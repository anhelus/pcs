{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python per il Calcolo Scientifico \u00b6 Benvenuti nel corso di Python per il Calcolo Scientifico ( PCS ). In questa pagina viene pubblicato il materiale e le informazioni relative al corso, nonch\u00e9 le slides proiettate a lezione. Attenzione Le dispense sono attualmente in fase di aggiornamento. Modalit\u00e0 di esame \u00b6 Le modalit\u00e0 di esame previste sono due: un esame orale , costituito da un colloquio nel quale saranno poste al candidato tre domande, due di natura teorica, ed una di natura pratica, strettamente inerenti i contenuti del corso; un tema d'anno , costituito da un progetto a scelta degli studenti, organizzati in gruppi da massimo tre (3) componenti . Il tema d'anno dovr\u00e0 essere prettamente pratico, e corredato da una breve presentazione ( massimo dodici (12) slides ) ed una relazione sul lavoro svolto ( massimo quattro (4) pagine ). Date di appello \u00b6 Le date di appello indicative sono le seguenti: Numero appello Data indicativa Primo 14/07/2022 Secondo 28/07/2022 Terzo 08/09/2022 Quarto 22/09/2022 Quinto 14/11/2022 Sesto 26/01/2023 Settimo 09/02/2023 Ottavo 16/02/2023 Salvo differenti disposizioni legate a recrudescenze della situazione pandemica, l' esame sar\u00e0 sostenuto in presenza , in un'aula del Dipartimento di Matematica da definirsi. Calendario delle lezioni \u00b6 Il calendario delle lezioni \u00e8 disponibile a questo link . Ricevimento \u00b6 E' possibile concordare un ricevimento inviando una e-mail all'indirizzo angelo.cardellicchio@stiima.cnr.it .","title":"Home"},{"location":"#python-per-il-calcolo-scientifico","text":"Benvenuti nel corso di Python per il Calcolo Scientifico ( PCS ). In questa pagina viene pubblicato il materiale e le informazioni relative al corso, nonch\u00e9 le slides proiettate a lezione. Attenzione Le dispense sono attualmente in fase di aggiornamento.","title":"Python per il Calcolo Scientifico"},{"location":"#modalita-di-esame","text":"Le modalit\u00e0 di esame previste sono due: un esame orale , costituito da un colloquio nel quale saranno poste al candidato tre domande, due di natura teorica, ed una di natura pratica, strettamente inerenti i contenuti del corso; un tema d'anno , costituito da un progetto a scelta degli studenti, organizzati in gruppi da massimo tre (3) componenti . Il tema d'anno dovr\u00e0 essere prettamente pratico, e corredato da una breve presentazione ( massimo dodici (12) slides ) ed una relazione sul lavoro svolto ( massimo quattro (4) pagine ).","title":"Modalit\u00e0 di esame"},{"location":"#date-di-appello","text":"Le date di appello indicative sono le seguenti: Numero appello Data indicativa Primo 14/07/2022 Secondo 28/07/2022 Terzo 08/09/2022 Quarto 22/09/2022 Quinto 14/11/2022 Sesto 26/01/2023 Settimo 09/02/2023 Ottavo 16/02/2023 Salvo differenti disposizioni legate a recrudescenze della situazione pandemica, l' esame sar\u00e0 sostenuto in presenza , in un'aula del Dipartimento di Matematica da definirsi.","title":"Date di appello"},{"location":"#calendario-delle-lezioni","text":"Il calendario delle lezioni \u00e8 disponibile a questo link .","title":"Calendario delle lezioni"},{"location":"#ricevimento","text":"E' possibile concordare un ricevimento inviando una e-mail all'indirizzo angelo.cardellicchio@stiima.cnr.it .","title":"Ricevimento"},{"location":"material/01_python/01_intro/exercises/","text":"E1 - Introduzione a Python \u00b6 E1.1 \u00b6 Creiamo una stringa che assuma valore PCS . S1.1 - Soluzione \u00b6 >>> s = 'PCS' E1.2 \u00b6 Valutiamo la lunghezza della stringa creata al punto 1. S1.2 - Soluzione \u00b6 >>> len ( s ) E1.3 \u00b6 Proviamo a creare una lista a partire dalla stringa creata al punto 1. S1.3 - Soluzione \u00b6 >>> l = [ 'pcs' ] >>> l = [ 'p' , 'c' , 's' ]","title":"E1 - Introduzione a Python"},{"location":"material/01_python/01_intro/exercises/#e1-introduzione-a-python","text":"","title":"E1 - Introduzione a Python"},{"location":"material/01_python/01_intro/exercises/#e11","text":"Creiamo una stringa che assuma valore PCS .","title":"E1.1"},{"location":"material/01_python/01_intro/exercises/#s11-soluzione","text":">>> s = 'PCS'","title":"S1.1 - Soluzione"},{"location":"material/01_python/01_intro/exercises/#e12","text":"Valutiamo la lunghezza della stringa creata al punto 1.","title":"E1.2"},{"location":"material/01_python/01_intro/exercises/#s12-soluzione","text":">>> len ( s )","title":"S1.2 - Soluzione"},{"location":"material/01_python/01_intro/exercises/#e13","text":"Proviamo a creare una lista a partire dalla stringa creata al punto 1.","title":"E1.3"},{"location":"material/01_python/01_intro/exercises/#s13-soluzione","text":">>> l = [ 'pcs' ] >>> l = [ 'p' , 'c' , 's' ]","title":"S1.3 - Soluzione"},{"location":"material/01_python/01_intro/lecture/","text":"1 - Introduzione a Python \u00b6 Prima di iniziare a parlare del linguaggio Python, \u00e8 opportuno verificare che l'interprete sia installato nel nostro sistema. Per farlo, apriamo un terminale (Shell o Command Prompt, a seconda del nostro sistema), e scriviamo: $ python Se apparir\u00e0 una schermata simile a quella mostrata in figura, Python sar\u00e0 gi\u00e0 correttamente presente nel nostro sistema. In alternativa, dovremo provvedere ad installarlo seguendo la procedura indicata sul sito ufficiale , ed aggiungerlo al path di sistema. 1.1 - Python e tipizzazione \u00b6 1.1.1 Tipizzazione dinamica \u00b6 Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 # Il risultato sar\u00e0 2.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing . 1.1.1.1 - Duck Typing \u00b6 Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta. 1.2 - L'interprete Python \u00b6 Nella sezione introduttiva abbiamo visto come installare l'interprete Python, in modo da avere un ambiente di lavoro accessibile direttamente mediante riga di comando. Lanciamolo di nuovo usando il seguente comando da una shell: python Potremo quindi finalmente iniziare ad utilizzare Python. 1.3 - Calcoli e numeri \u00b6 Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2 1.3.1 - Divisioni \u00b6 Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi. 1.3.2 - Elevazione a potenza \u00b6 Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria. 1.4 - Stringhe \u00b6 In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella 1.4.1 - Stringhe su righe multiple \u00b6 Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2. 1.4.2 - Concatenazione di stringhe \u00b6 Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore. 1.4.3 - Indicizzazione di stringhe \u00b6 Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n' 1.4.4 - Slicing su stringhe \u00b6 L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j : s ] dove i \u00e8 l'indice iniziale, j quello finale ed s lo step utilizzato. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python' 1.4.5 - Lunghezza di una stringa \u00b6 La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6 1.4.6 - Immutabilit\u00e0 di una stringa \u00b6 Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile. 1.5 - Liste \u00b6 Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] 1.5.1 - Concatenazione, indicizzazione e slicing su liste \u00b6 Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] 1.5.2 - Alcuni esempi \u00b6 Ecco alcuni esempi di slicing su lista, con annessi risultati ottenibili. Consideriamo la seguente stringa: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 ] Prendiamo gli elementi sugli indice pari (ovvero 0, 2 e 4): >>> l [ 0 :: 2 ] [ 1 , 3 , 5 ] Prendiamo tutti gli elementi a partire dal terzultimo e con indice pari: >>> l [ - 3 :: 2 ] [ 4 , 6 ] Partiamo dal terzultimo elemento, e proseguiamo all'indietro verso l'origine: >>> l [ - 3 :: - 1 ] [ 4 , 3 , 2 , 1 ] Partiamo dall'ultimo elemento e proseguiamo sino al terz'ultimo dall'origine: >>> l [: 3 : - 1 ] [ 6 , 5 ] Prendiamo gli ultimi tre elementi in ordine inverso: >>> l [ len ( l ) - 1 : len ( l ) - 4 : - 1 ] [ 6 , 5 , 4 ] Prendiamo gli elementi agli indici pari in ordine inverso: >>> l [:: - 2 ] [ 6 , 4 , 2 ] 1.5.3 - Mutabilit\u00e0 di una lista \u00b6 A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ] 1.5.4 - Operazioni sulle liste \u00b6 Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"01 - Introduzione a Python"},{"location":"material/01_python/01_intro/lecture/#1-introduzione-a-python","text":"Prima di iniziare a parlare del linguaggio Python, \u00e8 opportuno verificare che l'interprete sia installato nel nostro sistema. Per farlo, apriamo un terminale (Shell o Command Prompt, a seconda del nostro sistema), e scriviamo: $ python Se apparir\u00e0 una schermata simile a quella mostrata in figura, Python sar\u00e0 gi\u00e0 correttamente presente nel nostro sistema. In alternativa, dovremo provvedere ad installarlo seguendo la procedura indicata sul sito ufficiale , ed aggiungerlo al path di sistema.","title":"1 - Introduzione a Python"},{"location":"material/01_python/01_intro/lecture/#11-python-e-tipizzazione","text":"","title":"1.1 - Python e tipizzazione"},{"location":"material/01_python/01_intro/lecture/#111-tipizzazione-dinamica","text":"Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 # Il risultato sar\u00e0 2.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing .","title":"1.1.1 Tipizzazione dinamica"},{"location":"material/01_python/01_intro/lecture/#1111-duck-typing","text":"Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta.","title":"1.1.1.1 - Duck Typing"},{"location":"material/01_python/01_intro/lecture/#12-linterprete-python","text":"Nella sezione introduttiva abbiamo visto come installare l'interprete Python, in modo da avere un ambiente di lavoro accessibile direttamente mediante riga di comando. Lanciamolo di nuovo usando il seguente comando da una shell: python Potremo quindi finalmente iniziare ad utilizzare Python.","title":"1.2 - L'interprete Python"},{"location":"material/01_python/01_intro/lecture/#13-calcoli-e-numeri","text":"Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2","title":"1.3 - Calcoli e numeri"},{"location":"material/01_python/01_intro/lecture/#131-divisioni","text":"Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi.","title":"1.3.1 - Divisioni"},{"location":"material/01_python/01_intro/lecture/#132-elevazione-a-potenza","text":"Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria.","title":"1.3.2 - Elevazione a potenza"},{"location":"material/01_python/01_intro/lecture/#14-stringhe","text":"In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella","title":"1.4 - Stringhe"},{"location":"material/01_python/01_intro/lecture/#141-stringhe-su-righe-multiple","text":"Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2.","title":"1.4.1 - Stringhe su righe multiple"},{"location":"material/01_python/01_intro/lecture/#142-concatenazione-di-stringhe","text":"Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore.","title":"1.4.2 - Concatenazione di stringhe"},{"location":"material/01_python/01_intro/lecture/#143-indicizzazione-di-stringhe","text":"Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n'","title":"1.4.3 - Indicizzazione di stringhe"},{"location":"material/01_python/01_intro/lecture/#144-slicing-su-stringhe","text":"L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j : s ] dove i \u00e8 l'indice iniziale, j quello finale ed s lo step utilizzato. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python'","title":"1.4.4 - Slicing su stringhe"},{"location":"material/01_python/01_intro/lecture/#145-lunghezza-di-una-stringa","text":"La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6","title":"1.4.5 - Lunghezza di una stringa"},{"location":"material/01_python/01_intro/lecture/#146-immutabilita-di-una-stringa","text":"Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile.","title":"1.4.6 - Immutabilit\u00e0 di una stringa"},{"location":"material/01_python/01_intro/lecture/#15-liste","text":"Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ]","title":"1.5 - Liste"},{"location":"material/01_python/01_intro/lecture/#151-concatenazione-indicizzazione-e-slicing-su-liste","text":"Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ]","title":"1.5.1 - Concatenazione, indicizzazione e slicing su liste"},{"location":"material/01_python/01_intro/lecture/#152-alcuni-esempi","text":"Ecco alcuni esempi di slicing su lista, con annessi risultati ottenibili. Consideriamo la seguente stringa: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 ] Prendiamo gli elementi sugli indice pari (ovvero 0, 2 e 4): >>> l [ 0 :: 2 ] [ 1 , 3 , 5 ] Prendiamo tutti gli elementi a partire dal terzultimo e con indice pari: >>> l [ - 3 :: 2 ] [ 4 , 6 ] Partiamo dal terzultimo elemento, e proseguiamo all'indietro verso l'origine: >>> l [ - 3 :: - 1 ] [ 4 , 3 , 2 , 1 ] Partiamo dall'ultimo elemento e proseguiamo sino al terz'ultimo dall'origine: >>> l [: 3 : - 1 ] [ 6 , 5 ] Prendiamo gli ultimi tre elementi in ordine inverso: >>> l [ len ( l ) - 1 : len ( l ) - 4 : - 1 ] [ 6 , 5 , 4 ] Prendiamo gli elementi agli indici pari in ordine inverso: >>> l [:: - 2 ] [ 6 , 4 , 2 ]","title":"1.5.2 - Alcuni esempi"},{"location":"material/01_python/01_intro/lecture/#153-mutabilita-di-una-lista","text":"A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ]","title":"1.5.3 - Mutabilit\u00e0 di una lista"},{"location":"material/01_python/01_intro/lecture/#154-operazioni-sulle-liste","text":"Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"1.5.4 - Operazioni sulle liste"},{"location":"material/01_python/02_syntax/exercises/","text":"E2 - Programmare in Python \u00b6 E2.1 \u00b6 Scriviamo una funzione che iteri fino a che il valore associato ad un contatore intero \u00e8 minore di 10. Usiamo un ciclo while . S2.1 - Soluzione \u00b6 def itera_while (): i = 0 while i < 10 : i = i + 1 print ( \" {} -ma iterazione\" . format ( i )) Il risultato ottenuto sar\u00e0: >>> itera_while () 1 - ma iterazione 2 - ma iterazione 3 - ma iterazione 4 - ma iterazione 5 - ma iterazione 6 - ma iterazione 7 - ma iterazione 8 - ma iterazione 9 - ma iterazione 10 - ma iterazione E2.2 \u00b6 Scriviamo una funzione che iteri fino a che una condizione booleana non \u00e8 False . Usiamo un ciclo for , ponendo come numero massimo di iterazioni 100 e se necessario, usando il metodo random.randint(a, b) . S2.2 - Soluzione \u00b6 def itera_for (): cond = True for i in range ( 100 ): eval = random . randint ( - 10 , 10 ) print ( 'Valuto numero {} ' . format ( eval )) if eval < 0 : print ( 'Esco' ) cond = False return cond else : print ( 'Continuo' ) return cond Il risultato ottenuto sar\u00e0: >>> itera_for () Valuto numero 6 Continuo Valuto numero 7 Continuo Valuto numero 8 Continuo Valuto numero - 4 Esco False E2.3 \u00b6 Estraiamo tutti gli indici pari di una lista arbitraria di dieci elementi in ordine inverso. Per farlo, usiamo sia la funzione range sia lo slicing. S2.3 - Soluzione \u00b6 def estrai_con_slice ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : return lista [ - 2 :: - 2 ] def estrai_con_range ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : l_out = [] for i in range ( 8 , - 1 , - 2 ): l_out . append ( lista [ i ]) return l_out Il risultato ottenuto sar\u00e0: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> estrai_con_slice ( l ) [ 10 , 8 , 6 , 4 , 2 ] >>> estrai_con_range ( l ) [ 10 , 8 , 6 , 4 , 2 ] E2.4 \u00b6 Utilizzare il pattern matching per stampare a schermo la parola \"Vero\" se il valore di una variabile \u00e8 True , e \"Falso\" altrimenti. S2.4 - Soluzione \u00b6 def match_case ( true_or_false ): match true_or_false : case True : return \"Vero\" case False : return \"Falso\" Il risultato ottenuto sar\u00e0: >>> a = True >>> match_case ( a ) 'Vero' >>> b = False >>> match_case ( b ) 'Falso' E2.5 \u00b6 Creare un metodo che raddoppi una lista passata come argomento in ingresso. Provare ad utilizzare un ciclo for e ricordare la differenza tra shallow e deep copy. S2.5 - Soluzione \u00b6 Potremmo essere tentati di scrivere una funzione come la seguente: def raddoppia_lista ( lista ): for elemento in lista : lista . append ( elemento ) print ( f \"Lista all'iterazione attuale: { lista } \" ) Proviamo a chiamare questa funzione; avremo subito un output ingestibile. Ci\u00f2 \u00e8 legato al fatto che Python \u00e8 fermo in un loop infinito: il metodo agisce sulla lista originaria, che ad ogni iterazione del ciclo \"ingloba\" un altro elemento, provocando di conseguenza un aumento delle dimensioni della lista e, quindi, un'ulteriore iterazione, e cos\u00ec via all'infinito. Possiamo per\u00f2 ottenere il risultato che ci serve usando il metodo deepcopy : from copy import deepcopy def raddoppia_lista_deep ( lista ): lista_appoggio = deepcopy ( lista ) for elemento in lista_appoggio : lista . append ( elemento ) print ( f \"Lista di appoggio: { lista_appoggio } \" ) print ( f \"Lista attuale: { lista } \" ) In questo caso, stiamo creando un'altra variabile, chiamata lista_appoggio , che sar\u00e0 utilizzata come \"buffer\" per aggiungere alla lista originaria gli elementi relativi a s\u00e9 stessa. Provando a chiamare questo codice otterremo il risultato desiderato: >>> raddoppia_lista_deep ([ 1 , 2 ]) Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 ] Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 , 2 ]","title":"E2 - Programmare in Python"},{"location":"material/01_python/02_syntax/exercises/#e2-programmare-in-python","text":"","title":"E2 - Programmare in Python"},{"location":"material/01_python/02_syntax/exercises/#e21","text":"Scriviamo una funzione che iteri fino a che il valore associato ad un contatore intero \u00e8 minore di 10. Usiamo un ciclo while .","title":"E2.1"},{"location":"material/01_python/02_syntax/exercises/#s21-soluzione","text":"def itera_while (): i = 0 while i < 10 : i = i + 1 print ( \" {} -ma iterazione\" . format ( i )) Il risultato ottenuto sar\u00e0: >>> itera_while () 1 - ma iterazione 2 - ma iterazione 3 - ma iterazione 4 - ma iterazione 5 - ma iterazione 6 - ma iterazione 7 - ma iterazione 8 - ma iterazione 9 - ma iterazione 10 - ma iterazione","title":"S2.1 - Soluzione"},{"location":"material/01_python/02_syntax/exercises/#e22","text":"Scriviamo una funzione che iteri fino a che una condizione booleana non \u00e8 False . Usiamo un ciclo for , ponendo come numero massimo di iterazioni 100 e se necessario, usando il metodo random.randint(a, b) .","title":"E2.2"},{"location":"material/01_python/02_syntax/exercises/#s22-soluzione","text":"def itera_for (): cond = True for i in range ( 100 ): eval = random . randint ( - 10 , 10 ) print ( 'Valuto numero {} ' . format ( eval )) if eval < 0 : print ( 'Esco' ) cond = False return cond else : print ( 'Continuo' ) return cond Il risultato ottenuto sar\u00e0: >>> itera_for () Valuto numero 6 Continuo Valuto numero 7 Continuo Valuto numero 8 Continuo Valuto numero - 4 Esco False","title":"S2.2 - Soluzione"},{"location":"material/01_python/02_syntax/exercises/#e23","text":"Estraiamo tutti gli indici pari di una lista arbitraria di dieci elementi in ordine inverso. Per farlo, usiamo sia la funzione range sia lo slicing.","title":"E2.3"},{"location":"material/01_python/02_syntax/exercises/#s23-soluzione","text":"def estrai_con_slice ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : return lista [ - 2 :: - 2 ] def estrai_con_range ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : l_out = [] for i in range ( 8 , - 1 , - 2 ): l_out . append ( lista [ i ]) return l_out Il risultato ottenuto sar\u00e0: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> estrai_con_slice ( l ) [ 10 , 8 , 6 , 4 , 2 ] >>> estrai_con_range ( l ) [ 10 , 8 , 6 , 4 , 2 ]","title":"S2.3 - Soluzione"},{"location":"material/01_python/02_syntax/exercises/#e24","text":"Utilizzare il pattern matching per stampare a schermo la parola \"Vero\" se il valore di una variabile \u00e8 True , e \"Falso\" altrimenti.","title":"E2.4"},{"location":"material/01_python/02_syntax/exercises/#s24-soluzione","text":"def match_case ( true_or_false ): match true_or_false : case True : return \"Vero\" case False : return \"Falso\" Il risultato ottenuto sar\u00e0: >>> a = True >>> match_case ( a ) 'Vero' >>> b = False >>> match_case ( b ) 'Falso'","title":"S2.4 - Soluzione"},{"location":"material/01_python/02_syntax/exercises/#e25","text":"Creare un metodo che raddoppi una lista passata come argomento in ingresso. Provare ad utilizzare un ciclo for e ricordare la differenza tra shallow e deep copy.","title":"E2.5"},{"location":"material/01_python/02_syntax/exercises/#s25-soluzione","text":"Potremmo essere tentati di scrivere una funzione come la seguente: def raddoppia_lista ( lista ): for elemento in lista : lista . append ( elemento ) print ( f \"Lista all'iterazione attuale: { lista } \" ) Proviamo a chiamare questa funzione; avremo subito un output ingestibile. Ci\u00f2 \u00e8 legato al fatto che Python \u00e8 fermo in un loop infinito: il metodo agisce sulla lista originaria, che ad ogni iterazione del ciclo \"ingloba\" un altro elemento, provocando di conseguenza un aumento delle dimensioni della lista e, quindi, un'ulteriore iterazione, e cos\u00ec via all'infinito. Possiamo per\u00f2 ottenere il risultato che ci serve usando il metodo deepcopy : from copy import deepcopy def raddoppia_lista_deep ( lista ): lista_appoggio = deepcopy ( lista ) for elemento in lista_appoggio : lista . append ( elemento ) print ( f \"Lista di appoggio: { lista_appoggio } \" ) print ( f \"Lista attuale: { lista } \" ) In questo caso, stiamo creando un'altra variabile, chiamata lista_appoggio , che sar\u00e0 utilizzata come \"buffer\" per aggiungere alla lista originaria gli elementi relativi a s\u00e9 stessa. Provando a chiamare questo codice otterremo il risultato desiderato: >>> raddoppia_lista_deep ([ 1 , 2 ]) Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 ] Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 , 2 ]","title":"S2.5 - Soluzione"},{"location":"material/01_python/02_syntax/lecture/","text":"2 - Programmare in Python \u00b6 2.1 - Alcuni concetti sintattici fondamentali \u00b6 Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente. 2.1.1 - Uso delle parentesi \u00b6 Le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse. Ad esempio: a = 2 b = 3 c = 4 r_1 = a + b * c # Valore restituito: 14 r_2 = ( a + b ) * c # Valore restituito: 24 if a > 2 : # Questa notazione \u00e8 valida, ed \u00e8 equivalente ad (a > 2) 2. Le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una struttura dati. # Creo una lista lista = [ 1 , 2 , 3 ] # Accedo al secondo elemento della lista lista [ 1 ] # Il valore acceduto \u00e8 2 3. Le parentesi graffe sono usate per la creazione di un dizionario. dizionario = { 'a' : 1 , 'b' : 2 } # Notiamo che per accedere ad una chiave di un dizionario useremo comunque la parentesi quadra. dizionario [ a ] # Il valore acceduto \u00e8 1, ovvero quello relativo alla chiave 'a' 2.1.2 - Ambito e termine di un'istruzione \u00b6 A differenza del C, che prevede che ogni istruzione sia terminata da un punto e virgola, Python prevede che un'istruzione termini quando si va a capo. Quindi: a = 1 # L'istruzione di assegnazione \u00e8 terminata! In altre parole, si pu\u00f2 omettere il punto e virgola. Per quello che riguarda invece la definizione di un ambito, ad esempio locale all'interno di una funzione, Python si affida ai due punti , che sostituiscono la parentesi graffa di apertura, ed al numero di indentazioni . Ambito e indentazioni In generale, possiamo dire che le istruzioni allo stesso livello di indentazione sono considerate dall'interprete Python come istruzioni appartenenti al medesimo ambito. Quindi: # L'inizio della funzione, e quindi dell'ambito # che questa delimita, \u00e8 contrassegnato dai due punti def funzione (): # Inizio ambito # Il codice deve essere allo stesso livello di indentazione a = 1 a + 1 # ... return 0 Le indentazioni Per ottenere l'indentazione, occorre usare il tasto tab sulla tastiera, oppure quattro spazi. E' comunque estremamente importante non mescolare le due tecniche. 2.2 - Programmazione strutturata \u00b6 Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like. 2.2.1 - Istruzioni condizionali ( if ) \u00b6 Partiamo dall'istruzione condizionale if . Questa, in Python, ha una sintassi di questo tipo. if condizione : istruzioni () elif altra_condizione : altre_istruzioni () else : ultime_istruzioni () Notiamo l'utilizzo della keyword elif come crasi della forma else if utilizzata in altri linguaggi di programmazione. Ad esempio, se volessimo verificare il valore di una variabile intera, potremmo scrivere: a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) L'output di questo controllo sar\u00e0: a \u00e8 uguale a 5 2.2.2 - Pattern matching \u00b6 Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"caso 1\" : istruzioni () case \"altro caso\" : print ( \"Comando sconosciuto\" ) 2.2.3 - Cicli \u00b6 2.2.3.1 - Ciclo for \u00b6 Il ciclo for itera su una sequenza , come una lista o una stringa, ed ha una sintassi del tipo: for elemento in sequenza : istruzioni () Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, il ciclo for opera esclusivamente sugli iterabili , per cui potrebbe in qualche caso occorrere una riprogettazione del codice. Tuttavia, questa caratteristica di Python comporta anche una maggiore semplicit\u00e0 del codice; ad esempio, vediamo come \u00e8 molto semplice iterare su una stringa: string = \"Python\" for char in string : print ( char ) A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n No free lunches! Come ci ricorda il no free lunches theorem , non esistono pasti gratuiti ! Infatti, la maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti. 2.2.3.2 - Ciclo while \u00b6 A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello delle controparti negli altri linguaggi di programmazione. La sintassi generica \u00e8: while ( condizione ): istruzioni () Ad esempio: i = True while ( i ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) else : print ( \"Esco!\" ) i = False Il codice nel blocco precedente non fa altro che generare un valore numerico intero casuale nell'intervallo \\([-5, 5]\\) mediante la funzione randint . Se tale valore \u00e8 superiore a \\(0\\) , il ciclo continua, altrimenti si esce dallo stesso. A schermo vedremo, ad esempio: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola. 2.4 - La funzione range() \u00b6 Riprendiamo adesso il ciclo for visto in precedenza. vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: r = range ( 0 , 5 , 1 ) print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Esercizio : Proviamo ad iterare su tutti i valori della lista ['Pippo', 'Pluto', 5, 'Paperino'] . Soluzione : Usiamo la funzione range() assieme alla funzione len() : l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] for i in range ( len ( l )): print ( l [ i ]) # Output Pippo Pluto 5 Paperino In pratica, dato che la funzione len(l) ci restituisce il numero di elementi nella lista, ovvero \\(4\\) , stiamo andando a definire un range che va da 0 a 3. A questo punto, ci baster\u00e0 elemento per elemento ai valori contenuti all'interno della lista, ed avremo ottenuto il risultato sperato. 2.5 - Istruzioni break e continue \u00b6 Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: while ( True ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) continue else : print ( \"Esco!\" ) break print ( \"Sono uscito!\" ) Le istruzioni precedenti usciranno dal ciclo quando viene generato casualmente un numero negativo, mentre continueranno ad iterare quando viene generato casualmente un numero positivo. 2.6 - Definire una funzione \u00b6 In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri opzionali , con valori di default. Esercizio : Creiamo una funzione che concateni ad una lista il doppio dei singoli valori presenti nella stessa. Soluzione : usiamo la funzione append per mettere in coda i nuovi elementi della lista. def raddoppia_lista ( lista ): for i in range ( len ( lista )): lista . append ( l [ i ] * 2 ) l = [ 1 , 2 ] raddoppia_lista ( l ) # Risultato atteso: [1, 2, 2, 4] Esercizio : Creiamo una funzione che generi una lista di elementi casuali tra \\(0\\) e \\(10\\) , usando un parametro opzionale per specificarne la lunghezza. Soluzione : usiamo la funzione append() in accoppiata alla funzione randint() . def genera_lista_casuale ( lunghezza = 5 ): l = [] for i in range ( lunghezza ): l . append ( randint ( 0 , 10 )) return l ... genera_lista_casuale () # Possibile risultato: [3, 1, 2, 0, 6] genera_lista_casuale ( 10 ) # Possibile risultato: [7, 9, 1, 10, 2, 4, 9, 1, 4, 8] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore. 2.6.1 - Passaggio di parametri a funzione \u00b6 Python prevede che i parametri siano passati ad una funzione secondo una modalit\u00e0 ibrida chiamata call-by-assignment . In pratica, il passaggio avviene esclusivamente per valore , ma con effetti differenti su tipi mutabili ed immutabili. Ad esempio, provando a passare un valore primitivo (come un intero), Python si comporter\u00e0 come se si stesse effettuando un passaggio per valore: def raddoppia ( intero ): intero = intero * 2 print ( f 'Valore all \\' interno della funzione: { intero } ' ) Il risultato sar\u00e0: >>> intero = 1 >>> raddoppia ( intero ) \"Valore all'interno della funzione: 2\" >>> print ( f 'Valore all \\' esterno della funzione: { intero } ' ) \"Valore all'interno della funzione: 1\" Ci\u00f2 \u00e8 legato al fatto che il passaggio viene effettuato per valore, per cui la funzione raddoppia agir\u00e0 su una copia della variabile passata come argomento, e non sulla variabile originaria. Se invece usassimo una funzione che modifica una lista: def aggiungi_a_lista ( lista , elemento ): lista . append ( elemento ) print ( f 'Valore all \\' interno della funzione: { lista } ' ) Il risultato sar\u00e0: >>> lista = [ 1 , 2 ] >>> aggiungi_a_lista ( lista , 3 ) \"Valore all'interno della funzione: [1, 2, 3]\" >>> print ( f 'Valore all \\' esterno della funzione: { lista } ' ) \"Valore all'interno della funzione: [1, 2, 3]\" In questo caso, essendo la lista mutabile, il passaggio viene effettuato nei fatti per reference : ci\u00f2 significa che le operazioni comppiute all'interno della funzione aggiungi_a_lista agiranno sulla lista originaria. Shallow e deep copy Di default, Python copia le variabili per mezzo di una shallow copy : ci\u00f2 significa che un'operazione di assignment del tipo a = b fa in modo che a punti allo stesso indirizzo di memoria di b e, di conseguenza, ogni modifica a b si rifletta su a . Per evitare un fenomeno di questo tipo occorre usare una deep copy grazie alla funzione deepcopy della libreria copy . 2.6.2 - L'istruzione pass \u00b6 Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, esistono diverse situazioni in cui l'istruzione pass risulta essere estremamente utile.","title":"02 - Programmare in Python"},{"location":"material/01_python/02_syntax/lecture/#2-programmare-in-python","text":"","title":"2 - Programmare in Python"},{"location":"material/01_python/02_syntax/lecture/#21-alcuni-concetti-sintattici-fondamentali","text":"Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente.","title":"2.1 - Alcuni concetti sintattici fondamentali"},{"location":"material/01_python/02_syntax/lecture/#211-uso-delle-parentesi","text":"Le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse. Ad esempio: a = 2 b = 3 c = 4 r_1 = a + b * c # Valore restituito: 14 r_2 = ( a + b ) * c # Valore restituito: 24 if a > 2 : # Questa notazione \u00e8 valida, ed \u00e8 equivalente ad (a > 2) 2. Le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una struttura dati. # Creo una lista lista = [ 1 , 2 , 3 ] # Accedo al secondo elemento della lista lista [ 1 ] # Il valore acceduto \u00e8 2 3. Le parentesi graffe sono usate per la creazione di un dizionario. dizionario = { 'a' : 1 , 'b' : 2 } # Notiamo che per accedere ad una chiave di un dizionario useremo comunque la parentesi quadra. dizionario [ a ] # Il valore acceduto \u00e8 1, ovvero quello relativo alla chiave 'a'","title":"2.1.1 - Uso delle parentesi"},{"location":"material/01_python/02_syntax/lecture/#212-ambito-e-termine-di-unistruzione","text":"A differenza del C, che prevede che ogni istruzione sia terminata da un punto e virgola, Python prevede che un'istruzione termini quando si va a capo. Quindi: a = 1 # L'istruzione di assegnazione \u00e8 terminata! In altre parole, si pu\u00f2 omettere il punto e virgola. Per quello che riguarda invece la definizione di un ambito, ad esempio locale all'interno di una funzione, Python si affida ai due punti , che sostituiscono la parentesi graffa di apertura, ed al numero di indentazioni . Ambito e indentazioni In generale, possiamo dire che le istruzioni allo stesso livello di indentazione sono considerate dall'interprete Python come istruzioni appartenenti al medesimo ambito. Quindi: # L'inizio della funzione, e quindi dell'ambito # che questa delimita, \u00e8 contrassegnato dai due punti def funzione (): # Inizio ambito # Il codice deve essere allo stesso livello di indentazione a = 1 a + 1 # ... return 0 Le indentazioni Per ottenere l'indentazione, occorre usare il tasto tab sulla tastiera, oppure quattro spazi. E' comunque estremamente importante non mescolare le due tecniche.","title":"2.1.2 - Ambito e termine di un'istruzione"},{"location":"material/01_python/02_syntax/lecture/#22-programmazione-strutturata","text":"Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like.","title":"2.2 - Programmazione strutturata"},{"location":"material/01_python/02_syntax/lecture/#221-istruzioni-condizionali-if","text":"Partiamo dall'istruzione condizionale if . Questa, in Python, ha una sintassi di questo tipo. if condizione : istruzioni () elif altra_condizione : altre_istruzioni () else : ultime_istruzioni () Notiamo l'utilizzo della keyword elif come crasi della forma else if utilizzata in altri linguaggi di programmazione. Ad esempio, se volessimo verificare il valore di una variabile intera, potremmo scrivere: a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) L'output di questo controllo sar\u00e0: a \u00e8 uguale a 5","title":"2.2.1 - Istruzioni condizionali (if)"},{"location":"material/01_python/02_syntax/lecture/#222-pattern-matching","text":"Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"caso 1\" : istruzioni () case \"altro caso\" : print ( \"Comando sconosciuto\" )","title":"2.2.2 - Pattern matching"},{"location":"material/01_python/02_syntax/lecture/#223-cicli","text":"","title":"2.2.3 - Cicli"},{"location":"material/01_python/02_syntax/lecture/#2231-ciclo-for","text":"Il ciclo for itera su una sequenza , come una lista o una stringa, ed ha una sintassi del tipo: for elemento in sequenza : istruzioni () Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, il ciclo for opera esclusivamente sugli iterabili , per cui potrebbe in qualche caso occorrere una riprogettazione del codice. Tuttavia, questa caratteristica di Python comporta anche una maggiore semplicit\u00e0 del codice; ad esempio, vediamo come \u00e8 molto semplice iterare su una stringa: string = \"Python\" for char in string : print ( char ) A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n No free lunches! Come ci ricorda il no free lunches theorem , non esistono pasti gratuiti ! Infatti, la maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti.","title":"2.2.3.1 - Ciclo for"},{"location":"material/01_python/02_syntax/lecture/#2232-ciclo-while","text":"A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello delle controparti negli altri linguaggi di programmazione. La sintassi generica \u00e8: while ( condizione ): istruzioni () Ad esempio: i = True while ( i ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) else : print ( \"Esco!\" ) i = False Il codice nel blocco precedente non fa altro che generare un valore numerico intero casuale nell'intervallo \\([-5, 5]\\) mediante la funzione randint . Se tale valore \u00e8 superiore a \\(0\\) , il ciclo continua, altrimenti si esce dallo stesso. A schermo vedremo, ad esempio: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola.","title":"2.2.3.2 - Ciclo while"},{"location":"material/01_python/02_syntax/lecture/#24-la-funzione-range","text":"Riprendiamo adesso il ciclo for visto in precedenza. vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: r = range ( 0 , 5 , 1 ) print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Esercizio : Proviamo ad iterare su tutti i valori della lista ['Pippo', 'Pluto', 5, 'Paperino'] . Soluzione : Usiamo la funzione range() assieme alla funzione len() : l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] for i in range ( len ( l )): print ( l [ i ]) # Output Pippo Pluto 5 Paperino In pratica, dato che la funzione len(l) ci restituisce il numero di elementi nella lista, ovvero \\(4\\) , stiamo andando a definire un range che va da 0 a 3. A questo punto, ci baster\u00e0 elemento per elemento ai valori contenuti all'interno della lista, ed avremo ottenuto il risultato sperato.","title":"2.4 - La funzione range()"},{"location":"material/01_python/02_syntax/lecture/#25-istruzioni-break-e-continue","text":"Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: while ( True ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) continue else : print ( \"Esco!\" ) break print ( \"Sono uscito!\" ) Le istruzioni precedenti usciranno dal ciclo quando viene generato casualmente un numero negativo, mentre continueranno ad iterare quando viene generato casualmente un numero positivo.","title":"2.5 - Istruzioni break e continue"},{"location":"material/01_python/02_syntax/lecture/#26-definire-una-funzione","text":"In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri opzionali , con valori di default. Esercizio : Creiamo una funzione che concateni ad una lista il doppio dei singoli valori presenti nella stessa. Soluzione : usiamo la funzione append per mettere in coda i nuovi elementi della lista. def raddoppia_lista ( lista ): for i in range ( len ( lista )): lista . append ( l [ i ] * 2 ) l = [ 1 , 2 ] raddoppia_lista ( l ) # Risultato atteso: [1, 2, 2, 4] Esercizio : Creiamo una funzione che generi una lista di elementi casuali tra \\(0\\) e \\(10\\) , usando un parametro opzionale per specificarne la lunghezza. Soluzione : usiamo la funzione append() in accoppiata alla funzione randint() . def genera_lista_casuale ( lunghezza = 5 ): l = [] for i in range ( lunghezza ): l . append ( randint ( 0 , 10 )) return l ... genera_lista_casuale () # Possibile risultato: [3, 1, 2, 0, 6] genera_lista_casuale ( 10 ) # Possibile risultato: [7, 9, 1, 10, 2, 4, 9, 1, 4, 8] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore.","title":"2.6 - Definire una funzione"},{"location":"material/01_python/02_syntax/lecture/#261-passaggio-di-parametri-a-funzione","text":"Python prevede che i parametri siano passati ad una funzione secondo una modalit\u00e0 ibrida chiamata call-by-assignment . In pratica, il passaggio avviene esclusivamente per valore , ma con effetti differenti su tipi mutabili ed immutabili. Ad esempio, provando a passare un valore primitivo (come un intero), Python si comporter\u00e0 come se si stesse effettuando un passaggio per valore: def raddoppia ( intero ): intero = intero * 2 print ( f 'Valore all \\' interno della funzione: { intero } ' ) Il risultato sar\u00e0: >>> intero = 1 >>> raddoppia ( intero ) \"Valore all'interno della funzione: 2\" >>> print ( f 'Valore all \\' esterno della funzione: { intero } ' ) \"Valore all'interno della funzione: 1\" Ci\u00f2 \u00e8 legato al fatto che il passaggio viene effettuato per valore, per cui la funzione raddoppia agir\u00e0 su una copia della variabile passata come argomento, e non sulla variabile originaria. Se invece usassimo una funzione che modifica una lista: def aggiungi_a_lista ( lista , elemento ): lista . append ( elemento ) print ( f 'Valore all \\' interno della funzione: { lista } ' ) Il risultato sar\u00e0: >>> lista = [ 1 , 2 ] >>> aggiungi_a_lista ( lista , 3 ) \"Valore all'interno della funzione: [1, 2, 3]\" >>> print ( f 'Valore all \\' esterno della funzione: { lista } ' ) \"Valore all'interno della funzione: [1, 2, 3]\" In questo caso, essendo la lista mutabile, il passaggio viene effettuato nei fatti per reference : ci\u00f2 significa che le operazioni comppiute all'interno della funzione aggiungi_a_lista agiranno sulla lista originaria. Shallow e deep copy Di default, Python copia le variabili per mezzo di una shallow copy : ci\u00f2 significa che un'operazione di assignment del tipo a = b fa in modo che a punti allo stesso indirizzo di memoria di b e, di conseguenza, ogni modifica a b si rifletta su a . Per evitare un fenomeno di questo tipo occorre usare una deep copy grazie alla funzione deepcopy della libreria copy .","title":"2.6.1 - Passaggio di parametri a funzione"},{"location":"material/01_python/02_syntax/lecture/#262-listruzione-pass","text":"Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, esistono diverse situazioni in cui l'istruzione pass risulta essere estremamente utile.","title":"2.6.2 - L'istruzione pass"},{"location":"material/01_python/03_data_structures/exercises/","text":"E3 - Esercizi sulle strutture dati \u00b6 E3.1 \u00b6 Proviamo a valutare il tempo necessario alle operazioni di insert e pop su una coda in Python usando la libreria time . Confrontiamo il risultato ottenuto con quello ottenibile implementando una coda come una struttura di tipo deque e usando gli opportuni metodi appendleft e popleft . S3.1 - Soluzione \u00b6 from time import time from collections import deque def queue ( queue , pushed = 1 ): tic = time () queue . insert ( 0 , 4 ) queue . pop () toc = time () return tic , toc def queue_con_deque ( queue , pushed = 1 ): tic = time () queue . appendleft ( pushed ) queue . popleft () toc = time () return tic , toc Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo un output simile al seguente: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0 E3.2 \u00b6 Selezioniamo tutti i nomi che iniziano con la lettera B dalla seguente lista: lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] Facciamolo usando un ciclo ed una list comprehension. S3.2 - Soluzione \u00b6 Usando un ciclo: output_for = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output_for . append ( nome ) Usando una list comprehension: output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] E3.3 \u00b6 Ottenere una lista che abbia al suo interno tutti i quadrati dei numeri che vanno da 1 a 10 S3.3 - Soluzione \u00b6 Usando un ciclo: def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 1 , 11 ): output . append ( quadrato ( i )) Usando una list comprehension: output = [ quadrato ( i ) for i in range ( 1 , 11 )] E3.4 \u00b6 Ottenere una lista che abbia la stringa pari in corrispondenza dei numeri pari, mentre quella dispari in corrispondenza dei numeri dispari, per tutti i numeri che vanno da 1 a 10. S3.4 - Soluzione \u00b6 Usando un ciclo: output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \"pari\" ) else : output . append ( \"dispari\" ) Usando una list comprehension: output = [ \"pari\" if i % 2 == 0 else \"dispari\" for i in range ( 1 , 10 )] Suggerimento Possiamo usare la forma base della list comprehension definendo una funzione accessoria. Ad esempio: def pari_o_dispari ( numero ): if numero % 2 == 0 : return 'pari' else : return 'dispari' E3.5 \u00b6 Scrivere una dict comprehension che permetta di ottenere il dizionario vecchio_o_giovane dato il seguente dizionario: dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } In particolare, il dizionario vecchio_o_giovane avr\u00e0 le stesse chiavi del dizionario di partenza, a cui sar\u00e0 associato il valore giovane soltanto se il valore della chiave del dizionario di partenza \u00e8 inferiore a 65. S3.5 - Soluzione \u00b6 vecchio_o_giovane = { k : 'vecchio' if v > 65 else 'giovane' for ( k , v ) in dizionario . items () } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"E3 - Strutture dati in Python"},{"location":"material/01_python/03_data_structures/exercises/#e3-esercizi-sulle-strutture-dati","text":"","title":"E3 - Esercizi sulle strutture dati"},{"location":"material/01_python/03_data_structures/exercises/#e31","text":"Proviamo a valutare il tempo necessario alle operazioni di insert e pop su una coda in Python usando la libreria time . Confrontiamo il risultato ottenuto con quello ottenibile implementando una coda come una struttura di tipo deque e usando gli opportuni metodi appendleft e popleft .","title":"E3.1"},{"location":"material/01_python/03_data_structures/exercises/#s31-soluzione","text":"from time import time from collections import deque def queue ( queue , pushed = 1 ): tic = time () queue . insert ( 0 , 4 ) queue . pop () toc = time () return tic , toc def queue_con_deque ( queue , pushed = 1 ): tic = time () queue . appendleft ( pushed ) queue . popleft () toc = time () return tic , toc Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo un output simile al seguente: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0","title":"S3.1 - Soluzione"},{"location":"material/01_python/03_data_structures/exercises/#e32","text":"Selezioniamo tutti i nomi che iniziano con la lettera B dalla seguente lista: lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] Facciamolo usando un ciclo ed una list comprehension.","title":"E3.2"},{"location":"material/01_python/03_data_structures/exercises/#s32-soluzione","text":"Usando un ciclo: output_for = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output_for . append ( nome ) Usando una list comprehension: output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ]","title":"S3.2 - Soluzione"},{"location":"material/01_python/03_data_structures/exercises/#e33","text":"Ottenere una lista che abbia al suo interno tutti i quadrati dei numeri che vanno da 1 a 10","title":"E3.3"},{"location":"material/01_python/03_data_structures/exercises/#s33-soluzione","text":"Usando un ciclo: def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 1 , 11 ): output . append ( quadrato ( i )) Usando una list comprehension: output = [ quadrato ( i ) for i in range ( 1 , 11 )]","title":"S3.3 - Soluzione"},{"location":"material/01_python/03_data_structures/exercises/#e34","text":"Ottenere una lista che abbia la stringa pari in corrispondenza dei numeri pari, mentre quella dispari in corrispondenza dei numeri dispari, per tutti i numeri che vanno da 1 a 10.","title":"E3.4"},{"location":"material/01_python/03_data_structures/exercises/#s34-soluzione","text":"Usando un ciclo: output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \"pari\" ) else : output . append ( \"dispari\" ) Usando una list comprehension: output = [ \"pari\" if i % 2 == 0 else \"dispari\" for i in range ( 1 , 10 )] Suggerimento Possiamo usare la forma base della list comprehension definendo una funzione accessoria. Ad esempio: def pari_o_dispari ( numero ): if numero % 2 == 0 : return 'pari' else : return 'dispari'","title":"S3.4 - Soluzione"},{"location":"material/01_python/03_data_structures/exercises/#e35","text":"Scrivere una dict comprehension che permetta di ottenere il dizionario vecchio_o_giovane dato il seguente dizionario: dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } In particolare, il dizionario vecchio_o_giovane avr\u00e0 le stesse chiavi del dizionario di partenza, a cui sar\u00e0 associato il valore giovane soltanto se il valore della chiave del dizionario di partenza \u00e8 inferiore a 65.","title":"E3.5"},{"location":"material/01_python/03_data_structures/exercises/#s35-soluzione","text":"vecchio_o_giovane = { k : 'vecchio' if v > 65 else 'giovane' for ( k , v ) in dizionario . items () } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"S3.5 - Soluzione"},{"location":"material/01_python/03_data_structures/lecture/","text":"3 - Strutture dati in Python \u00b6 3.1 - Liste, pile e code \u00b6 Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi. 3.1.1 - Pila \u00b6 Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. Ad esempio: s = [ 1 , 2 , 3 ] s . append ( 4 ) # s sar\u00e0 pari a [1, 2, 3, 4] e = s . pop () # e sar\u00e0 pari a 4, mentre s sar\u00e0 pari a [1, 2, 3] 3.1.2 - Coda \u00b6 Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec. Per implementare una coda a partire da una lista, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . q = [ 1 , 2 , 3 ] q . insert ( 0 , 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . pop ( 0 ) # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: from collections import deque q = deque ([ 1 , 2 , 3 ]) q . appendleft ( 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . popleft () # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Nota Sottolineamo che q non \u00e8 pi\u00f9 una lista, ma una deque . 3.2 - List comprehension \u00b6 Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input. 3.2.1 - Forma estesa con if-else \u00b6 La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Perch\u00e9 usare le list comprehension? Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension. 3.3 - Le assignment expressions \u00b6 Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 3.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] 3.4 - Tuple \u00b6 Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: tupla = ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: tupla = ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: tupla [ 2 ] = [ 2 , 2 , 3 ] Apparir\u00e0 un errore simile a questo: Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> TypeError: 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : tupla [ 2 ][ 0 ] = 2 # La tupla sar\u00e0 ('hello', 'world', [2, 2, 3]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi. 3.5 - Set \u00b6 Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. insieme = { 1 , \"stringa\" , 2 } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: l = [ 1 , 2 , 2 , 3 ] # La lista sar\u00e0 [1, 2, 2, 3] s = set ( l ) # Il set sar\u00e0 [1, 2, 3] 3.6 - Dizionari \u00b6 Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 3.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: dizionario = {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: dizionario [ 'k' ] = 'v' dizionario [ 1 ] = 'n' # Il dizionario sar\u00e0 {'k': 'v', 1: 'n'} Per accedere al valore associato ad una determinata chiave: dizionario [ 1 ] # Il valore restituito sar\u00e0 'n' 3.6.1 - Chiavi e valori \u00b6 E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: chiavi = dizionario . keys () # Restituisce dict_keys(['k', 1]), che non \u00e8 una lista! list ( chiavi ) # Restituisce ['k', 1], che \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: valori = dizionario . values () # Restituisce dict_values(['v', 'n']), che non \u00e8 una lista! list ( valori ) # Restituisce ['v', 'n'], che \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: coppie = dizionario . items () # Restituisce dict_items([('k', 'v'), (1, 'n')]) list ( coppie ) # Restituisce una lista di tuple 3.6.2 - Creazione di un dizionario (non vuoto) \u00b6 Abbiamo diversi modi per creare un dizionario non vuoto. 3.6.2.1 - Uso dell'operatore {} \u00b6 Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 } 3.6.2.2 - Uso del costruttore dict() \u00b6 Un altro modo \u00e8 usare il metodo costruttore dict() : dizionario = dict ( k1 = 1 , k2 = 2 ) # Il dizionario sar\u00e0 {'k1': 1, 'k2': 2} 3.6.2.3 - Uso della funzione zip \u00b6 Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: chiavi = [ 'k1' , 'k2' ] valori = [ 1 , 2 ] dizionario = dict ( zip ( chiavi , valori )) 3.6.2.4 - Dict comprehension \u00b6 Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} print ( quadrati ) # Risultato: {'1': 1, '2': 4, '3': 9, '4': 16, '5': 25, '6': 36, '7': 49, '8': 64, '9': 81}","title":"03 - Strutture dati"},{"location":"material/01_python/03_data_structures/lecture/#3-strutture-dati-in-python","text":"","title":"3 - Strutture dati in Python"},{"location":"material/01_python/03_data_structures/lecture/#31-liste-pile-e-code","text":"Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi.","title":"3.1 - Liste, pile e code"},{"location":"material/01_python/03_data_structures/lecture/#311-pila","text":"Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. Ad esempio: s = [ 1 , 2 , 3 ] s . append ( 4 ) # s sar\u00e0 pari a [1, 2, 3, 4] e = s . pop () # e sar\u00e0 pari a 4, mentre s sar\u00e0 pari a [1, 2, 3]","title":"3.1.1 - Pila"},{"location":"material/01_python/03_data_structures/lecture/#312-coda","text":"Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec. Per implementare una coda a partire da una lista, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . q = [ 1 , 2 , 3 ] q . insert ( 0 , 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . pop ( 0 ) # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: from collections import deque q = deque ([ 1 , 2 , 3 ]) q . appendleft ( 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . popleft () # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Nota Sottolineamo che q non \u00e8 pi\u00f9 una lista, ma una deque .","title":"3.1.2 - Coda"},{"location":"material/01_python/03_data_structures/lecture/#32-list-comprehension","text":"Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input.","title":"3.2 - List comprehension"},{"location":"material/01_python/03_data_structures/lecture/#321-forma-estesa-con-if-else","text":"La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Perch\u00e9 usare le list comprehension? Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension.","title":"3.2.1 - Forma estesa con if-else"},{"location":"material/01_python/03_data_structures/lecture/#33-le-assignment-expressions","text":"Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 3.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"3.3 - Le assignment expressions"},{"location":"material/01_python/03_data_structures/lecture/#34-tuple","text":"Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: tupla = ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: tupla = ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: tupla [ 2 ] = [ 2 , 2 , 3 ] Apparir\u00e0 un errore simile a questo: Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> TypeError: 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : tupla [ 2 ][ 0 ] = 2 # La tupla sar\u00e0 ('hello', 'world', [2, 2, 3]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi.","title":"3.4 - Tuple"},{"location":"material/01_python/03_data_structures/lecture/#35-set","text":"Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. insieme = { 1 , \"stringa\" , 2 } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: l = [ 1 , 2 , 2 , 3 ] # La lista sar\u00e0 [1, 2, 2, 3] s = set ( l ) # Il set sar\u00e0 [1, 2, 3]","title":"3.5 - Set"},{"location":"material/01_python/03_data_structures/lecture/#36-dizionari","text":"Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 3.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: dizionario = {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: dizionario [ 'k' ] = 'v' dizionario [ 1 ] = 'n' # Il dizionario sar\u00e0 {'k': 'v', 1: 'n'} Per accedere al valore associato ad una determinata chiave: dizionario [ 1 ] # Il valore restituito sar\u00e0 'n'","title":"3.6 - Dizionari"},{"location":"material/01_python/03_data_structures/lecture/#361-chiavi-e-valori","text":"E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: chiavi = dizionario . keys () # Restituisce dict_keys(['k', 1]), che non \u00e8 una lista! list ( chiavi ) # Restituisce ['k', 1], che \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: valori = dizionario . values () # Restituisce dict_values(['v', 'n']), che non \u00e8 una lista! list ( valori ) # Restituisce ['v', 'n'], che \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: coppie = dizionario . items () # Restituisce dict_items([('k', 'v'), (1, 'n')]) list ( coppie ) # Restituisce una lista di tuple","title":"3.6.1 - Chiavi e valori"},{"location":"material/01_python/03_data_structures/lecture/#362-creazione-di-un-dizionario-non-vuoto","text":"Abbiamo diversi modi per creare un dizionario non vuoto.","title":"3.6.2 - Creazione di un dizionario (non vuoto)"},{"location":"material/01_python/03_data_structures/lecture/#3621-uso-delloperatore","text":"Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"3.6.2.1 - Uso dell'operatore {}"},{"location":"material/01_python/03_data_structures/lecture/#3622-uso-del-costruttore-dict","text":"Un altro modo \u00e8 usare il metodo costruttore dict() : dizionario = dict ( k1 = 1 , k2 = 2 ) # Il dizionario sar\u00e0 {'k1': 1, 'k2': 2}","title":"3.6.2.2 - Uso del costruttore dict()"},{"location":"material/01_python/03_data_structures/lecture/#3623-uso-della-funzione-zip","text":"Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: chiavi = [ 'k1' , 'k2' ] valori = [ 1 , 2 ] dizionario = dict ( zip ( chiavi , valori ))","title":"3.6.2.3 - Uso della funzione zip"},{"location":"material/01_python/03_data_structures/lecture/#3624-dict-comprehension","text":"Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} print ( quadrati ) # Risultato: {'1': 1, '2': 4, '3': 9, '4': 16, '5': 25, '6': 36, '7': 49, '8': 64, '9': 81}","title":"3.6.2.4 - Dict comprehension"},{"location":"material/01_python/04_classes/exercises/","text":"E4 - Programmazione orientata agli oggetti in Python \u00b6 E4.1 \u00b6 Scrivere una classe Persona applicando i concetti visti durante la lezione. S4.1 - Soluzione \u00b6 Scriviamo la classe Persona come segue: class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe. E4.2 \u00b6 Creiamo due classi: la prima \u00e8 la classe Quadrato , che modella tutti i quadrati; la seconda \u00e8 la classe Cerchio , che modella tutti i cerchi. Entrambe devono discendere da una classe base chiamata Figura . S4.2 - Soluzione \u00b6 from abc import ABC , abstractmethod from math import pi class Figura ( ABC ): @property def perimetro ( self ): return self . __perimetro @property def area ( self ): return self . __area @abstractmethod def perimetro ( self ): pass @abstractmethod def area ( self ): pass class Quadrato ( Figura ): def __init__ ( self , lato ): self . lato = lato @property def lato ( self ): return self . __lato @lato . setter def lato ( self , value ): self . __lato = value def perimetro ( self ): return self . lato * 4 def area ( self ): return self . lato ** 2 class Cerchio ( Figura ): def __init__ ( self , raggio ): self . raggio = raggio @property def raggio ( self ): return self . __raggio @raggio . setter def raggio ( self , value ): self . __raggio = value def perimetro ( self ): return 2 * pi * self . raggio def area ( self ): return pi * ( self . raggio ** 2 ) # Esempio di uso q = Quadrato ( 5 ) print ( 'Lato: {} - Perimetro: {} - Area: {} ' . format ( q . lato , q . perimetro (), q . area ())) c = Cerchio ( 5 ) print ( 'Raggio: {} - Perimetro: {} - Area: {} ' . format ( c . raggio , c . perimetro (), c . area ()))","title":"E4 - Programmazione orientata agli oggetti in Python"},{"location":"material/01_python/04_classes/exercises/#e4-programmazione-orientata-agli-oggetti-in-python","text":"","title":"E4 - Programmazione orientata agli oggetti in Python"},{"location":"material/01_python/04_classes/exercises/#e41","text":"Scrivere una classe Persona applicando i concetti visti durante la lezione.","title":"E4.1"},{"location":"material/01_python/04_classes/exercises/#s41-soluzione","text":"Scriviamo la classe Persona come segue: class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"S4.1 - Soluzione"},{"location":"material/01_python/04_classes/exercises/#e42","text":"Creiamo due classi: la prima \u00e8 la classe Quadrato , che modella tutti i quadrati; la seconda \u00e8 la classe Cerchio , che modella tutti i cerchi. Entrambe devono discendere da una classe base chiamata Figura .","title":"E4.2"},{"location":"material/01_python/04_classes/exercises/#s42-soluzione","text":"from abc import ABC , abstractmethod from math import pi class Figura ( ABC ): @property def perimetro ( self ): return self . __perimetro @property def area ( self ): return self . __area @abstractmethod def perimetro ( self ): pass @abstractmethod def area ( self ): pass class Quadrato ( Figura ): def __init__ ( self , lato ): self . lato = lato @property def lato ( self ): return self . __lato @lato . setter def lato ( self , value ): self . __lato = value def perimetro ( self ): return self . lato * 4 def area ( self ): return self . lato ** 2 class Cerchio ( Figura ): def __init__ ( self , raggio ): self . raggio = raggio @property def raggio ( self ): return self . __raggio @raggio . setter def raggio ( self , value ): self . __raggio = value def perimetro ( self ): return 2 * pi * self . raggio def area ( self ): return pi * ( self . raggio ** 2 ) # Esempio di uso q = Quadrato ( 5 ) print ( 'Lato: {} - Perimetro: {} - Area: {} ' . format ( q . lato , q . perimetro (), q . area ())) c = Cerchio ( 5 ) print ( 'Raggio: {} - Perimetro: {} - Area: {} ' . format ( c . raggio , c . perimetro (), c . area ()))","title":"S4.2 - Soluzione"},{"location":"material/01_python/04_classes/lecture/","text":"4 - Programmazione orientata agli oggetti in Python \u00b6 Python offre un esteso supporto alla programmazione orientata agli oggetti. Prima di proseguire, per\u00f2, \u00e8 opportuno introdurre brevemente questo concetto. 4.1 - La programmazione orientata agli oggetti \u00b6 Quello della programmazione orientata agli oggetti (OOP) \u00e8 un paradigma di programmazione che permette di creare nuovi tipi definiti dall'utente, da intendersi come complementari ai tipi definiti dal linguaggio di programmazione. In tal senso, la OOP sposta il focus dalle funzioni , centrali nei linguaggi come il C e nel paradigma procedurale, ai dati . In tal senso, si arriva a dire che nella OOP tutto \u00e8 un oggetto . 4.1.1 - Classi \u00b6 Una classe \u00e8 un prototipo per un determinato tipo di dati definito dall'utente. Ad esempio: la classe Studente rappresenta tutte le propriet\u00e0 e le azioni associate ad uno studente; la classe Auto rappresenta tutte le propriet\u00e0 e le azioni associate ad un'auto; la classe Motore definisce i comportamenti dei motori; e via discorrendo. In generale, quindi, pu\u00f2 esistere una classe per ogni tipologia di oggetti presenti nel mondo, sia esso reale o informatico. Importante \u00e8 non confondere la classe con il singolo oggetto , chiamato istanza . Ad esempio: lo studente Angelo Cardellicchio \u00e8 un'istanza della classe Studente ; l'auto Opel Corsa targata AB 123 CD \u00e8 un'istanza della classe Auto ; l'auto Hyundai Tucson CD 321 AB \u00e8 un'istanza della classe Auto ; l'auto Opel Corsa targata AA 123 CC \u00e8 un'altra istanza della classe Auto . 4.1.1.1 - Metodi ed attributi \u00b6 Ogni classe ha dei metodi , che caratterizzano delle azioni che \u00e8 possibile effettuare su ogni istanza della classe, e degli attributi , ovvero delle caratteristiche dell'istanza. In particolare, ogni nuovo tipo, chiamato classe , avr\u00e0 opportuni attributi e metodi , ognuno dei quali accessibile dall'esterno mediante opportuni modificatori . Ad esempio, l'auto Opel Corsa targata AB 123 CD ha una casa costruttrice (Opel), un modello (Corsa), una targa (AB 123 CD), una cilindrata, e via dicendo. 4.2 - Classi in Python \u00b6 Per definire una classe, dovremo usare la parola chiave class : class NomeClasse ( ClasseBase ): # Attributi e metodi di classe... Con la sintassi precedente, abbiamo creato una classe chiamata NomeClasse discendente da una classe base ( ClasseBase ). 4.3 - Il metodo __init__ \u00b6 La maggior parte dei linguaggi di programmazione utilizza il concetto di costruttore per creare un'istanza di una classe. Il Python, tuttavia, non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione dei singoli attributi dell'istanza. Da qui deriva il nome del metodo, ovvero __init__ : class NomeClasse ( ClasseBase ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Unpacking Con la sintassi *args e **kwargs vogliamo rappresentare l'azione di unpacking di (rispettivamente) una lista ed un dizionario, mediante la quale stiamo passando tutti i valori contenuti all'interno della sequenza. Occorre prestare particolare attenzione all'uso della keyword self , che permette di riferirsi alla specifica istanza di una classe (per chi ha familiarit\u00e0 con i linguaggi come il C++, \u00e8 concettualmente simile alla parola chiave this ). Ad esempio: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome self . _cognome = cognome self . __eta = eta Questo snippet ci permette di evidenziare quattro punti: la classe generica object , da cui derivano tutte le classi Python (ma la cui dichiarazione pu\u00f2 comunque essere omessa); il funzionamento della parola chiave self , che permette di associare agli attributi della singola istanza un determinato valore; la possibilit\u00e0 di inserire tra i parametri dei valori opzionali e di default (in questo caso eta , che di default vale 18 ); la presenza di uno o due simboli _ ( underscore ) davanti ad alcuni attributi. Approfondiamo brevemente il punto 4. 4.4 - Modificatori di accesso \u00b6 Python prevede l'uso di modificatori di accesso ai dati; nello specifico, troviamo i classici public , protected e private . Tuttavia, a differenza di altri linguaggi, per distinguere tra i tre modificatori di accesso si utilizzano uno o due underscore come suffisso al nome dell'attributo; in particolare, usare un underscore singolo indica un attributo protected, mentre un underscore doppio indica un attributo private . Nel nostro caso: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome # Membro \"public\" self . _cognome = cognome # Membro \"protected\" self . __eta = eta # Membro \"private\" Attenzione Nonostante il modificatore di accesso, \u00e8 possibile accedere ai membri protetti dall'esterno della classe. Infatti: >>> p = Persona ( 'Jax' , 'Teller' ) >>> print ( p . nome ) >>> print ( p . _cognome ) Jax Teller Questo non vale per gli attributi privati: >>> try: >>> print ( p.__eta ) >>> except AttributeError: >>> print ( 'Et\u00e0 \u00e8 privato!' ) Et\u00e0 \u00e8 privato! Questa sintassi pu\u00f2 ovviamente essere utilizzata per definire dei metodi protetti o privati. Suggerimento La sintassi che abbiamo mostrato nello snippet precedente \u00e8 relativa alla gestione delle eccezioni . 4.5 - Metodi \u00b6 La sintassi per definire il metodo di una classe \u00e8 analoga a quella usata per definire una funzione. def metodo ( self , * args , ** kwargs ): pass Esiste tuttavia una differenza fondamentale: infatti, il primo attributo di un metodo appartenente ad una classe \u00e8 sempre un riferimento all'istanza tramite la parola chiave self . Tale riferimento non va specificato quando il metodo viene chiamato dall'esterno: # ... p = Persona () # p \u00e8 un'istanza di Persona p . metodo ( parametro ) # richiamo il metodo dall'istanza # ... Nel codice precedente, abbiamo usato l'operatore . per accedere a metodo definito all'interno della classe Persona . Approfondiamo adesso alcune particolari tipologie di metodi, ottenibili usando determinati decorator (cfr. appendice B). 4.5.1 - Metodi di classe \u00b6 Il decorator @classmethod ci permette di definire i cosiddetti metodi di classe : @classmethod def builder_stringa ( cls , stringa : str ): nome , cognome , eta = stringa . split ( ' ' ) return Persona ( nome , cognome , eta ) A differenza dei metodi standard, i metodi di classe hanno un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi che si applicano all'intera classe , e non alla singola istanza. Un tipico esempio di utilizzo di un metodo di classe \u00e8 mostrato nello snippet precedente, nel quale stiamo creando un oggetto di classe Persona a partire da una stringa. Curiosit\u00e0 Il metodo precedente \u00e8, di fatto, un'implementazione del design pattern Builder. Per richiamare un metodo di classe occorre riferirsi al nome della classe stessa, e non ad una singola istanza: >>> persona = Person . builder_stringa ( 'Bobby Munson 58' ) >>> print ( \" {} {} \" . format ( persona . nome , persona . _cognome )) Bobby Munson 4.5.2 - Metodi statici \u00b6 Mediante il decoratore @staticmethod possiamo definire un metodo statico . In Python il funzionamento di un metodo di questo tipo \u00e8 riassumibile in un comportamento assimilabile ad una funzione \"semplice\", definita per\u00f2 all'interno della classe, e richiamabile su istanze della stessa. Ad esempio: @staticmethod def nome_valido ( nome ): if len ( nome ) < 2 : return False else : return True Questo metodo \u00e8 quindi liberamente richiamabile mediante l'operatore . da una singola istanza: >>> print ( persona . nome_valido ( 'Li' )) True Un'altra possibilit\u00e0 \u00e8 richiamarlo sulla classe stessa: >>> print ( Persona . nome_valido ( 'X' )) False 4.5.3 - Metodi astratti \u00b6 Possiamo definire dei metodi astratti (cfr. Appendice C) mediante il decorator @abstractmethod . Per farlo, la nostra classe deve discendere dalla classe ABC (acronimo che sta per Abstract Base Class ), contenuta nel package abc : from abc import ABC class ClasseBase ( ABC ): # ... @abstractmethod def metodo_da_sovrascrivere ( self ): pass I metodi contrassegnati con il decorator @abstractmethod dovranno essere implementati nelle classi derivate (in altre parole, dovremo farne l' override ): class ClasseDerivata ( ClasseBase ): # ... def metodo_da_sovrascrivere ( self ): # ... 4.6 - Le propriet\u00e0 \u00b6 In molti linguaggi di programmazione si usano tradizionalmente i metodi accessori ( getter ) e modificatori ( setter ) per accedere agli attributi delle istanze di una classe. Python non vieta di farlo: ad esempio, possiamo scrivere un metodo get_nome(self) per accedere al nome di una persona, ed un metodo set_nome(self, nome) per impostare detta propriet\u00e0. Tuttavia, \u00e8 possibile usare una sintassi pi\u00f9 compatta (e, in definitiva, maggiormente pythonic ) mediante il decorator @property , che rappresenta una funzione a quattro parametri: property ( fget = None , fset = None , fdel = None , doc = None ) In particolare: fget \u00e8 la funzione usata per recuperare il valore dell'attributo; fset \u00e8 la funzione usata per impostare il valore dell'attributo; fdel \u00e8 la funzione per rimuovere l'attributo; doc \u00e8 la funzione per documentare e descrivere l'attributo. Grazie a property , potremo seguire le \"best practice\" della OOP, rendendo privati gli attributi della classe ed accedendovi mediante opportuni metodi. class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"04 - Classi"},{"location":"material/01_python/04_classes/lecture/#4-programmazione-orientata-agli-oggetti-in-python","text":"Python offre un esteso supporto alla programmazione orientata agli oggetti. Prima di proseguire, per\u00f2, \u00e8 opportuno introdurre brevemente questo concetto.","title":"4 - Programmazione orientata agli oggetti in Python"},{"location":"material/01_python/04_classes/lecture/#41-la-programmazione-orientata-agli-oggetti","text":"Quello della programmazione orientata agli oggetti (OOP) \u00e8 un paradigma di programmazione che permette di creare nuovi tipi definiti dall'utente, da intendersi come complementari ai tipi definiti dal linguaggio di programmazione. In tal senso, la OOP sposta il focus dalle funzioni , centrali nei linguaggi come il C e nel paradigma procedurale, ai dati . In tal senso, si arriva a dire che nella OOP tutto \u00e8 un oggetto .","title":"4.1 - La programmazione orientata agli oggetti"},{"location":"material/01_python/04_classes/lecture/#411-classi","text":"Una classe \u00e8 un prototipo per un determinato tipo di dati definito dall'utente. Ad esempio: la classe Studente rappresenta tutte le propriet\u00e0 e le azioni associate ad uno studente; la classe Auto rappresenta tutte le propriet\u00e0 e le azioni associate ad un'auto; la classe Motore definisce i comportamenti dei motori; e via discorrendo. In generale, quindi, pu\u00f2 esistere una classe per ogni tipologia di oggetti presenti nel mondo, sia esso reale o informatico. Importante \u00e8 non confondere la classe con il singolo oggetto , chiamato istanza . Ad esempio: lo studente Angelo Cardellicchio \u00e8 un'istanza della classe Studente ; l'auto Opel Corsa targata AB 123 CD \u00e8 un'istanza della classe Auto ; l'auto Hyundai Tucson CD 321 AB \u00e8 un'istanza della classe Auto ; l'auto Opel Corsa targata AA 123 CC \u00e8 un'altra istanza della classe Auto .","title":"4.1.1 - Classi"},{"location":"material/01_python/04_classes/lecture/#4111-metodi-ed-attributi","text":"Ogni classe ha dei metodi , che caratterizzano delle azioni che \u00e8 possibile effettuare su ogni istanza della classe, e degli attributi , ovvero delle caratteristiche dell'istanza. In particolare, ogni nuovo tipo, chiamato classe , avr\u00e0 opportuni attributi e metodi , ognuno dei quali accessibile dall'esterno mediante opportuni modificatori . Ad esempio, l'auto Opel Corsa targata AB 123 CD ha una casa costruttrice (Opel), un modello (Corsa), una targa (AB 123 CD), una cilindrata, e via dicendo.","title":"4.1.1.1 - Metodi ed attributi"},{"location":"material/01_python/04_classes/lecture/#42-classi-in-python","text":"Per definire una classe, dovremo usare la parola chiave class : class NomeClasse ( ClasseBase ): # Attributi e metodi di classe... Con la sintassi precedente, abbiamo creato una classe chiamata NomeClasse discendente da una classe base ( ClasseBase ).","title":"4.2 - Classi in Python"},{"location":"material/01_python/04_classes/lecture/#43-il-metodo-__init__","text":"La maggior parte dei linguaggi di programmazione utilizza il concetto di costruttore per creare un'istanza di una classe. Il Python, tuttavia, non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione dei singoli attributi dell'istanza. Da qui deriva il nome del metodo, ovvero __init__ : class NomeClasse ( ClasseBase ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Unpacking Con la sintassi *args e **kwargs vogliamo rappresentare l'azione di unpacking di (rispettivamente) una lista ed un dizionario, mediante la quale stiamo passando tutti i valori contenuti all'interno della sequenza. Occorre prestare particolare attenzione all'uso della keyword self , che permette di riferirsi alla specifica istanza di una classe (per chi ha familiarit\u00e0 con i linguaggi come il C++, \u00e8 concettualmente simile alla parola chiave this ). Ad esempio: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome self . _cognome = cognome self . __eta = eta Questo snippet ci permette di evidenziare quattro punti: la classe generica object , da cui derivano tutte le classi Python (ma la cui dichiarazione pu\u00f2 comunque essere omessa); il funzionamento della parola chiave self , che permette di associare agli attributi della singola istanza un determinato valore; la possibilit\u00e0 di inserire tra i parametri dei valori opzionali e di default (in questo caso eta , che di default vale 18 ); la presenza di uno o due simboli _ ( underscore ) davanti ad alcuni attributi. Approfondiamo brevemente il punto 4.","title":"4.3 - Il metodo __init__"},{"location":"material/01_python/04_classes/lecture/#44-modificatori-di-accesso","text":"Python prevede l'uso di modificatori di accesso ai dati; nello specifico, troviamo i classici public , protected e private . Tuttavia, a differenza di altri linguaggi, per distinguere tra i tre modificatori di accesso si utilizzano uno o due underscore come suffisso al nome dell'attributo; in particolare, usare un underscore singolo indica un attributo protected, mentre un underscore doppio indica un attributo private . Nel nostro caso: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome # Membro \"public\" self . _cognome = cognome # Membro \"protected\" self . __eta = eta # Membro \"private\" Attenzione Nonostante il modificatore di accesso, \u00e8 possibile accedere ai membri protetti dall'esterno della classe. Infatti: >>> p = Persona ( 'Jax' , 'Teller' ) >>> print ( p . nome ) >>> print ( p . _cognome ) Jax Teller Questo non vale per gli attributi privati: >>> try: >>> print ( p.__eta ) >>> except AttributeError: >>> print ( 'Et\u00e0 \u00e8 privato!' ) Et\u00e0 \u00e8 privato! Questa sintassi pu\u00f2 ovviamente essere utilizzata per definire dei metodi protetti o privati. Suggerimento La sintassi che abbiamo mostrato nello snippet precedente \u00e8 relativa alla gestione delle eccezioni .","title":"4.4 - Modificatori di accesso"},{"location":"material/01_python/04_classes/lecture/#45-metodi","text":"La sintassi per definire il metodo di una classe \u00e8 analoga a quella usata per definire una funzione. def metodo ( self , * args , ** kwargs ): pass Esiste tuttavia una differenza fondamentale: infatti, il primo attributo di un metodo appartenente ad una classe \u00e8 sempre un riferimento all'istanza tramite la parola chiave self . Tale riferimento non va specificato quando il metodo viene chiamato dall'esterno: # ... p = Persona () # p \u00e8 un'istanza di Persona p . metodo ( parametro ) # richiamo il metodo dall'istanza # ... Nel codice precedente, abbiamo usato l'operatore . per accedere a metodo definito all'interno della classe Persona . Approfondiamo adesso alcune particolari tipologie di metodi, ottenibili usando determinati decorator (cfr. appendice B).","title":"4.5 - Metodi"},{"location":"material/01_python/04_classes/lecture/#451-metodi-di-classe","text":"Il decorator @classmethod ci permette di definire i cosiddetti metodi di classe : @classmethod def builder_stringa ( cls , stringa : str ): nome , cognome , eta = stringa . split ( ' ' ) return Persona ( nome , cognome , eta ) A differenza dei metodi standard, i metodi di classe hanno un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi che si applicano all'intera classe , e non alla singola istanza. Un tipico esempio di utilizzo di un metodo di classe \u00e8 mostrato nello snippet precedente, nel quale stiamo creando un oggetto di classe Persona a partire da una stringa. Curiosit\u00e0 Il metodo precedente \u00e8, di fatto, un'implementazione del design pattern Builder. Per richiamare un metodo di classe occorre riferirsi al nome della classe stessa, e non ad una singola istanza: >>> persona = Person . builder_stringa ( 'Bobby Munson 58' ) >>> print ( \" {} {} \" . format ( persona . nome , persona . _cognome )) Bobby Munson","title":"4.5.1 - Metodi di classe"},{"location":"material/01_python/04_classes/lecture/#452-metodi-statici","text":"Mediante il decoratore @staticmethod possiamo definire un metodo statico . In Python il funzionamento di un metodo di questo tipo \u00e8 riassumibile in un comportamento assimilabile ad una funzione \"semplice\", definita per\u00f2 all'interno della classe, e richiamabile su istanze della stessa. Ad esempio: @staticmethod def nome_valido ( nome ): if len ( nome ) < 2 : return False else : return True Questo metodo \u00e8 quindi liberamente richiamabile mediante l'operatore . da una singola istanza: >>> print ( persona . nome_valido ( 'Li' )) True Un'altra possibilit\u00e0 \u00e8 richiamarlo sulla classe stessa: >>> print ( Persona . nome_valido ( 'X' )) False","title":"4.5.2 - Metodi statici"},{"location":"material/01_python/04_classes/lecture/#453-metodi-astratti","text":"Possiamo definire dei metodi astratti (cfr. Appendice C) mediante il decorator @abstractmethod . Per farlo, la nostra classe deve discendere dalla classe ABC (acronimo che sta per Abstract Base Class ), contenuta nel package abc : from abc import ABC class ClasseBase ( ABC ): # ... @abstractmethod def metodo_da_sovrascrivere ( self ): pass I metodi contrassegnati con il decorator @abstractmethod dovranno essere implementati nelle classi derivate (in altre parole, dovremo farne l' override ): class ClasseDerivata ( ClasseBase ): # ... def metodo_da_sovrascrivere ( self ): # ...","title":"4.5.3 - Metodi astratti"},{"location":"material/01_python/04_classes/lecture/#46-le-proprieta","text":"In molti linguaggi di programmazione si usano tradizionalmente i metodi accessori ( getter ) e modificatori ( setter ) per accedere agli attributi delle istanze di una classe. Python non vieta di farlo: ad esempio, possiamo scrivere un metodo get_nome(self) per accedere al nome di una persona, ed un metodo set_nome(self, nome) per impostare detta propriet\u00e0. Tuttavia, \u00e8 possibile usare una sintassi pi\u00f9 compatta (e, in definitiva, maggiormente pythonic ) mediante il decorator @property , che rappresenta una funzione a quattro parametri: property ( fget = None , fset = None , fdel = None , doc = None ) In particolare: fget \u00e8 la funzione usata per recuperare il valore dell'attributo; fset \u00e8 la funzione usata per impostare il valore dell'attributo; fdel \u00e8 la funzione per rimuovere l'attributo; doc \u00e8 la funzione per documentare e descrivere l'attributo. Grazie a property , potremo seguire le \"best practice\" della OOP, rendendo privati gli attributi della classe ed accedendovi mediante opportuni metodi. class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"4.6 - Le propriet\u00e0"},{"location":"material/01_python/05_modules/lecture/","text":"5 - Script e moduli \u00b6 Quando si usa Python la tentazione \u00e8 quella di interagire direttamente con l'interprete, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi. Ad esempio: non avremo a disposizione il syntax highlighting offerto da una normale IDE; non potremo recuperare il codice una volta chiuso l'interprete; non potremo n\u00e9 modificare, n\u00e9 verificare facilmente il funzionamento del codice. Appare quindi evidente come usare l'interprete non sia un modo ottimale di sviluppare codice Python. Di conseguenza, sar\u00e0 necessario definire, mediante la nostra IDE di riferimento, dei veri e propri script che saranno salvati sotto forma di file con estensione .py , ognuno dei quali contenenti una serie di istruzioni necessarie all'esecuzione del nostro programma. 5.1 - Il primo script \u00b6 Proviamo quindi a creare il nostro primo script Python. Per farlo, apriamo la nostra IDE di riferimento, come Visual Studio Code, e creiamo un file chiamato main.py , all'interno del quale inseriremo il seguente codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: cd cartella_dove_risiede_lo_script python main.py Le due istruzioni precedenti: servono a cambiare cartella ( change directory , cd ), spostandoci nella cartella dove risiede lo script; dicono all'interprete Python di lanciare lo script main.py . A schermo, se tutto \u00e8 andato per il verso giusto, apparir\u00e0 la scritta Hello, world : Hello, world 5.2 - I moduli \u00b6 Quando le dimensioni della nostra code base (ovvero la quantit\u00e0 di codice che scriviamo nel nostro programma) iniziano ad essere particolarmente \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , separando in file differenti parti di codice delegate a funzioni eterogenee. Facciamo un esempio. Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che distingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ . 5.2.1 - I moduli geometria e trigonometria \u00b6 Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) . 5.3 - Usare gli import \u00b6 Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve. 5.3.1 - Alias \u00b6 La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi )) 5.4 - La funzione dir() \u00b6 La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from . 5.5 - Moduli della libreria standard \u00b6 Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference . 5.6 - Package \u00b6 Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"05 - Moduli"},{"location":"material/01_python/05_modules/lecture/#5-script-e-moduli","text":"Quando si usa Python la tentazione \u00e8 quella di interagire direttamente con l'interprete, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi. Ad esempio: non avremo a disposizione il syntax highlighting offerto da una normale IDE; non potremo recuperare il codice una volta chiuso l'interprete; non potremo n\u00e9 modificare, n\u00e9 verificare facilmente il funzionamento del codice. Appare quindi evidente come usare l'interprete non sia un modo ottimale di sviluppare codice Python. Di conseguenza, sar\u00e0 necessario definire, mediante la nostra IDE di riferimento, dei veri e propri script che saranno salvati sotto forma di file con estensione .py , ognuno dei quali contenenti una serie di istruzioni necessarie all'esecuzione del nostro programma.","title":"5 - Script e moduli"},{"location":"material/01_python/05_modules/lecture/#51-il-primo-script","text":"Proviamo quindi a creare il nostro primo script Python. Per farlo, apriamo la nostra IDE di riferimento, come Visual Studio Code, e creiamo un file chiamato main.py , all'interno del quale inseriremo il seguente codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: cd cartella_dove_risiede_lo_script python main.py Le due istruzioni precedenti: servono a cambiare cartella ( change directory , cd ), spostandoci nella cartella dove risiede lo script; dicono all'interprete Python di lanciare lo script main.py . A schermo, se tutto \u00e8 andato per il verso giusto, apparir\u00e0 la scritta Hello, world : Hello, world","title":"5.1 - Il primo script"},{"location":"material/01_python/05_modules/lecture/#52-i-moduli","text":"Quando le dimensioni della nostra code base (ovvero la quantit\u00e0 di codice che scriviamo nel nostro programma) iniziano ad essere particolarmente \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , separando in file differenti parti di codice delegate a funzioni eterogenee. Facciamo un esempio. Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che distingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ .","title":"5.2 - I moduli"},{"location":"material/01_python/05_modules/lecture/#521-i-moduli-geometria-e-trigonometria","text":"Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) .","title":"5.2.1 - I moduli geometria e trigonometria"},{"location":"material/01_python/05_modules/lecture/#53-usare-gli-import","text":"Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve.","title":"5.3 - Usare gli import"},{"location":"material/01_python/05_modules/lecture/#531-alias","text":"La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi ))","title":"5.3.1 - Alias"},{"location":"material/01_python/05_modules/lecture/#54-la-funzione-dir","text":"La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from .","title":"5.4 - La funzione dir()"},{"location":"material/01_python/05_modules/lecture/#55-moduli-della-libreria-standard","text":"Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference .","title":"5.5 - Moduli della libreria standard"},{"location":"material/01_python/05_modules/lecture/#56-package","text":"Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"5.6 - Package"},{"location":"material/02_libs/06_jupyter/lecture/","text":"6. iPython e Jupyter Lab \u00b6 Fino a questo momento ci siamo limitati a lanciare script Python direttamente da riga di comando. Tuttavia, \u00e8 evidente come questo approccio sia limitato, specialmente in applicazioni in ambito data science. Per ovviare a queste problematiche, all'interno del framework SciPy viene proposto Jupyter Lab , che introduce uno tra gli strumenti pi\u00f9 utilizzati dai data analyst al giorno d'oggi, ovvero i notebook . 6.1 - Anatomia di un notebook \u00b6 Un notebook \u00e8, in poche parole, un ambiente interattivo che permette di scrivere e testare il nostro codice. In particolare, ptoremo scrivere una o pi\u00f9 istruzioni, ed eseguirle in maniera separata dalle altre mediante il meccanismo delle celle , che altro non sono se non dei singoli \"blocchi\" di codice. Suggerimento I notebook Jupyter ci permettono di inserire anche commenti, descrizioni ed equazioni utilizzando due linguaggi di markup molto noti, ovvero Markdown e Latex . Vediamo adesso come creare ed utilizzare il nostro primo notebook. 6.2 - Installazione e lancio di Jupyter Lab \u00b6 Per prima cosa, installiamo Jupyter scegliendo una tra le opzioni mostrate in appendice . pip install jupyterlab A differenza delle altre librerie, Jupyter non andr\u00e0 (necessariamente) importato; infatti, \u00e8 possibile lanciare un ambiente interattivo utilizzando la seguente istruzione da riga di comando: jupyter lab Importare iPython In teoria \u00e8 possibile importare iPython ed utilizzare i metodi e le classi messe a disposizione come una qualsiasi libreria. Nei fatti, per\u00f2, molto spesso ci si limita ad utilizzare l'ambiente interattivo offerto dai notebook. 6.3 - Il primo notebook \u00b6 A questo punto ci troveremo davanti ad una schermata simile a quella mostrata nella figura successiva. Creiamo il nostro primo notebook premendo il pulsante Python 3 nel menu Notebook . Una volta terminata la procedura, potremo iniziare ad interagire con l'ambiente. Prima di procedere, per\u00f2, definiamo il nome del nostro notebook dal menu a sinistra. Proviamo a fare qualcosa di semplice: creiamo una funzione che sommi due variabili di tipo numerico, restituendo il risultato, e chiamiamola su due diversi valori. Per prima cosa, scriviamo il codice della funzione all'interno della prima cella: def somma ( a , b ): somma = a + b return somma Per eseguire il codice all'interno della cella, premiamo il tasto Play , oppure la combinazione di tasti Shift+Invio . Una volta eseguita la prima cella, Jupyter ne creer\u00e0 in automatico un'altra; al suo interno, potremo scrivere le istruzioni necessarie a chiamare la funzione somma su due diversi valori. somma ( 5 , 7 ) Eseguiamo l'istruzione; noteremo che al di sotto della cella apparir\u00e0 il valore assunto dalla funzione. 6.4 - Altre operazioni utili \u00b6 Jupyter ci permette di effettuare una serie di operazioni utili, tra cui: cancellare un'intera cella; inserire una cella al di sopra o al di sotto di quella attualmente selezionata; stoppare il kernel; riavviare il kernel. Soffermiamoci per un attimo sulle ultime due operazioni. Pu\u00f2 capitare, infatti, che ci sia la necessit\u00e0 di interrompere il flusso attuale dell'esecuzione delle istruzioni, oppure ancora che sia necessario riavviare il notebook. Dato che Jupyter si basa sul concetto di kernel , il quale \u00e8 il responsabile per l'esecuzione del notebook, diremo in gergo che possiamo interrompere , o stoppare , il kernel, oppure ancora che possiamo riavviarlo . L'interruzione del kernel si limita a fermare l'esecuzione della cella attuale: ci\u00f2 non comporta alcuna perdita di dati, e potremo riprendere ad eseguire il codice nel notebook in ogni momento, sia dall'inizio di quella cella, sia dall'interno di un'altra. Il riavvio del kernel, invece, \"blocca\" completamente l'esecuzione, andando a cancellare anche le variabili presenti in memoria: si tratta, quindi, di un vero e proprio \"reset\", da utilizzare quando, ad esempio, abbiamo la necessit\u00e0 di riorganizzare il codice, oppure quando abbiamo effettuato un numero eccessivo di modifiche per il quale i risultati iniziano a non essere coerenti con le nostre attese.","title":"06 - Jupyter"},{"location":"material/02_libs/06_jupyter/lecture/#6-ipython-e-jupyter-lab","text":"Fino a questo momento ci siamo limitati a lanciare script Python direttamente da riga di comando. Tuttavia, \u00e8 evidente come questo approccio sia limitato, specialmente in applicazioni in ambito data science. Per ovviare a queste problematiche, all'interno del framework SciPy viene proposto Jupyter Lab , che introduce uno tra gli strumenti pi\u00f9 utilizzati dai data analyst al giorno d'oggi, ovvero i notebook .","title":"6. iPython e Jupyter Lab"},{"location":"material/02_libs/06_jupyter/lecture/#61-anatomia-di-un-notebook","text":"Un notebook \u00e8, in poche parole, un ambiente interattivo che permette di scrivere e testare il nostro codice. In particolare, ptoremo scrivere una o pi\u00f9 istruzioni, ed eseguirle in maniera separata dalle altre mediante il meccanismo delle celle , che altro non sono se non dei singoli \"blocchi\" di codice. Suggerimento I notebook Jupyter ci permettono di inserire anche commenti, descrizioni ed equazioni utilizzando due linguaggi di markup molto noti, ovvero Markdown e Latex . Vediamo adesso come creare ed utilizzare il nostro primo notebook.","title":"6.1 - Anatomia di un notebook"},{"location":"material/02_libs/06_jupyter/lecture/#62-installazione-e-lancio-di-jupyter-lab","text":"Per prima cosa, installiamo Jupyter scegliendo una tra le opzioni mostrate in appendice . pip install jupyterlab A differenza delle altre librerie, Jupyter non andr\u00e0 (necessariamente) importato; infatti, \u00e8 possibile lanciare un ambiente interattivo utilizzando la seguente istruzione da riga di comando: jupyter lab Importare iPython In teoria \u00e8 possibile importare iPython ed utilizzare i metodi e le classi messe a disposizione come una qualsiasi libreria. Nei fatti, per\u00f2, molto spesso ci si limita ad utilizzare l'ambiente interattivo offerto dai notebook.","title":"6.2 - Installazione e lancio di Jupyter Lab"},{"location":"material/02_libs/06_jupyter/lecture/#63-il-primo-notebook","text":"A questo punto ci troveremo davanti ad una schermata simile a quella mostrata nella figura successiva. Creiamo il nostro primo notebook premendo il pulsante Python 3 nel menu Notebook . Una volta terminata la procedura, potremo iniziare ad interagire con l'ambiente. Prima di procedere, per\u00f2, definiamo il nome del nostro notebook dal menu a sinistra. Proviamo a fare qualcosa di semplice: creiamo una funzione che sommi due variabili di tipo numerico, restituendo il risultato, e chiamiamola su due diversi valori. Per prima cosa, scriviamo il codice della funzione all'interno della prima cella: def somma ( a , b ): somma = a + b return somma Per eseguire il codice all'interno della cella, premiamo il tasto Play , oppure la combinazione di tasti Shift+Invio . Una volta eseguita la prima cella, Jupyter ne creer\u00e0 in automatico un'altra; al suo interno, potremo scrivere le istruzioni necessarie a chiamare la funzione somma su due diversi valori. somma ( 5 , 7 ) Eseguiamo l'istruzione; noteremo che al di sotto della cella apparir\u00e0 il valore assunto dalla funzione.","title":"6.3 - Il primo notebook"},{"location":"material/02_libs/06_jupyter/lecture/#64-altre-operazioni-utili","text":"Jupyter ci permette di effettuare una serie di operazioni utili, tra cui: cancellare un'intera cella; inserire una cella al di sopra o al di sotto di quella attualmente selezionata; stoppare il kernel; riavviare il kernel. Soffermiamoci per un attimo sulle ultime due operazioni. Pu\u00f2 capitare, infatti, che ci sia la necessit\u00e0 di interrompere il flusso attuale dell'esecuzione delle istruzioni, oppure ancora che sia necessario riavviare il notebook. Dato che Jupyter si basa sul concetto di kernel , il quale \u00e8 il responsabile per l'esecuzione del notebook, diremo in gergo che possiamo interrompere , o stoppare , il kernel, oppure ancora che possiamo riavviarlo . L'interruzione del kernel si limita a fermare l'esecuzione della cella attuale: ci\u00f2 non comporta alcuna perdita di dati, e potremo riprendere ad eseguire il codice nel notebook in ogni momento, sia dall'inizio di quella cella, sia dall'interno di un'altra. Il riavvio del kernel, invece, \"blocca\" completamente l'esecuzione, andando a cancellare anche le variabili presenti in memoria: si tratta, quindi, di un vero e proprio \"reset\", da utilizzare quando, ad esempio, abbiamo la necessit\u00e0 di riorganizzare il codice, oppure quando abbiamo effettuato un numero eccessivo di modifiche per il quale i risultati iniziano a non essere coerenti con le nostre attese.","title":"6.4 - Altre operazioni utili"},{"location":"material/02_libs/07_numpy/01_intro/lecture/","text":"7. Introduzione a NumPy \u00b6 La libreria NumPy , nome derivante dalla crasi tra *Num*erical *Py*thon, \u00e8 una tra le pi\u00f9 utilizzate nelle applicazioni di calcolo scientifico in Python. Nella pratica, possiamo pensare a NumPy come ad uno standard de facto : infatti, le classi ed i metodi messi a disposizione dalla libreria sono estensivamente utilizzate nella quasi totalit\u00e0 degli altri tool Python per le scienze matematiche, chimiche e fisiche, oltre che per l'ingegneria. Partiamo nella nostra disamina dalla procedura di installazione della libreria. Nota In realt\u00e0, partiremo sempre dalla procedura di installazione, qualunque sia la libreria che analizzeremo. 7.1 Installare NumPy \u00b6 Ricordiamo che le diverse opzioni utilizzabili per installare una libreria sono descritte nel dettaglio nell' appendice B . Nel nostro caso, installeremo NumPy mediante 7.1.1 \u00b6 La prima, e forse la pi\u00f9 utilizzata universalmente, \u00e8 quella di utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Possia Per installare NumPy \u00e8 possibile optare per due opzioni. La prima \u00e8 usare una distribuzione scientifica \"predefinita\" di Python (la pi\u00f9 conosciuta \u00e8 Anaconda ); la seconda, che \u00e8 anche quella che seguiremo, \u00e8 creare un apposito ambiente virtuale (cfr. Appendice B) con il gestore delle dipendenze pipenv . Creiamo quindi una nuova cartella all'interno della quale andremo ad ospitare tutti i nostri script, e spostiamoci all'interno della stessa: $ mkdir python-data-science $ cd python-data-science A questo punto, usiamo pipenv per creare un nuovo ambiente virtuale ed installare NumPy: ===\"Pip\" pip install numpy ===\"Pipenv\" pipenv install numpy Una volta terminata la procedura, saranno presenti due file all'interno della cartella python-data-science : Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente questi due file. Per farlo, esistono comandi appositi, che saranno introdotti man mano che li useremo. Importare NumPy \u00b6 Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np Gli ndarray \u00b6 La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy mette a disposizione gli ndarray , che rappresentano degli array ad \\(n\\) dimensioni contenenti dati di tipo omogeneo . Il significato di ndarray ndarray \u00e8 un'abbreviazione che sta per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 in qualche modo simile a quella di una classica lista Python: >>> a = np . array ([ 1 , 2 , 3 ]) In realt\u00e0, volendo essere precisi, possiamo affermare come esista un costruttore che crea un ndarray a partire da una lista, come mostrato nel codice precedente. Questa sintassi, per\u00f2, non deve trarre in inganno. Sono diverse le differenze che intercorrono tra un ndarray ed una classica lista; le principali possono essere riassunte nella seguente tabella. Caratteristica ndarray Lista Dimensione Fissata al momento della creazione Mutabile (ad esempio, con append() ) Elementi Omogenei (stesso tipo) Eterogenei (qualsiasi tipo) Ambito Operazioni algebriche General-purpose Commentiamo brevemente le differenze viste nella tabella precedente: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array comporter\u00e0 quindi la creazione di un nuovo array, con la cancellazione di quello originario. Nella lista, essendo mutabile, questo non avviene; gli elementi di un ndarray devono essere dello stesso tipo, mentre le liste accettano qualsiasi tipo di elemento al loro interno; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni, mentre le liste sono progettate per supportare di ogni tipo. Efficienza di NumPy nelle operazioni algebriche \u00b6 Il punto 3 dell'elenco precedente assume particolare rilevanza ai nostri fini. Per comprenderne il motivo, facciamo un semplice esempio, considerando una moltiplicazione elemento per elemento tra due vettori riga della stessa dimensione. Approccio con liste \u00b6 Usando due liste, potremmo usare un ciclo for o una list comprehension: # ciclo for c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) # list comprehension c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] Il risultato dell'operazione sar\u00e0 in entrambi i casi corretto . Tuttavia, i cicli sono computazionalmente costosi : ci\u00f2 significa che, specialmente all'aumentare del numero di elementi contenuti nei vettori, sar\u00e0 necessario pagare un costo crescente. La soluzione sarebbe quindi quella di ricorrere ad un linguaggio pi\u00f9 efficiente, come il C che, essendo compilato, riduce alcune delle inefficienze tipiche dei linguaggi interpretati. Il codice precedentemente diverrebbe quindi: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Apparentemente s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Il numero di cicli annidati aumenter\u00e0 in maniera direttamente proporzionale alla dimensionalit\u00e0 degli array: ci\u00f2 significa, ad esempio, che per un array a dieci dimensioni avremo altrettanti cicli annidati. Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, per moltiplicare due array in NumPy basta la seguente istruzione: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, anche rispetto alle liste in Python , ed \u00e8 molto simile a quella che si trova sulle formule \"reali\" usate sui libri di testo. Infine, questa istruzione sfrutta codice precompilato : in questo modo, si potranno ottenere delle prestazioni (quasi) equivalenti a quelle del codice scritto direttamente in C. Vettorizzazione e broadcasting Quello che abbiamo appena visto \u00e8 formalmente riassumibile nei concetti di vettorizzazione (ovvero la possibilit\u00e0 di scrivere il codice senza usare esplicitamente dei cicli) e broadcasting (riguardante la possibilit\u00e0 di usare una sintassi comune ed indipendente dalla dimensionalit\u00e0 degli array coinvolti nelle operazioni).","title":"07.1 - Introduzione a Numpy"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#7-introduzione-a-numpy","text":"La libreria NumPy , nome derivante dalla crasi tra *Num*erical *Py*thon, \u00e8 una tra le pi\u00f9 utilizzate nelle applicazioni di calcolo scientifico in Python. Nella pratica, possiamo pensare a NumPy come ad uno standard de facto : infatti, le classi ed i metodi messi a disposizione dalla libreria sono estensivamente utilizzate nella quasi totalit\u00e0 degli altri tool Python per le scienze matematiche, chimiche e fisiche, oltre che per l'ingegneria. Partiamo nella nostra disamina dalla procedura di installazione della libreria. Nota In realt\u00e0, partiremo sempre dalla procedura di installazione, qualunque sia la libreria che analizzeremo.","title":"7. Introduzione a NumPy"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#71-installare-numpy","text":"Ricordiamo che le diverse opzioni utilizzabili per installare una libreria sono descritte nel dettaglio nell' appendice B . Nel nostro caso, installeremo NumPy mediante","title":"7.1 Installare NumPy"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#711","text":"La prima, e forse la pi\u00f9 utilizzata universalmente, \u00e8 quella di utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Possia Per installare NumPy \u00e8 possibile optare per due opzioni. La prima \u00e8 usare una distribuzione scientifica \"predefinita\" di Python (la pi\u00f9 conosciuta \u00e8 Anaconda ); la seconda, che \u00e8 anche quella che seguiremo, \u00e8 creare un apposito ambiente virtuale (cfr. Appendice B) con il gestore delle dipendenze pipenv . Creiamo quindi una nuova cartella all'interno della quale andremo ad ospitare tutti i nostri script, e spostiamoci all'interno della stessa: $ mkdir python-data-science $ cd python-data-science A questo punto, usiamo pipenv per creare un nuovo ambiente virtuale ed installare NumPy: ===\"Pip\" pip install numpy ===\"Pipenv\" pipenv install numpy Una volta terminata la procedura, saranno presenti due file all'interno della cartella python-data-science : Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente questi due file. Per farlo, esistono comandi appositi, che saranno introdotti man mano che li useremo.","title":"7.1.1"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#importare-numpy","text":"Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np","title":"Importare NumPy"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#gli-ndarray","text":"La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy mette a disposizione gli ndarray , che rappresentano degli array ad \\(n\\) dimensioni contenenti dati di tipo omogeneo . Il significato di ndarray ndarray \u00e8 un'abbreviazione che sta per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 in qualche modo simile a quella di una classica lista Python: >>> a = np . array ([ 1 , 2 , 3 ]) In realt\u00e0, volendo essere precisi, possiamo affermare come esista un costruttore che crea un ndarray a partire da una lista, come mostrato nel codice precedente. Questa sintassi, per\u00f2, non deve trarre in inganno. Sono diverse le differenze che intercorrono tra un ndarray ed una classica lista; le principali possono essere riassunte nella seguente tabella. Caratteristica ndarray Lista Dimensione Fissata al momento della creazione Mutabile (ad esempio, con append() ) Elementi Omogenei (stesso tipo) Eterogenei (qualsiasi tipo) Ambito Operazioni algebriche General-purpose Commentiamo brevemente le differenze viste nella tabella precedente: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array comporter\u00e0 quindi la creazione di un nuovo array, con la cancellazione di quello originario. Nella lista, essendo mutabile, questo non avviene; gli elementi di un ndarray devono essere dello stesso tipo, mentre le liste accettano qualsiasi tipo di elemento al loro interno; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni, mentre le liste sono progettate per supportare di ogni tipo.","title":"Gli ndarray"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#efficienza-di-numpy-nelle-operazioni-algebriche","text":"Il punto 3 dell'elenco precedente assume particolare rilevanza ai nostri fini. Per comprenderne il motivo, facciamo un semplice esempio, considerando una moltiplicazione elemento per elemento tra due vettori riga della stessa dimensione.","title":"Efficienza di NumPy nelle operazioni algebriche"},{"location":"material/02_libs/07_numpy/01_intro/lecture/#approccio-con-liste","text":"Usando due liste, potremmo usare un ciclo for o una list comprehension: # ciclo for c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) # list comprehension c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] Il risultato dell'operazione sar\u00e0 in entrambi i casi corretto . Tuttavia, i cicli sono computazionalmente costosi : ci\u00f2 significa che, specialmente all'aumentare del numero di elementi contenuti nei vettori, sar\u00e0 necessario pagare un costo crescente. La soluzione sarebbe quindi quella di ricorrere ad un linguaggio pi\u00f9 efficiente, come il C che, essendo compilato, riduce alcune delle inefficienze tipiche dei linguaggi interpretati. Il codice precedentemente diverrebbe quindi: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Apparentemente s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Il numero di cicli annidati aumenter\u00e0 in maniera direttamente proporzionale alla dimensionalit\u00e0 degli array: ci\u00f2 significa, ad esempio, che per un array a dieci dimensioni avremo altrettanti cicli annidati. Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, per moltiplicare due array in NumPy basta la seguente istruzione: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, anche rispetto alle liste in Python , ed \u00e8 molto simile a quella che si trova sulle formule \"reali\" usate sui libri di testo. Infine, questa istruzione sfrutta codice precompilato : in questo modo, si potranno ottenere delle prestazioni (quasi) equivalenti a quelle del codice scritto direttamente in C. Vettorizzazione e broadcasting Quello che abbiamo appena visto \u00e8 formalmente riassumibile nei concetti di vettorizzazione (ovvero la possibilit\u00e0 di scrivere il codice senza usare esplicitamente dei cicli) e broadcasting (riguardante la possibilit\u00e0 di usare una sintassi comune ed indipendente dalla dimensionalit\u00e0 degli array coinvolti nelle operazioni).","title":"Approccio con liste"},{"location":"material/02_libs/07_numpy/02_array/exercises/","text":"Risoluzione degli esercizi \u00b6 Scriviamo una funzione che restituisca il prodotto riga per colonna di due vettori v1 e v2 . Usiamo una list comprehension, e verifichiamo che la lunghezza dei due vettori sia coerente. Il metodo dovr\u00e0 funzionare indipendentemente dall\u2019ordine in cui sono passati i parametri. def riga_per_colonna ( v1 , v2 ): if v1 . shape [ 0 ] == 1 : if v2 . shape [ 1 ] == 1 and v1 . shape [ 1 ] == v2 . shape [ 0 ]: return sum ([ v1 [ 0 ][ i ] * v2 [ i ] for i in range ( v2 . shape [ 0 ])]) elif v2 . shape [ 0 ] == 1 : if v1 . shape [ 1 ] == 1 and v2 . shape [ 1 ] == v1 . shape [ 0 ]: return sum ([ v1 [ i ] * v2 [ 0 ][ i ] for i in range ( v1 . shape [ 0 ])]) raise ValueError ( 'Le dimensioni dei vettori non sono coerenti.' ) v1 = np . array ([[ 1 , 2 , 3 , 4 ]]) v2 = np . array ([[ 1 ],[ 2 ],[ 3 ],[ 4 ]]) riga_per_colonna ( v1 , v2 ) riga_per_colonna ( v2 , v1 ) riga_per_colonna ( np . array ([[ 1 ]]), v2 ) Scriviamo una funzione crea_array(dim_1, dim_2, val_min, val_max) che crei array di dimensioni arbitrarie dim_1 x dim_2 fatti di numeri interi casuali compresi tra val_min e val_max . Di default, la funzione dovr\u00e0 creare dei vettori riga. import numpy as np from random import randint def crea_array ( dim_1 , dim_2 = 1 , val_min = 0 , val_max = 100 ): rows = [[ randint ( val_min , val_max ) for i in range ( dim_2 )] for j in range ( dim_1 )] return np . array ( rows ) a_1 = crea_array ( 4 , 1 ) a_2 = crea_array ( 2 , 2 )","title":"E7.2 - Gli Array"},{"location":"material/02_libs/07_numpy/02_array/exercises/#risoluzione-degli-esercizi","text":"Scriviamo una funzione che restituisca il prodotto riga per colonna di due vettori v1 e v2 . Usiamo una list comprehension, e verifichiamo che la lunghezza dei due vettori sia coerente. Il metodo dovr\u00e0 funzionare indipendentemente dall\u2019ordine in cui sono passati i parametri. def riga_per_colonna ( v1 , v2 ): if v1 . shape [ 0 ] == 1 : if v2 . shape [ 1 ] == 1 and v1 . shape [ 1 ] == v2 . shape [ 0 ]: return sum ([ v1 [ 0 ][ i ] * v2 [ i ] for i in range ( v2 . shape [ 0 ])]) elif v2 . shape [ 0 ] == 1 : if v1 . shape [ 1 ] == 1 and v2 . shape [ 1 ] == v1 . shape [ 0 ]: return sum ([ v1 [ i ] * v2 [ 0 ][ i ] for i in range ( v1 . shape [ 0 ])]) raise ValueError ( 'Le dimensioni dei vettori non sono coerenti.' ) v1 = np . array ([[ 1 , 2 , 3 , 4 ]]) v2 = np . array ([[ 1 ],[ 2 ],[ 3 ],[ 4 ]]) riga_per_colonna ( v1 , v2 ) riga_per_colonna ( v2 , v1 ) riga_per_colonna ( np . array ([[ 1 ]]), v2 ) Scriviamo una funzione crea_array(dim_1, dim_2, val_min, val_max) che crei array di dimensioni arbitrarie dim_1 x dim_2 fatti di numeri interi casuali compresi tra val_min e val_max . Di default, la funzione dovr\u00e0 creare dei vettori riga. import numpy as np from random import randint def crea_array ( dim_1 , dim_2 = 1 , val_min = 0 , val_max = 100 ): rows = [[ randint ( val_min , val_max ) for i in range ( dim_2 )] for j in range ( dim_1 )] return np . array ( rows ) a_1 = crea_array ( 4 , 1 ) a_2 = crea_array ( 2 , 2 )","title":"Risoluzione degli esercizi"},{"location":"material/02_libs/07_numpy/02_array/lecture/","text":"Introduzione agli array \u00b6 Nella scorsa lezione , abbiamo introdotto gli array , ovvero la struttura dati \"centrale\" all'interno dell'ecosistema di NumPy. In questa lezione e nelle successive ne approfondiremo gli aspetti e le caratteristiche principali. Array e liste \u00b6 La prima impressione che si pu\u00f2 avere \u00e8 che gli array siano molto simili alle classiche liste. Esistono per\u00f2 alcune differenze, cui abbiamo gi\u00e0 accennato nella scorsa lezione. In linea di massima, per\u00f2, \u00e8 preferibile usare un array quando si ha a che fare con operazioni di tipo matematico su dati omogenei , ovvero dello stesso tipo. Questo \u00e8 collegato essenzialmente a questioni di ottimizzazione : NumPy sfrutta per le operazioni matematiche del codice precompilato in C, ed inoltre gli array sono pi\u00f9 compatti e veloci da utilizzare rispetto alle liste. La classe ndarray \u00b6 Alle volte, ci si pu\u00f2 riferire ad un array con il termine ndarray , abbreviazione che sta per \\(n\\) -dimensional array. Questa \u00e8, in realt\u00e0, la rappresentazione pi\u00f9 generica degli array di NumPy, e permette di caratterizzare delle strutture dati con un numero arbitrario di dimensioni ( \\(n\\) , per l'appunto). Vettori, matrici e tensori Una struttura di tipo algebrico ad \\(n\\) dimensioni, con \\(n > 2\\) , \u00e8 detta tensore . Se \\(n = 1\\) , abbiamo un vettore , mentre con \\(n = 2\\) abbiamo una matrice . Creazione ed inizializzazione \u00b6 Il primo passo per utilizzare un ndarray \u00e8, ovviamente, crearlo! Per farlo, ci sono diversi metodi, ma il pi\u00f9 semplice \u00e8 sicuramente quello di passare al metodo array() di NumPy una lista di elementi. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) Possiamo passare anche una \"lista di liste\", in modo da ottenere un array multidimensionale: >>> b = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> b array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Gli array non sono necessariamente numerici. Possiamo, ad esempio, creare un array di stringhe: >>> c = np . array ([ \"s1\" , \"s2\" ]) >>> c array ([ 's1' , 's2' ], dtype = '<U2' ) Array eterogenei \u00b6 Abbiamo gi\u00e0 detto che gli array, a differenza delle stringhe, devono contenere dati omogenei , ovvero dello stesso tipo. Cosa succede se proviamo a passare al metodo numpy.array() una lista composta da dati di tipo differente? Facciamo un esempio. >>> d = np . array ([ 1 , 1. ]) >>> d array ([ 1. , 1. ]) Abbiamo passato al metodo array() un valore intero ed un float. Possiamo notare che \u00e8 stato effettuato un casting in maniera implicita, e tutti i valori passati sono stati convertiti in float. Vediamo cosa accade se provassimo a passare un intero ed una stringa. >>> e = np . array ([ 1 , \"s3\" ]) >>> e array ([ '1' , 's3' ], dtype = '<U11' ) Anche in questo caso, \u00e8 stata effettuata la conversione dei dati in automatico, passando stavolta da intero a stringa. La regola da tenere a mente, ad ogni modo, \u00e8 che NumPy (e, in generale, Python) seguono il principio dell' upcasting : in altre parole, quando deve essere fatta una conversione tra diversi tipi di dati, si far\u00e0 in modo da convertire tutte le variabili nel tipo a pi\u00f9 alta precisione , allo scopo di evitare perdite di informazioni. Il numero di elementi di un array \u00b6 Abbiamo detto che un array \u00e8 un \"contenitore\", a dimensione prefissata, per oggetti di un ben determinato tipo e dimensione. Il numero di dimensioni e gli oggetti contenuti all'interno di un array sono definiti a partire da una propriet\u00e0 chiamata shape , liberamente traducibile in \"forma\". Quest'ultima \u00e8 una tupla di numeri interi, ovviamente non negativi, che permette di determinare la dimensionalit\u00e0 dell'array lungo ogni asse (ovvero \\(x\\) , \\(y\\) , \\(z\\) , etc.). Ad esempio, potremo dire che il seguente array bidimensionale ha due assi, il primo di lunghezza due, il secondo di lunghezza tre: >>> a = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]]) >>> a array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Proviamo a valutare la propriet\u00e0 shape del precedente array: >>> a . shape ( 2 , 3 ) Costruzione di un array \u00b6 Nella lezione precedente abbiamo visto come sia possibile creare un array NumPy usando la funzione np.array() , che ci permette di crearlo a partire da una semplice lista: >>> a = np . array ([ 1 , 2 , 3 ]) Volendo, per\u00f2, possiamo usare anche il costruttore della classe ndarray , cui dovremo passare come minimo la shape desiderata: >>> a = np . ndarray ([ 3 , 3 ]) # oppure a = np.ndarray(shape=(3,3)) >>> a array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 3.02368175e-321 ], [ 6.69431255e+151 , 1.68534231e+246 , 6.69431467e+151 ]]) Nota I numeri con cui viene \"riempito\" l'array sono casuali, ed andranno definiti solo in seguito. Al di l\u00e0 di questi metodi base, esistono altri modi per costruire tipi di array ben specifici. Vediamoli brevemente. Costruire un array: alcuni modi alternativi \u00b6 Array con valori zero ed unitari \u00b6 Possiamo creare un array di dimensioni arbitrarie in cui tutti gli elementi sono pari ad 1. Per farlo, usiamo la funzione ones() : >>> u = np . ones ( shape = ( 3 , 3 )) >>> u array ([[ 1. , 1. , 1. ], [ 1. , 1. , 1. ], [ 1. , 1. , 1. ]]) In modo simile, possiamo creare array di dimensioni arbitrarie in cui tutti gli elementi sono pari a zero mediante la funzione zeros() : >>> z = np . zeros ( shape = ( 3 , 3 )) >>> z array ([[ 0. , 0. , 0. ], [ 0. , 0. , 0. ], [ 0. , 0. , 0. ]]) Array vuoti \u00b6 Possiamo creare un array vuoto mediante la funzione empty() : >>> e = np . empty ( shape = ( 3 , 3 )) >>> e array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 1.67982320e-321 ], [ 5.96555652e-302 , 1.14188703e-104 , 9.91401238e-278 ]]) Questa funzione pu\u00f2 risultare utile quando vogliamo preallocare spazio per un array. Nota I pi\u00f9 attenti avranno notato che, in realt\u00e0, l'array generato da empty() non \u00e8 vuoto, ma contiene valori casuali. Matrice identit\u00e0 \u00b6 Possiamo creare una matrice identit\u00e0 usando la funzione eye() : >>> i = np . eye ( 3 ) >>> i array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Attenzione In questo caso, notiamo come non si possa passare una tupla o una lista per indicare le dimensioni dell'array. Tuttavia, possiamo specificare sia il numero delle righe (con il primo parametro) che il numero delle colonne (con il secondo parametro). Matrici diagonali \u00b6 La funzione diag() viene usata sia per creare una matrice diagonale a partire da un vettore (che, ovviamente, sar\u00e0 poi la diagonale della matrice), sia per estrarre la diagonale di una matrice. Facciamo alcuni esempi. Da vettore a matrice \u00b6 Immaginiamo di avere un vettore riga a tre elementi. >>> x = np . array ([ 5 , 2 , 3 ]) >>> x array ([ 5 , 2 , 3 ]) Possiamo creare una matrice diagonale passando questo vettore come argomento alla funzione diag() : >>> d = np . diag ( x ) >>> d array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 3 ]]) Da matrice a vettore \u00b6 Affrontiamo adesso il problema duale. Immaginiamo di avere il seguente array, e volerne estrarre la diagonale: >>> x >>> x array ([[ 5 , 2 , 2 ], [ 2 , 1 , 3 ], [ 4 , 3 , 6 ]]) Per farlo, dovremo anche questa volta usare la funzione diag() , passando per\u00f2 l'array: >>> d = np . diag ( x ) >>> d array ([ 5 , 1 , 6 ]) Suggerimento Il fatto che la funzione diag() sia usata per operazioni duali pu\u00f2, a ragione, causare confusione. Basta per\u00f2 ricordare che passando un vettore si ottiene una matrice, mentre passando una matrice si ottiene un vettore, ed il gioco \u00e8 fatto. Attenzione La funzione diag() accetta solo input monodimensionali (vettori) e bidimensionali (matrici)! Matrici triangolari \u00b6 Concludiamo questa breve carrellata mostrando due metodi in grado di estrarre la matrice triangolare, rispettivamente superiore ed inferiore. Supponiamo di avere la matrice x definita in precedenza. Per estrarre la matrice triangolare superiore, dovremo usare la funzione triu() : >>> tu = np . triu ( x ) >>> tu array ([[ 5 , 2 , 2 ], [ 0 , 1 , 3 ], [ 0 , 0 , 6 ]]) Per estrarre invece la matrice triangolare inferiore, dovremo usare la funzione tril() : >>> tl = np . tril ( x ) >>> tl array ([[ 5 , 0 , 0 ], [ 2 , 1 , 0 ], [ 4 , 3 , 6 ]]) Suggerimento In questo caso, le funzioni tril() e triu() possono tranquillamente essere applicate agli array n-dimensionali. Inoltre, non \u00e8 richiesto che l'array sia quadrato. Accedere agli elementi di un array \u00b6 Il modo pi\u00f9 immediato per accedere al valore di un elemento in un array \u00e8 usare l'operatore [] , specificando contestualmente l'indice dell'elemento cui si vuole accedere, proprio come avviene per le liste. Ad esempio, possiamo selezionare il primo elemento di un array con questa sintassi: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 ] 1 Nel caso di array ad \\(n\\) dimensioni, \u00e8 necessario indicare l'indice per ciascuna delle dimensioni dell'array. Nel caso di un array bidimensionale, potremmo selezionare l'elemento alla prima riga e prima colonna con una sintassi di questo tipo: >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 ][ 0 ] 1 Maschere booleane \u00b6 Possiamo accedere ad un sottoinsieme di elementi dell'array mediante una \"maschera\", che consiste in un array di dimensioni uguali a quelle di partenza, ma composto soltanto da valori booleani; ovviamente, saranno estratti solo gli elementi il cui indice nella maschera \u00e8 a True . Ad esempio, possiamo selezionare tutti gli elementi appartenenti alla prima colonna dell'array b : >>> mask = ([ True , False ], [ True , False ]) >>> b [ mask ] array ([ 1 , 3 ]) Oppure possiamo scegliere tutti gli elementi che soddisfano una certa condizione logico/matematica: >>> mask = ( b > 2 ) >>> mask array ([[ False , False ], [ True , True ]]) >>> b [ mask ] array ([ 3 , 4 ]) La precedente notazione pu\u00f2 essere ulteriormente sintetizzata \"prendendo in prestito\" i principi della programmazione funzionale: >>> b [ b > 2 ] array ([ 3 , 4 ]) Volendo, possiamo adattare la forma precedente all'uso di espressioni arbitrariamente complesse: >>> b [ b % 2 == 0 ] array ([ 2 , 4 ]) >>> b [( b > 1 ) & ( b < 4 )] array ([ 2 , 3 ]) Slicing degli array \u00b6 Cos\u00ec come le liste, gli array consentono di effettuare lo slicing: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 : 2 ] array ([ 1 , 2 ]) Per gli array multidimensionali, lo slicing si intende sulla n-ma dimensione dell'array. Questo concetto \u00e8 facile da comprendere se si visualizza l'array ad n-dimensioni come un array di array: >>> b array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 : 1 ] # Lo slicing avviene sulla seconda dimensione array ([[ 1 , 2 ]]) La funzione nonzero() \u00b6 Possiamo usare la funzione nonzero() per selezionare gli elementi e gli indici di un array il cui valore non sia pari a zero. Ad esempio: >>> x = np . array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) >>> x array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) Applicando la funzione nonzero() , avremo una tupla con gli indici per riga e colonna degli elementi diversi da zero: >>> np . nonzero ( x ) ( array ([ 0 , 1 , 2 , 2 ], dtype = int64 ), array ([ 0 , 1 , 0 , 1 ], dtype = int64 )) Notiamo che nella tupla \u00e8 presente un array per ciascuna delle dimensioni dell'array x . In questo caso, il primo array rappresenta gli indici relativi alla prima dimensione dei valori non nulli (in questo caso, gli indici di riga), mentre il secondo gli indici relativi alla seconda dimensione (indici di colonna). Volendo, \u00e8 possibile ottenere una lista di tuple rappresentative delle coppie di indici rappresentative dei valori non nulli, ad esempio mediante la funzione zip() : >>> coords = list ( zip ( s [ 0 ], s [ 1 ])) >>> coords [( 0 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 )] Fancy indexing \u00b6 Una tecnica estremamente interessante \u00e8 quella del fancy indexing . Concettualmente, questa indicizzazione prevede che venga passato un array di indici, in modo da accedere a pi\u00f9 elementi di un array contemporaneamente. Facciamo un esempio. >>> rand = np . random . RandomState ( 42 ) >>> x = rand . randint ( 100 , size = 10 ) >>> indexes = np . array ([[ 1 , 4 ],[ 5 , 2 ]]) >>> x array ([ 51 , 92 , 14 , 71 , 60 , 20 , 82 , 86 , 74 , 74 ]) >>> x [ indexes ] array ([[ 92 , 60 ], [ 20 , 14 ]]) Nel codice precedente, stiamo: usando la funzione randint per generare un array di numeri interi casuali compresi tra 0 e 100; generando un array bidimensionale indexes ; restituendo, mediante il fancy indexing, un array con le dimensioni di indexes e gli elementi di x presi nelle posizioni indicate da indexes . La potenza del fancy indexing sta proprio in questo: non solo siamo in grado di accedere facilmente a pi\u00f9 elementi di un array mediante un'unica operazione, ma possiamo anche ridisporre questi elementi come pi\u00f9 ci aggrada!","title":"07.2 - Gli Array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#introduzione-agli-array","text":"Nella scorsa lezione , abbiamo introdotto gli array , ovvero la struttura dati \"centrale\" all'interno dell'ecosistema di NumPy. In questa lezione e nelle successive ne approfondiremo gli aspetti e le caratteristiche principali.","title":"Introduzione agli array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#array-e-liste","text":"La prima impressione che si pu\u00f2 avere \u00e8 che gli array siano molto simili alle classiche liste. Esistono per\u00f2 alcune differenze, cui abbiamo gi\u00e0 accennato nella scorsa lezione. In linea di massima, per\u00f2, \u00e8 preferibile usare un array quando si ha a che fare con operazioni di tipo matematico su dati omogenei , ovvero dello stesso tipo. Questo \u00e8 collegato essenzialmente a questioni di ottimizzazione : NumPy sfrutta per le operazioni matematiche del codice precompilato in C, ed inoltre gli array sono pi\u00f9 compatti e veloci da utilizzare rispetto alle liste.","title":"Array e liste"},{"location":"material/02_libs/07_numpy/02_array/lecture/#la-classe-ndarray","text":"Alle volte, ci si pu\u00f2 riferire ad un array con il termine ndarray , abbreviazione che sta per \\(n\\) -dimensional array. Questa \u00e8, in realt\u00e0, la rappresentazione pi\u00f9 generica degli array di NumPy, e permette di caratterizzare delle strutture dati con un numero arbitrario di dimensioni ( \\(n\\) , per l'appunto). Vettori, matrici e tensori Una struttura di tipo algebrico ad \\(n\\) dimensioni, con \\(n > 2\\) , \u00e8 detta tensore . Se \\(n = 1\\) , abbiamo un vettore , mentre con \\(n = 2\\) abbiamo una matrice .","title":"La classe ndarray"},{"location":"material/02_libs/07_numpy/02_array/lecture/#creazione-ed-inizializzazione","text":"Il primo passo per utilizzare un ndarray \u00e8, ovviamente, crearlo! Per farlo, ci sono diversi metodi, ma il pi\u00f9 semplice \u00e8 sicuramente quello di passare al metodo array() di NumPy una lista di elementi. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) Possiamo passare anche una \"lista di liste\", in modo da ottenere un array multidimensionale: >>> b = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> b array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Gli array non sono necessariamente numerici. Possiamo, ad esempio, creare un array di stringhe: >>> c = np . array ([ \"s1\" , \"s2\" ]) >>> c array ([ 's1' , 's2' ], dtype = '<U2' )","title":"Creazione ed inizializzazione"},{"location":"material/02_libs/07_numpy/02_array/lecture/#array-eterogenei","text":"Abbiamo gi\u00e0 detto che gli array, a differenza delle stringhe, devono contenere dati omogenei , ovvero dello stesso tipo. Cosa succede se proviamo a passare al metodo numpy.array() una lista composta da dati di tipo differente? Facciamo un esempio. >>> d = np . array ([ 1 , 1. ]) >>> d array ([ 1. , 1. ]) Abbiamo passato al metodo array() un valore intero ed un float. Possiamo notare che \u00e8 stato effettuato un casting in maniera implicita, e tutti i valori passati sono stati convertiti in float. Vediamo cosa accade se provassimo a passare un intero ed una stringa. >>> e = np . array ([ 1 , \"s3\" ]) >>> e array ([ '1' , 's3' ], dtype = '<U11' ) Anche in questo caso, \u00e8 stata effettuata la conversione dei dati in automatico, passando stavolta da intero a stringa. La regola da tenere a mente, ad ogni modo, \u00e8 che NumPy (e, in generale, Python) seguono il principio dell' upcasting : in altre parole, quando deve essere fatta una conversione tra diversi tipi di dati, si far\u00e0 in modo da convertire tutte le variabili nel tipo a pi\u00f9 alta precisione , allo scopo di evitare perdite di informazioni.","title":"Array eterogenei"},{"location":"material/02_libs/07_numpy/02_array/lecture/#il-numero-di-elementi-di-un-array","text":"Abbiamo detto che un array \u00e8 un \"contenitore\", a dimensione prefissata, per oggetti di un ben determinato tipo e dimensione. Il numero di dimensioni e gli oggetti contenuti all'interno di un array sono definiti a partire da una propriet\u00e0 chiamata shape , liberamente traducibile in \"forma\". Quest'ultima \u00e8 una tupla di numeri interi, ovviamente non negativi, che permette di determinare la dimensionalit\u00e0 dell'array lungo ogni asse (ovvero \\(x\\) , \\(y\\) , \\(z\\) , etc.). Ad esempio, potremo dire che il seguente array bidimensionale ha due assi, il primo di lunghezza due, il secondo di lunghezza tre: >>> a = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]]) >>> a array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Proviamo a valutare la propriet\u00e0 shape del precedente array: >>> a . shape ( 2 , 3 )","title":"Il numero di elementi di un array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#costruzione-di-un-array","text":"Nella lezione precedente abbiamo visto come sia possibile creare un array NumPy usando la funzione np.array() , che ci permette di crearlo a partire da una semplice lista: >>> a = np . array ([ 1 , 2 , 3 ]) Volendo, per\u00f2, possiamo usare anche il costruttore della classe ndarray , cui dovremo passare come minimo la shape desiderata: >>> a = np . ndarray ([ 3 , 3 ]) # oppure a = np.ndarray(shape=(3,3)) >>> a array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 3.02368175e-321 ], [ 6.69431255e+151 , 1.68534231e+246 , 6.69431467e+151 ]]) Nota I numeri con cui viene \"riempito\" l'array sono casuali, ed andranno definiti solo in seguito. Al di l\u00e0 di questi metodi base, esistono altri modi per costruire tipi di array ben specifici. Vediamoli brevemente.","title":"Costruzione di un array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#costruire-un-array-alcuni-modi-alternativi","text":"","title":"Costruire un array: alcuni modi alternativi"},{"location":"material/02_libs/07_numpy/02_array/lecture/#array-con-valori-zero-ed-unitari","text":"Possiamo creare un array di dimensioni arbitrarie in cui tutti gli elementi sono pari ad 1. Per farlo, usiamo la funzione ones() : >>> u = np . ones ( shape = ( 3 , 3 )) >>> u array ([[ 1. , 1. , 1. ], [ 1. , 1. , 1. ], [ 1. , 1. , 1. ]]) In modo simile, possiamo creare array di dimensioni arbitrarie in cui tutti gli elementi sono pari a zero mediante la funzione zeros() : >>> z = np . zeros ( shape = ( 3 , 3 )) >>> z array ([[ 0. , 0. , 0. ], [ 0. , 0. , 0. ], [ 0. , 0. , 0. ]])","title":"Array con valori zero ed unitari"},{"location":"material/02_libs/07_numpy/02_array/lecture/#array-vuoti","text":"Possiamo creare un array vuoto mediante la funzione empty() : >>> e = np . empty ( shape = ( 3 , 3 )) >>> e array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 1.67982320e-321 ], [ 5.96555652e-302 , 1.14188703e-104 , 9.91401238e-278 ]]) Questa funzione pu\u00f2 risultare utile quando vogliamo preallocare spazio per un array. Nota I pi\u00f9 attenti avranno notato che, in realt\u00e0, l'array generato da empty() non \u00e8 vuoto, ma contiene valori casuali.","title":"Array vuoti"},{"location":"material/02_libs/07_numpy/02_array/lecture/#matrice-identita","text":"Possiamo creare una matrice identit\u00e0 usando la funzione eye() : >>> i = np . eye ( 3 ) >>> i array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Attenzione In questo caso, notiamo come non si possa passare una tupla o una lista per indicare le dimensioni dell'array. Tuttavia, possiamo specificare sia il numero delle righe (con il primo parametro) che il numero delle colonne (con il secondo parametro).","title":"Matrice identit\u00e0"},{"location":"material/02_libs/07_numpy/02_array/lecture/#matrici-diagonali","text":"La funzione diag() viene usata sia per creare una matrice diagonale a partire da un vettore (che, ovviamente, sar\u00e0 poi la diagonale della matrice), sia per estrarre la diagonale di una matrice. Facciamo alcuni esempi.","title":"Matrici diagonali"},{"location":"material/02_libs/07_numpy/02_array/lecture/#da-vettore-a-matrice","text":"Immaginiamo di avere un vettore riga a tre elementi. >>> x = np . array ([ 5 , 2 , 3 ]) >>> x array ([ 5 , 2 , 3 ]) Possiamo creare una matrice diagonale passando questo vettore come argomento alla funzione diag() : >>> d = np . diag ( x ) >>> d array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 3 ]])","title":"Da vettore a matrice"},{"location":"material/02_libs/07_numpy/02_array/lecture/#da-matrice-a-vettore","text":"Affrontiamo adesso il problema duale. Immaginiamo di avere il seguente array, e volerne estrarre la diagonale: >>> x >>> x array ([[ 5 , 2 , 2 ], [ 2 , 1 , 3 ], [ 4 , 3 , 6 ]]) Per farlo, dovremo anche questa volta usare la funzione diag() , passando per\u00f2 l'array: >>> d = np . diag ( x ) >>> d array ([ 5 , 1 , 6 ]) Suggerimento Il fatto che la funzione diag() sia usata per operazioni duali pu\u00f2, a ragione, causare confusione. Basta per\u00f2 ricordare che passando un vettore si ottiene una matrice, mentre passando una matrice si ottiene un vettore, ed il gioco \u00e8 fatto. Attenzione La funzione diag() accetta solo input monodimensionali (vettori) e bidimensionali (matrici)!","title":"Da matrice a vettore"},{"location":"material/02_libs/07_numpy/02_array/lecture/#matrici-triangolari","text":"Concludiamo questa breve carrellata mostrando due metodi in grado di estrarre la matrice triangolare, rispettivamente superiore ed inferiore. Supponiamo di avere la matrice x definita in precedenza. Per estrarre la matrice triangolare superiore, dovremo usare la funzione triu() : >>> tu = np . triu ( x ) >>> tu array ([[ 5 , 2 , 2 ], [ 0 , 1 , 3 ], [ 0 , 0 , 6 ]]) Per estrarre invece la matrice triangolare inferiore, dovremo usare la funzione tril() : >>> tl = np . tril ( x ) >>> tl array ([[ 5 , 0 , 0 ], [ 2 , 1 , 0 ], [ 4 , 3 , 6 ]]) Suggerimento In questo caso, le funzioni tril() e triu() possono tranquillamente essere applicate agli array n-dimensionali. Inoltre, non \u00e8 richiesto che l'array sia quadrato.","title":"Matrici triangolari"},{"location":"material/02_libs/07_numpy/02_array/lecture/#accedere-agli-elementi-di-un-array","text":"Il modo pi\u00f9 immediato per accedere al valore di un elemento in un array \u00e8 usare l'operatore [] , specificando contestualmente l'indice dell'elemento cui si vuole accedere, proprio come avviene per le liste. Ad esempio, possiamo selezionare il primo elemento di un array con questa sintassi: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 ] 1 Nel caso di array ad \\(n\\) dimensioni, \u00e8 necessario indicare l'indice per ciascuna delle dimensioni dell'array. Nel caso di un array bidimensionale, potremmo selezionare l'elemento alla prima riga e prima colonna con una sintassi di questo tipo: >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 ][ 0 ] 1","title":"Accedere agli elementi di un array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#maschere-booleane","text":"Possiamo accedere ad un sottoinsieme di elementi dell'array mediante una \"maschera\", che consiste in un array di dimensioni uguali a quelle di partenza, ma composto soltanto da valori booleani; ovviamente, saranno estratti solo gli elementi il cui indice nella maschera \u00e8 a True . Ad esempio, possiamo selezionare tutti gli elementi appartenenti alla prima colonna dell'array b : >>> mask = ([ True , False ], [ True , False ]) >>> b [ mask ] array ([ 1 , 3 ]) Oppure possiamo scegliere tutti gli elementi che soddisfano una certa condizione logico/matematica: >>> mask = ( b > 2 ) >>> mask array ([[ False , False ], [ True , True ]]) >>> b [ mask ] array ([ 3 , 4 ]) La precedente notazione pu\u00f2 essere ulteriormente sintetizzata \"prendendo in prestito\" i principi della programmazione funzionale: >>> b [ b > 2 ] array ([ 3 , 4 ]) Volendo, possiamo adattare la forma precedente all'uso di espressioni arbitrariamente complesse: >>> b [ b % 2 == 0 ] array ([ 2 , 4 ]) >>> b [( b > 1 ) & ( b < 4 )] array ([ 2 , 3 ])","title":"Maschere booleane"},{"location":"material/02_libs/07_numpy/02_array/lecture/#slicing-degli-array","text":"Cos\u00ec come le liste, gli array consentono di effettuare lo slicing: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 : 2 ] array ([ 1 , 2 ]) Per gli array multidimensionali, lo slicing si intende sulla n-ma dimensione dell'array. Questo concetto \u00e8 facile da comprendere se si visualizza l'array ad n-dimensioni come un array di array: >>> b array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 : 1 ] # Lo slicing avviene sulla seconda dimensione array ([[ 1 , 2 ]])","title":"Slicing degli array"},{"location":"material/02_libs/07_numpy/02_array/lecture/#la-funzione-nonzero","text":"Possiamo usare la funzione nonzero() per selezionare gli elementi e gli indici di un array il cui valore non sia pari a zero. Ad esempio: >>> x = np . array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) >>> x array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) Applicando la funzione nonzero() , avremo una tupla con gli indici per riga e colonna degli elementi diversi da zero: >>> np . nonzero ( x ) ( array ([ 0 , 1 , 2 , 2 ], dtype = int64 ), array ([ 0 , 1 , 0 , 1 ], dtype = int64 )) Notiamo che nella tupla \u00e8 presente un array per ciascuna delle dimensioni dell'array x . In questo caso, il primo array rappresenta gli indici relativi alla prima dimensione dei valori non nulli (in questo caso, gli indici di riga), mentre il secondo gli indici relativi alla seconda dimensione (indici di colonna). Volendo, \u00e8 possibile ottenere una lista di tuple rappresentative delle coppie di indici rappresentative dei valori non nulli, ad esempio mediante la funzione zip() : >>> coords = list ( zip ( s [ 0 ], s [ 1 ])) >>> coords [( 0 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 )]","title":"La funzione nonzero()"},{"location":"material/02_libs/07_numpy/02_array/lecture/#fancy-indexing","text":"Una tecnica estremamente interessante \u00e8 quella del fancy indexing . Concettualmente, questa indicizzazione prevede che venga passato un array di indici, in modo da accedere a pi\u00f9 elementi di un array contemporaneamente. Facciamo un esempio. >>> rand = np . random . RandomState ( 42 ) >>> x = rand . randint ( 100 , size = 10 ) >>> indexes = np . array ([[ 1 , 4 ],[ 5 , 2 ]]) >>> x array ([ 51 , 92 , 14 , 71 , 60 , 20 , 82 , 86 , 74 , 74 ]) >>> x [ indexes ] array ([[ 92 , 60 ], [ 20 , 14 ]]) Nel codice precedente, stiamo: usando la funzione randint per generare un array di numeri interi casuali compresi tra 0 e 100; generando un array bidimensionale indexes ; restituendo, mediante il fancy indexing, un array con le dimensioni di indexes e gli elementi di x presi nelle posizioni indicate da indexes . La potenza del fancy indexing sta proprio in questo: non solo siamo in grado di accedere facilmente a pi\u00f9 elementi di un array mediante un'unica operazione, ma possiamo anche ridisporre questi elementi come pi\u00f9 ci aggrada!","title":"Fancy indexing"},{"location":"material/02_libs/07_numpy/03_arithmetics/exercises/","text":"Risoluzione degli esercizi \u00b6 Scriviamo la funzione rettifica(array) , che restituisce un array delle stesse dimensioni di quello in ingresso ma che porta tutti i valori negativi a 0. def rettifica ( array ): array [ array < 0 ] = 0 return array rettifica ( np . array ([ - 1 , 2 , - 3 , 4 ])) Scriviamo la funzione asort(vect) che restituisce un vettore riga ordinato in modo discendente. def asort ( array ): s = np . sort ( array ) return s [ - 1 :: - 1 ] asort ( np . array ([ 3 , 2 , 5 , - 1 ]))","title":"E7.3 - Aritmetica in NumPy"},{"location":"material/02_libs/07_numpy/03_arithmetics/exercises/#risoluzione-degli-esercizi","text":"Scriviamo la funzione rettifica(array) , che restituisce un array delle stesse dimensioni di quello in ingresso ma che porta tutti i valori negativi a 0. def rettifica ( array ): array [ array < 0 ] = 0 return array rettifica ( np . array ([ - 1 , 2 , - 3 , 4 ])) Scriviamo la funzione asort(vect) che restituisce un vettore riga ordinato in modo discendente. def asort ( array ): s = np . sort ( array ) return s [ - 1 :: - 1 ] asort ( np . array ([ 3 , 2 , 5 , - 1 ]))","title":"Risoluzione degli esercizi"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/","text":"Operare sugli array \u00b6 NumPy offre numerose modalit\u00e0 per operare sugli array e manipolarli. Vediamone alcune. Operazioni algebriche di base \u00b6 Possiamo usare due array per effettuare diversi tipi di operazioni algebriche di base. Ad esempio, per sommare due array: >>> a = np . array ([ 1 , 2 ]) >>> b = np . array ([ 3 , 4 ]) >>> a + b array ([ 4 , 6 ]) Possiamo ovviamente anche fare le altre operazioni fondamentali: >>> a - b array ([ - 2 , - 2 ]) >>> a * b array ([ 3 , 8 ]) >>> a / b array ([ 0.33333333 , 0.5 ]) >>> b / a array ([ 3. , 2. ]) Moltiplicazione e divisione Per comprendere appieno il comportamento degli operatori * e /, dovremo parlare del broadcasting. Lo faremo in una delle prossime lezioni. La funzione sum \u00b6 La funzione sum(axis=None) ci permette di sommare tutti gli elementi di un array lungo l'asse specificato. Ad esempio, per sommare tutti gli elementi di un vettore: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a . sum () 10 In caso di array multidimensionale, dovremo specificare, come gi\u00e0 detto, l'asse. Ad esempio, per sommare gli elementi per colonna, dovremo passare il parametro 0 : >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b . sum ( axis = 0 ) array ([ 4 , 6 ]) Per sommare gli elementi per riga, invece, dovremo passare il parametro 1 : >>> b . sum ( axis = 1 ) array ([ 3 , 7 ]) La funzione dot() \u00b6 La funzione dot() ci permette di effettuare l'operazione di moltiplicazione matriciale standard: >>> a = np . array ([[ 1 , 2 ]]) >>> b = np . array ([[ 3 ], [ 4 ]]) >>> a . dot ( b ) array ([ 11 ]) >>> b . dot ( a ) array ([[ 3 , 6 ], [ 4 , 8 ]]) Ordinamento degli elementi di un array \u00b6 Ordinare gli elementi di un array \u00e8 possibile usando la funzione sort() . Ad esempio: >>> arr = np . array ([ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ]) >>> np . sort ( arr ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) L'ordine avviene, di default, in maniera ascendente . In caso di array n-dimensionale, possiamo anche specificare l'asse lungo il quale avviene l'ordinamento, specificando il parametro axis. Ad esempio: >>> mat = np . array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) >>> mat array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) Per ordinare lungo le colonne: >>> np . sort ( mat , axis = 0 ) array ([[ 2 , 2 , 1 ], [ 4 , 3 , 1 ], [ 7 , 5 , 6 ]]) Mentre per ordinare lungo le righe: >>> np . sort ( mat , axis = 1 ) array ([[ 1 , 2 , 3 ], [ 2 , 4 , 6 ], [ 1 , 5 , 7 ]]) Nota Esistono anche altre funzioni per l'ordinamento di un array, che per\u00f2 non tratteremo in questo corso. Concatenazione di pi\u00f9 array \u00b6 Possiamo concatenare due array usando la funzione concatenate() : >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> b = np . array ([ 5 , 6 , 7 , 8 ]) >>> np . concatenate (( a , b )) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) Si pu\u00f2 anche in questo caso usare il parametro axis per specificare l'asse lungo quale concatenare due diversi array: >>> x = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> y = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 1 ) array ([[ 1 , 2 , 5 , 6 ], [ 3 , 4 , 7 , 8 ]]) Ovviamente, le dimensioni degli array devono essere coerenti affinch\u00e9 vengano concatenati. Ad esempio, con questo array: >>> z = np . array ([[ 9 , 10 ]]) la concatenazione per righe \u00e8 ammissibile: >>> np . concatenate (( x , z ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 9 , 10 ]]) mentre la concatenazione per colonne non \u00e8 possibile: >>> np . concatenate (( x , z ), axis = 1 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<__array_function__ internals>\" , line 5 , in concatenate ValueError : all the input array dimensions for the concatenation axis must match exactly , but along dimension 0 , the array at index 0 has size 2 and the array at index 1 has size 1 Rimozione ed inserimento di elementi in un array \u00b6 La funzione delete \u00b6 La funzione delete(arr, obj, axis=None) ci permette di rimuovere uno o pi\u00f9 elementi di un array specificandone gli indici. La funzione accetta i seguenti parametri: arr : l'array sul quale vogliamo effettuare l'operazione di rimozione; obj : gli indici degli elementi da rimuovere; axis : l'asse su cui vogliamo operare. Ad esempio, immaginiamo di voler rimuovere il primo elemento di un vettore: >>> arr = np . array ([ 1 , 2 , 3 , 4 ]) >>> np . delete ( arr , 0 ) array ([ 2 , 3 , 4 ]) >>> arr La funzione pu\u00f2 essere anche applicata su pi\u00f9 indici usando una sequenza: >>> np . delete ( arr , range ( 2 )) array ([ 3 , 4 ]) Possiamo anche usare lo slicing: >>> idx = range ( 4 ) >>> np . delete ( arr , idx [ 0 : 2 ]) array ([ 3 , 4 ]) Suggerimento La precedente notazione pu\u00f2 essere rimpiazzata dalla funzione slice(start, stop, step) , che crea un oggetto di classe slice sugli indici che vanno da start a stop con passo step . Questo pu\u00f2 essere usato per scopi analoghi ai precedenti; ad esempio: >>> np . delete ( a , slice ( 0 , 2 , 1 )) array ([ 3 , 4 ]) Array multidimensionali \u00b6 La funzione pu\u00f2 essere usata anche su array multidimensionali. In questo caso, \u00e8 opportuno specificare l'asse su cui operare. Ad esempio, se vogliamo rimuovere la prima riga dal seguente array, dobbiamo dare il valore 0 al parametro axis : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) >>> np . delete ( mat , 0 , 0 ) array ([[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) Invece, se vogliamo rimuovere la prima colonna, dobbiamo passare il valore 1 : >>> np . delete ( mat , 0 , 1 ) array ([[ 2 , 3 ], [ 5 , 6 ], [ 8 , 9 ]]) Se non specificassimo alcun valore per il parametro axis , otterremmo questo risultato: >>> np . delete ( mat , 0 ) array ([ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Cosa \u00e8 accaduto? In pratica, \u00e8 stato rimosso il primo elemento dell'array vettorizzato ( flattened ). Rimozione di elementi mediante maschere booleane \u00b6 Spesso \u00e8 preferibile usare, al posto della notazione precedente, una maschera booleana: >>> mask = [ False , False , True , True ] >>> arr [ mask ] array ([ 3 , 4 ]) La funzione insert \u00b6 La funzione insert(arr, obj, values, axis=None) permette di inserire un elemento all'interno di un array. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; obj : gli indici su cui inserire i nuovi valori; values : i valori da inserire agli indici specificati da obj ; axis : l'asse su cui vogliamo operare. Ad esempio, per inserire una nuova riga nella matrice precedente, dovremo specificare l'indice di riga ( 3 ), gli elementi della riga da inserire ( [10, 11, 12] ) e l'asse ( 0 ): >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Cambiando l'asse in 1 , si effettua l'inserzione sulle colonne: >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Non specificando alcun asse, infine, si inserisce l'elemento specificato nella matrice vettorizzata: >>> np . insert ( mat , 9 , 10 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) La funzione append \u00b6 La funzione append(arr, values, axis=None) permette di inserire in coda ad un array i valori specificati. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; values : i valori da inserire in coda all'array; axis : l'asse su cui vogliamo operare. Al solito, non specificando l'asse effettuiamo la concatenazione sulla matrice vettorizzata: >>> np . append ( mat , [[ 10 , 11 , 12 ]]) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ]) Se specifichiamo il valore 0 sul parametro axis , effettuiamo la concatenazione per righe: >>> np . append ( mat , [[ 10 , 11 , 12 ]], axis = 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Se specifichiamo il valore 1 sul parametro axis , invece, effettuiamo la concatenazione per colonne: >>> np . append ( mat , [[ 10 ], [ 11 ], [ 12 ]], axis = 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Attenzione Nell'ultima istruzione, abbiamo usato un vettore colonna , mentre nella penultima un vettore riga . Dimensioni e forma di un array \u00b6 Esistono diverse propriet\u00e0 di un array che ne descrivono dimensioni e forma. Tornando alla nostra matrice mat , possiamo conoscere il numero di assi mediante l'attributo ndarray.ndim : >>> mat . ndim 2 Il numero di elementi \u00e8 invece definito dall'attributo ndarray.size : >>> mat . size 9 L'attributo ndarray.shape restituisce invece una tupla di interi che indica il numero di elementi per ciascuno degli assi dell'array: >>> mat . shape ( 3 , 3 ) Modificare le dimensioni di un array \u00b6 Possiamo modificare le dimensioni di un array mediante la funzione reshape(arr, new_shape) . I parametri passati alla funzione sono: arr : l'array di cui modificare le dimensioni; new_shape : le nuove dimensioni dell'array. Se volessimo modificare le dimensioni di una matrice da \\(4 \\times 4\\) a \\(2 \\times 8\\) , potremmo usare la funzione reshape come segue: >>> mat = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ], [ 13 , 14 , 15 , 16 ]]) >>> np . reshape ( mat , ( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Suggerimento Una forma alternativa \u00e8 la seguente: >>> mat . reshape (( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Ci\u00f2 significa che la funzione reshape \u00e8 sia disponibile nella libreria NumPy, sia come metodo sugli oggetti di classe ndarray . Attenzione Le nuove dimensioni dell'array devono essere coerenti con quelle dell'array di partenza! Flattening (o vettorizzazione) \u00b6 Abbiamo gi\u00e0 visto in precedenza la vettorizzazione di un array, effettuata in automatico in alcune situazioni (come ad esempio la chiamata di delete o insert senza specificare il parametro axis ). Tuttavia, possiamo usare la funzione flatten per effettuare manualmente questa operazione: >>> mat . flatten () array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Conclusioni \u00b6 In questa lezione, abbiamo visto alcuni fondamentali modi di manipolare un array che NumPy ci mette a disposizione. Nella prossima, parleremo pi\u00f9 in dettaglio delle operazioni algebriche.","title":"07.3 - Aritmetica in NumPy"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#operare-sugli-array","text":"NumPy offre numerose modalit\u00e0 per operare sugli array e manipolarli. Vediamone alcune.","title":"Operare sugli array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#operazioni-algebriche-di-base","text":"Possiamo usare due array per effettuare diversi tipi di operazioni algebriche di base. Ad esempio, per sommare due array: >>> a = np . array ([ 1 , 2 ]) >>> b = np . array ([ 3 , 4 ]) >>> a + b array ([ 4 , 6 ]) Possiamo ovviamente anche fare le altre operazioni fondamentali: >>> a - b array ([ - 2 , - 2 ]) >>> a * b array ([ 3 , 8 ]) >>> a / b array ([ 0.33333333 , 0.5 ]) >>> b / a array ([ 3. , 2. ]) Moltiplicazione e divisione Per comprendere appieno il comportamento degli operatori * e /, dovremo parlare del broadcasting. Lo faremo in una delle prossime lezioni.","title":"Operazioni algebriche di base"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#la-funzione-sum","text":"La funzione sum(axis=None) ci permette di sommare tutti gli elementi di un array lungo l'asse specificato. Ad esempio, per sommare tutti gli elementi di un vettore: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a . sum () 10 In caso di array multidimensionale, dovremo specificare, come gi\u00e0 detto, l'asse. Ad esempio, per sommare gli elementi per colonna, dovremo passare il parametro 0 : >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b . sum ( axis = 0 ) array ([ 4 , 6 ]) Per sommare gli elementi per riga, invece, dovremo passare il parametro 1 : >>> b . sum ( axis = 1 ) array ([ 3 , 7 ])","title":"La funzione sum"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#la-funzione-dot","text":"La funzione dot() ci permette di effettuare l'operazione di moltiplicazione matriciale standard: >>> a = np . array ([[ 1 , 2 ]]) >>> b = np . array ([[ 3 ], [ 4 ]]) >>> a . dot ( b ) array ([ 11 ]) >>> b . dot ( a ) array ([[ 3 , 6 ], [ 4 , 8 ]])","title":"La funzione dot()"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#ordinamento-degli-elementi-di-un-array","text":"Ordinare gli elementi di un array \u00e8 possibile usando la funzione sort() . Ad esempio: >>> arr = np . array ([ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ]) >>> np . sort ( arr ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) L'ordine avviene, di default, in maniera ascendente . In caso di array n-dimensionale, possiamo anche specificare l'asse lungo il quale avviene l'ordinamento, specificando il parametro axis. Ad esempio: >>> mat = np . array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) >>> mat array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) Per ordinare lungo le colonne: >>> np . sort ( mat , axis = 0 ) array ([[ 2 , 2 , 1 ], [ 4 , 3 , 1 ], [ 7 , 5 , 6 ]]) Mentre per ordinare lungo le righe: >>> np . sort ( mat , axis = 1 ) array ([[ 1 , 2 , 3 ], [ 2 , 4 , 6 ], [ 1 , 5 , 7 ]]) Nota Esistono anche altre funzioni per l'ordinamento di un array, che per\u00f2 non tratteremo in questo corso.","title":"Ordinamento degli elementi di un array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#concatenazione-di-piu-array","text":"Possiamo concatenare due array usando la funzione concatenate() : >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> b = np . array ([ 5 , 6 , 7 , 8 ]) >>> np . concatenate (( a , b )) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) Si pu\u00f2 anche in questo caso usare il parametro axis per specificare l'asse lungo quale concatenare due diversi array: >>> x = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> y = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 1 ) array ([[ 1 , 2 , 5 , 6 ], [ 3 , 4 , 7 , 8 ]]) Ovviamente, le dimensioni degli array devono essere coerenti affinch\u00e9 vengano concatenati. Ad esempio, con questo array: >>> z = np . array ([[ 9 , 10 ]]) la concatenazione per righe \u00e8 ammissibile: >>> np . concatenate (( x , z ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 9 , 10 ]]) mentre la concatenazione per colonne non \u00e8 possibile: >>> np . concatenate (( x , z ), axis = 1 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<__array_function__ internals>\" , line 5 , in concatenate ValueError : all the input array dimensions for the concatenation axis must match exactly , but along dimension 0 , the array at index 0 has size 2 and the array at index 1 has size 1","title":"Concatenazione di pi\u00f9 array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#rimozione-ed-inserimento-di-elementi-in-un-array","text":"","title":"Rimozione ed inserimento di elementi in un array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#la-funzione-delete","text":"La funzione delete(arr, obj, axis=None) ci permette di rimuovere uno o pi\u00f9 elementi di un array specificandone gli indici. La funzione accetta i seguenti parametri: arr : l'array sul quale vogliamo effettuare l'operazione di rimozione; obj : gli indici degli elementi da rimuovere; axis : l'asse su cui vogliamo operare. Ad esempio, immaginiamo di voler rimuovere il primo elemento di un vettore: >>> arr = np . array ([ 1 , 2 , 3 , 4 ]) >>> np . delete ( arr , 0 ) array ([ 2 , 3 , 4 ]) >>> arr La funzione pu\u00f2 essere anche applicata su pi\u00f9 indici usando una sequenza: >>> np . delete ( arr , range ( 2 )) array ([ 3 , 4 ]) Possiamo anche usare lo slicing: >>> idx = range ( 4 ) >>> np . delete ( arr , idx [ 0 : 2 ]) array ([ 3 , 4 ]) Suggerimento La precedente notazione pu\u00f2 essere rimpiazzata dalla funzione slice(start, stop, step) , che crea un oggetto di classe slice sugli indici che vanno da start a stop con passo step . Questo pu\u00f2 essere usato per scopi analoghi ai precedenti; ad esempio: >>> np . delete ( a , slice ( 0 , 2 , 1 )) array ([ 3 , 4 ])","title":"La funzione delete"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#array-multidimensionali","text":"La funzione pu\u00f2 essere usata anche su array multidimensionali. In questo caso, \u00e8 opportuno specificare l'asse su cui operare. Ad esempio, se vogliamo rimuovere la prima riga dal seguente array, dobbiamo dare il valore 0 al parametro axis : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) >>> np . delete ( mat , 0 , 0 ) array ([[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) Invece, se vogliamo rimuovere la prima colonna, dobbiamo passare il valore 1 : >>> np . delete ( mat , 0 , 1 ) array ([[ 2 , 3 ], [ 5 , 6 ], [ 8 , 9 ]]) Se non specificassimo alcun valore per il parametro axis , otterremmo questo risultato: >>> np . delete ( mat , 0 ) array ([ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Cosa \u00e8 accaduto? In pratica, \u00e8 stato rimosso il primo elemento dell'array vettorizzato ( flattened ).","title":"Array multidimensionali"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#rimozione-di-elementi-mediante-maschere-booleane","text":"Spesso \u00e8 preferibile usare, al posto della notazione precedente, una maschera booleana: >>> mask = [ False , False , True , True ] >>> arr [ mask ] array ([ 3 , 4 ])","title":"Rimozione di elementi mediante maschere booleane"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#la-funzione-insert","text":"La funzione insert(arr, obj, values, axis=None) permette di inserire un elemento all'interno di un array. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; obj : gli indici su cui inserire i nuovi valori; values : i valori da inserire agli indici specificati da obj ; axis : l'asse su cui vogliamo operare. Ad esempio, per inserire una nuova riga nella matrice precedente, dovremo specificare l'indice di riga ( 3 ), gli elementi della riga da inserire ( [10, 11, 12] ) e l'asse ( 0 ): >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Cambiando l'asse in 1 , si effettua l'inserzione sulle colonne: >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Non specificando alcun asse, infine, si inserisce l'elemento specificato nella matrice vettorizzata: >>> np . insert ( mat , 9 , 10 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ])","title":"La funzione insert"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#la-funzione-append","text":"La funzione append(arr, values, axis=None) permette di inserire in coda ad un array i valori specificati. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; values : i valori da inserire in coda all'array; axis : l'asse su cui vogliamo operare. Al solito, non specificando l'asse effettuiamo la concatenazione sulla matrice vettorizzata: >>> np . append ( mat , [[ 10 , 11 , 12 ]]) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ]) Se specifichiamo il valore 0 sul parametro axis , effettuiamo la concatenazione per righe: >>> np . append ( mat , [[ 10 , 11 , 12 ]], axis = 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Se specifichiamo il valore 1 sul parametro axis , invece, effettuiamo la concatenazione per colonne: >>> np . append ( mat , [[ 10 ], [ 11 ], [ 12 ]], axis = 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Attenzione Nell'ultima istruzione, abbiamo usato un vettore colonna , mentre nella penultima un vettore riga .","title":"La funzione append"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#dimensioni-e-forma-di-un-array","text":"Esistono diverse propriet\u00e0 di un array che ne descrivono dimensioni e forma. Tornando alla nostra matrice mat , possiamo conoscere il numero di assi mediante l'attributo ndarray.ndim : >>> mat . ndim 2 Il numero di elementi \u00e8 invece definito dall'attributo ndarray.size : >>> mat . size 9 L'attributo ndarray.shape restituisce invece una tupla di interi che indica il numero di elementi per ciascuno degli assi dell'array: >>> mat . shape ( 3 , 3 )","title":"Dimensioni e forma di un array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#modificare-le-dimensioni-di-un-array","text":"Possiamo modificare le dimensioni di un array mediante la funzione reshape(arr, new_shape) . I parametri passati alla funzione sono: arr : l'array di cui modificare le dimensioni; new_shape : le nuove dimensioni dell'array. Se volessimo modificare le dimensioni di una matrice da \\(4 \\times 4\\) a \\(2 \\times 8\\) , potremmo usare la funzione reshape come segue: >>> mat = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ], [ 13 , 14 , 15 , 16 ]]) >>> np . reshape ( mat , ( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Suggerimento Una forma alternativa \u00e8 la seguente: >>> mat . reshape (( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Ci\u00f2 significa che la funzione reshape \u00e8 sia disponibile nella libreria NumPy, sia come metodo sugli oggetti di classe ndarray . Attenzione Le nuove dimensioni dell'array devono essere coerenti con quelle dell'array di partenza!","title":"Modificare le dimensioni di un array"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#flattening-o-vettorizzazione","text":"Abbiamo gi\u00e0 visto in precedenza la vettorizzazione di un array, effettuata in automatico in alcune situazioni (come ad esempio la chiamata di delete o insert senza specificare il parametro axis ). Tuttavia, possiamo usare la funzione flatten per effettuare manualmente questa operazione: >>> mat . flatten () array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ])","title":"Flattening (o vettorizzazione)"},{"location":"material/02_libs/07_numpy/03_arithmetics/lecture/#conclusioni","text":"In questa lezione, abbiamo visto alcuni fondamentali modi di manipolare un array che NumPy ci mette a disposizione. Nella prossima, parleremo pi\u00f9 in dettaglio delle operazioni algebriche.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/04_algebra/exercises/","text":"Risoluzione degli esercizi \u00b6 Scriviamo la funzione calcola_determinante(mat) che permetta di calcolare il determinante di una matrice \\(2 \\times 2\\) . def calcola_determinante ( mat ): if len ( mat . shape ) == 2 and mat . shape [ 0 ] == mat . shape [ 1 ] and mat . shape [ 0 ] == 2 : return mat [ 0 ][ 0 ] * mat [ 1 ][ 1 ] - mat [ 0 ][ 1 ] * mat [ 1 ][ 0 ] raise ValueError ( 'La matrice non ha le dimensioni attese.' ) Scriviamo la funzione inverti_se_inveribile(mat) che, data una matrice bidimensionale, restituisca l'inversa soltanto se mat \u00e8 bidimensionale e quadrata, ed il determinante \u00e8 diverso da zero. Usare esclusivamente le istruzioni if . def inverti_se_invertibile ( mat ): if len ( mat . shape ) == 2 \\ and mat . shape [ 0 ] == mat . shape [ 1 ] \\ and linalg . det ( mat ) != 0 : return linalg . inv ( mat ) raise ValueError ( 'La matrice passata non \u00e8 invertibile.' )","title":"E7.4 - Algebra in NumPy"},{"location":"material/02_libs/07_numpy/04_algebra/exercises/#risoluzione-degli-esercizi","text":"Scriviamo la funzione calcola_determinante(mat) che permetta di calcolare il determinante di una matrice \\(2 \\times 2\\) . def calcola_determinante ( mat ): if len ( mat . shape ) == 2 and mat . shape [ 0 ] == mat . shape [ 1 ] and mat . shape [ 0 ] == 2 : return mat [ 0 ][ 0 ] * mat [ 1 ][ 1 ] - mat [ 0 ][ 1 ] * mat [ 1 ][ 0 ] raise ValueError ( 'La matrice non ha le dimensioni attese.' ) Scriviamo la funzione inverti_se_inveribile(mat) che, data una matrice bidimensionale, restituisca l'inversa soltanto se mat \u00e8 bidimensionale e quadrata, ed il determinante \u00e8 diverso da zero. Usare esclusivamente le istruzioni if . def inverti_se_invertibile ( mat ): if len ( mat . shape ) == 2 \\ and mat . shape [ 0 ] == mat . shape [ 1 ] \\ and linalg . det ( mat ) != 0 : return linalg . inv ( mat ) raise ValueError ( 'La matrice passata non \u00e8 invertibile.' )","title":"Risoluzione degli esercizi"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/","text":"Operazioni matriciali \u00b6 La maggior parte delle operazioni matriciali possono essere svolte usando il package linalg di NumPy. Tutti gli esempi che faremo nel prosieguo, quindi, prevederanno l'importazione di questo package; facciamolo scrivendo l'opportuna istruzione import . from numpy import linalg Trasposta di una matrice \u00b6 La prima operazione che vedremo non richiede l'uso del modulo linalg , ed \u00e8 quella che ci permette di effettuare la trasposta di una matrice. Per farlo, usiamo la funzione transpose . >>> np . transpose ( x ) Matrice inversa \u00b6 Possiamo calcolare l'inversa di una matrice usando la funzione inv(mat) del package linalg , dove mat \u00e8 la matrice da invertire. Ad esempio: >>> mat = np . array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 4 ]]) >>> mat_inv = linalg . inv ( mat ) >>> mat_inv array ([[ 0.2 , 0. , 0. ], [ 0. , 0.5 , 0. ], [ 0. , 0. , 0.25 ]]) Ovviamente, la matrice mat deve essere invertibile. Nel caso passassimo una matrice rettangolare, infatti,verrebbe lanciato un LinAlgError : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Last 2 dimensions of the array must be square Lo stesso accade per una matrice singolare: >>> mat = np . array ([[ 1 , 1 , 1 ],[ 2 , 2 , 2 ],[ 0 , 0 , 1 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Singular matrix Curiosit\u00e0 La matrice inversa che viene calcolata dalla funzione inv() \u00e8 quella che, moltiplicata per la matrice iniziale, restituisce la matrice identit\u00e0. Verifichiamolo: >>> mat . dot ( mat_inv ) array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Prodotti vettoriali e matriciali \u00b6 La funzione dot() \u00b6 Abbiamo gi\u00e0 visto nella lezione precedente un esempio di uso della funzione dot(a, b) , utile a calcolare il prodotto matriciale tra gli array a ed b . Ovviamente, si applicano tutte le regole valevoli per il calcolo del prodotto matriciale (ovvero quello relativo alla moltiplicazione righe per colonne); riassumiamole nella seguente tabella sulla base delle dimensionalit\u00e0 di a ed b . Dimensionalit\u00e0 a Dimensionalit\u00e0 b Risultato Note Monodimensionale (vettore) Monodimensionale (vettore) Prodotto scalare / Bidimensionale (matrice) Bidimensionale (matrice) Prodotto matriciale Preferire la funzione matmul Scalare N-dimensionale Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * N-dimensionale Scalare Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * Nel caso entrambi gli array siano N-dimensionali, si applicano altre regole che non approfondiremo in questa sede (\u00e8 possibile recuperarle a questo indirizzo ). Prodotto interno \u00b6 Possiamo usare la funzione inner(a, b) per calcolare il prodotto interno (o scalare ) tra i vettori a e b : >>> np . inner ( a , b ) 11 Prodotto esterno \u00b6 Possiamo usare la funzione outer(a, b) per calcolare il prodotto esterno tra due vettori. In particolare, dati due vettori \\(a = [a_1, a_2, \\ldots, a_n]\\) e \\(b = [b_1, b_2, \\ldots, b_n]\\) , il prodotto esterno \u00e8 definito come la matrice \\(P\\) tale che: P = [[ a_1 * b_1 ... a_1 * b_n ], ... , [ a_n * b_1 ... a_n * b_n ]] Ad esempio: >>> np . outer ( a , b ) array ([[ 3 , 4 ], [ 6 , 8 ]]) La funzione matmul \u00b6 Quando abbiamo parlato della funzione dot(a, b) abbiamo visto come sia possibile usarla per effettuare il prodotto matriciale tra le matrici mat_1 e mat_2 . Tuttavia, esiste un'altra possibilit\u00e0, che \u00e8 anche quella consigliata , ovvero usare la funzione matmul(a, b) : >>> a = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . matmul ( a , b ) array ([[ 19 , 22 ], [ 43 , 50 ]]) La funzione matmul() ha una differenza fondamentale rispetto alla funzione dot() , in quanto non accetta scalari come parametro (anche se \u00e8 possibile passare vettori ed array N-dimensionali). Esiste in realt\u00e0 un'altra differenza importante, che riguarda le operazioni N-dimensionali, ma che non tratteremo in questa sede. Potenza di matrice \u00b6 La funzione matrix_power(a, n) del package linalg permette di elevare a potenza n della matrice a . Ad esempio: >>> matrix_power ( a , 5 ) array ([[ 1069 , 1558 ], [ 2337 , 3406 ]]) Decomposizione di matrice \u00b6 Decomposizione QR \u00b6 La decomposizione (o fattorizzazione ) \\(QR\\) di una matrice invertibile \\(A\\) si definisce come il prodotto di una matrice ortogonale \\(Q\\) \u00e8 una matrice ortogonale per una matrice triangolare superiore \\(R\\) : \\[ A = QR \\] Matrice ortogonale Una matrice ortogonale \u00e8 una matrice quadrata la cui inversa coincide con la trasposta. NumPy ci offre un metodo per effettuare la decomposizione QR in un'unica istruzione mediante la funzione qr(a) del package linalg . Ad esempio: >>> ( q , r ) = qr ( mat ) >>> q array ([[ - 0.74535599 , - 0.28151707 , - 0.60431166 ], [ - 0.2981424 , - 0.67001063 , 0.67985062 ], [ - 0.59628479 , 0.68690166 , 0.41546427 ]]) >>> r array ([[ - 6.70820393 , - 1.19256959 , - 14.16176386 ], [ 0. , - 3.94686936 , 5.03915561 ], [ 0. , 0. , 0.22661687 ]]) Notiamo che il valore restituito dalla funzione \u00e8 una tupla il cui primo elemento \u00e8 la matrice \\(Q\\) , mentre il secondo \u00e8 \\(R\\) . Decomposizione ai valori singolari \u00b6 La decomposizione ai valori singolari , detta anche SVD (dall'inglese Singular Value Decomposition ), \u00e8 un tipo di fattorizzazione basato sul concetto di autovalore ed autovettore . In particolare, data una matrice \\(A\\) di dimensioni \\(m \\times n\\) , questa \u00e8 decomponibile come segue: \\[ A = U \\Sigma V^* \\] dove \\(U\\) \u00e8 una matrice unitaria di dimensioni \\(m \\times m\\) , \\(\\Sigma\\) \u00e8 una matrice diagonale rettangolare di dimensioni \\(m \\times n\\) , e \\(V^*\\) \u00e8 la trasposta coinugata di una matrice unitaria di dimensioni \\(n \\times n\\) . Trasposta coniugata La trasposta coniugata di una matrice \u00e8 ottenuta effettuandone la trasposizione e scambiando ogni elemento con il suo complesso coniugato. Anche in questo caso, la SVD \u00e8 estremamente complessa da implementare a partire dalle sue funzioni basilari. NumPy ci viene quindi in aiuto con la funzione svd(mat) del package linalg . Ad esempio: >>> ( u , s , v ) = linalg . svd ( mat ) >>> u array ([[ - 0.62732922 , - 0.48645199 , - 0.60813034 ], [ - 0.10481126 , - 0.72105629 , 0.68490322 ], [ - 0.77166874 , 0.49339871 , 0.40135404 ]]) >>> s array ([ 16.33118238 , 4.61369058 , 0.07963155 ]) >>> v array ([[ - 0.39390556 , - 0.00157703 , - 0.91914956 ], [ - 0.41198638 , - 0.89361655 , 0.17809178 ], [ - 0.82164812 , 0.44882844 , 0.35135082 ]]) Autovalori ed autovettori \u00b6 I concetti di autovalore ed autovettore hanno ampia applicazione in numerose discipline scientifiche, arrivando a definire la base su cui vengono elaborati alcuni degli approcci pi\u00f9 avanzati al machine learning. Formalmente, data una matrice quadrata \\(A\\) di ordine \\(n\\) con valori in uno spazio \\(\\mathbb{K}\\) , uno scalare \\(\\lambda_0 \\in \\mathbb{K}\\) \u00e8 definito autovalore di \\(A\\) se esiste un vettore colonna non nullo \\(v_0 \\in K^n\\) tale che: \\[ Av = \\lambda_0v \\] Dal punto di vista \"fisico\", un autovettore non cambia la sua direzione a seguito dell'applicazione di una trasformazione lineare. Possiamo, ad esempio, ruotarlo, ma la sua direzione non verr\u00e0 modificata; l'unico effetto che potremo notare sar\u00e0 una modifica nel modulo o nel verso, a seconda del suo autovalore. Per calcolare gli autovalori e gli autovettori di una matrice, NumPy ci mette a disposizione la funzione eig(a) , sempre appartenente al package linalg , che restituisce gli autovalori e gli autovettori destri di una matrice quadrata: >>> ( w , v ) = linalg . eig ( mat ) >>> w array ([ 15.23391422 , 0.08412242 , 4.68196336 ]) >>> v array ([[ - 0.66930729 , - 0.82394712 , - 0.68445786 ], [ - 0.16856631 , 0.44469209 , - 0.70619627 ], [ - 0.72361119 , 0.35122656 , 0.18111947 ]]) Norma \u00b6 La funzione linalg.norm(a) ci permette di calcolare la norma di una matrice. Opzionalmente, possiamo specificare tre parametri, ovvero: ord , che rappresenta l'ordine della norma da calcolare (di default, viene calcolata la norma di Frobenius); axis , che indica l'asse (o gli assi, in caso di array multidimensionale) su cui operare; keepdims , usata per restituire, opzionalmente, l'asse su cui viene calcolata la norma. Per calcolare la norma di Frobenius della matrice mat possiamo usare questa sintassi: >>> linalg . norm ( mat ) 16.97056274847714 Determinante, rango e traccia \u00b6 Possiamo calcolare rapidamente determinante, rango e traccia di una matrice mediante le funzioni det(a) , matrix_rank(a) e trace(a) , quest'ultima non appartenente al package linalg . Ad esempio: >>> linalg . det ( mat ) 6.000000000000001 >>> linalg . matrix_rank ( mat ) 3 >>> np . trace ( mat ) 20 Nota La funzione trace pu\u00f2 anche essere usata per calcolare la sommatoria delle sovra/sotto diagonali specificando il parametro offset . Ad esempio: >>> mat array ([[ 5 , 2 , 9 ], [ 2 , 3 , 1 ], [ 4 , - 2 , 12 ]]) >>> np . trace ( mat , offset = 1 ) 3 >>> np . trace ( mat , offset =- 1 ) 0 Risoluzione di sistemi \u00b6 Chiudiamo questa (necessariamente breve!) carrellata sulle operazioni di algebra lineare con la funzione solve(a, b) , che permette di risolvere un sistema di equazioni lineari nel quale la matrice a \u00e8 la matrice dei coefficienti, mentre il vettore b \u00e8 il vettore dei termini noti. Ad esempio: >>> b = np . array ([ 3 , 2 , 3 ]) >>> linalg . solve ( mat , b ) array ([ - 7.5 , 4.5 , 3.5 ]) Nota Ovviamente, la matrice a deve essere quadrata, mentre il vettore b deve avere esattamente n elementi, con n ordine di a ! Conclusioni \u00b6 In questa lezione, abbiamo visto come NumPy ci offra dei metodi per effettuare le operazioni base di algebra lineare in poche e semplici operazioni. Nella successiva, vedremo i metodi che ci vengono dati per trattare i polinomi reali.","title":"07.4 - Algebra in NumPy"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#operazioni-matriciali","text":"La maggior parte delle operazioni matriciali possono essere svolte usando il package linalg di NumPy. Tutti gli esempi che faremo nel prosieguo, quindi, prevederanno l'importazione di questo package; facciamolo scrivendo l'opportuna istruzione import . from numpy import linalg","title":"Operazioni matriciali"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#trasposta-di-una-matrice","text":"La prima operazione che vedremo non richiede l'uso del modulo linalg , ed \u00e8 quella che ci permette di effettuare la trasposta di una matrice. Per farlo, usiamo la funzione transpose . >>> np . transpose ( x )","title":"Trasposta di una matrice"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#matrice-inversa","text":"Possiamo calcolare l'inversa di una matrice usando la funzione inv(mat) del package linalg , dove mat \u00e8 la matrice da invertire. Ad esempio: >>> mat = np . array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 4 ]]) >>> mat_inv = linalg . inv ( mat ) >>> mat_inv array ([[ 0.2 , 0. , 0. ], [ 0. , 0.5 , 0. ], [ 0. , 0. , 0.25 ]]) Ovviamente, la matrice mat deve essere invertibile. Nel caso passassimo una matrice rettangolare, infatti,verrebbe lanciato un LinAlgError : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Last 2 dimensions of the array must be square Lo stesso accade per una matrice singolare: >>> mat = np . array ([[ 1 , 1 , 1 ],[ 2 , 2 , 2 ],[ 0 , 0 , 1 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Singular matrix Curiosit\u00e0 La matrice inversa che viene calcolata dalla funzione inv() \u00e8 quella che, moltiplicata per la matrice iniziale, restituisce la matrice identit\u00e0. Verifichiamolo: >>> mat . dot ( mat_inv ) array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]])","title":"Matrice inversa"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#prodotti-vettoriali-e-matriciali","text":"","title":"Prodotti vettoriali e matriciali"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#la-funzione-dot","text":"Abbiamo gi\u00e0 visto nella lezione precedente un esempio di uso della funzione dot(a, b) , utile a calcolare il prodotto matriciale tra gli array a ed b . Ovviamente, si applicano tutte le regole valevoli per il calcolo del prodotto matriciale (ovvero quello relativo alla moltiplicazione righe per colonne); riassumiamole nella seguente tabella sulla base delle dimensionalit\u00e0 di a ed b . Dimensionalit\u00e0 a Dimensionalit\u00e0 b Risultato Note Monodimensionale (vettore) Monodimensionale (vettore) Prodotto scalare / Bidimensionale (matrice) Bidimensionale (matrice) Prodotto matriciale Preferire la funzione matmul Scalare N-dimensionale Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * N-dimensionale Scalare Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * Nel caso entrambi gli array siano N-dimensionali, si applicano altre regole che non approfondiremo in questa sede (\u00e8 possibile recuperarle a questo indirizzo ).","title":"La funzione dot()"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#prodotto-interno","text":"Possiamo usare la funzione inner(a, b) per calcolare il prodotto interno (o scalare ) tra i vettori a e b : >>> np . inner ( a , b ) 11","title":"Prodotto interno"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#prodotto-esterno","text":"Possiamo usare la funzione outer(a, b) per calcolare il prodotto esterno tra due vettori. In particolare, dati due vettori \\(a = [a_1, a_2, \\ldots, a_n]\\) e \\(b = [b_1, b_2, \\ldots, b_n]\\) , il prodotto esterno \u00e8 definito come la matrice \\(P\\) tale che: P = [[ a_1 * b_1 ... a_1 * b_n ], ... , [ a_n * b_1 ... a_n * b_n ]] Ad esempio: >>> np . outer ( a , b ) array ([[ 3 , 4 ], [ 6 , 8 ]])","title":"Prodotto esterno"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#la-funzione-matmul","text":"Quando abbiamo parlato della funzione dot(a, b) abbiamo visto come sia possibile usarla per effettuare il prodotto matriciale tra le matrici mat_1 e mat_2 . Tuttavia, esiste un'altra possibilit\u00e0, che \u00e8 anche quella consigliata , ovvero usare la funzione matmul(a, b) : >>> a = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . matmul ( a , b ) array ([[ 19 , 22 ], [ 43 , 50 ]]) La funzione matmul() ha una differenza fondamentale rispetto alla funzione dot() , in quanto non accetta scalari come parametro (anche se \u00e8 possibile passare vettori ed array N-dimensionali). Esiste in realt\u00e0 un'altra differenza importante, che riguarda le operazioni N-dimensionali, ma che non tratteremo in questa sede.","title":"La funzione matmul"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#potenza-di-matrice","text":"La funzione matrix_power(a, n) del package linalg permette di elevare a potenza n della matrice a . Ad esempio: >>> matrix_power ( a , 5 ) array ([[ 1069 , 1558 ], [ 2337 , 3406 ]])","title":"Potenza di matrice"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#decomposizione-di-matrice","text":"","title":"Decomposizione di matrice"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#decomposizione-qr","text":"La decomposizione (o fattorizzazione ) \\(QR\\) di una matrice invertibile \\(A\\) si definisce come il prodotto di una matrice ortogonale \\(Q\\) \u00e8 una matrice ortogonale per una matrice triangolare superiore \\(R\\) : \\[ A = QR \\] Matrice ortogonale Una matrice ortogonale \u00e8 una matrice quadrata la cui inversa coincide con la trasposta. NumPy ci offre un metodo per effettuare la decomposizione QR in un'unica istruzione mediante la funzione qr(a) del package linalg . Ad esempio: >>> ( q , r ) = qr ( mat ) >>> q array ([[ - 0.74535599 , - 0.28151707 , - 0.60431166 ], [ - 0.2981424 , - 0.67001063 , 0.67985062 ], [ - 0.59628479 , 0.68690166 , 0.41546427 ]]) >>> r array ([[ - 6.70820393 , - 1.19256959 , - 14.16176386 ], [ 0. , - 3.94686936 , 5.03915561 ], [ 0. , 0. , 0.22661687 ]]) Notiamo che il valore restituito dalla funzione \u00e8 una tupla il cui primo elemento \u00e8 la matrice \\(Q\\) , mentre il secondo \u00e8 \\(R\\) .","title":"Decomposizione QR"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#decomposizione-ai-valori-singolari","text":"La decomposizione ai valori singolari , detta anche SVD (dall'inglese Singular Value Decomposition ), \u00e8 un tipo di fattorizzazione basato sul concetto di autovalore ed autovettore . In particolare, data una matrice \\(A\\) di dimensioni \\(m \\times n\\) , questa \u00e8 decomponibile come segue: \\[ A = U \\Sigma V^* \\] dove \\(U\\) \u00e8 una matrice unitaria di dimensioni \\(m \\times m\\) , \\(\\Sigma\\) \u00e8 una matrice diagonale rettangolare di dimensioni \\(m \\times n\\) , e \\(V^*\\) \u00e8 la trasposta coinugata di una matrice unitaria di dimensioni \\(n \\times n\\) . Trasposta coniugata La trasposta coniugata di una matrice \u00e8 ottenuta effettuandone la trasposizione e scambiando ogni elemento con il suo complesso coniugato. Anche in questo caso, la SVD \u00e8 estremamente complessa da implementare a partire dalle sue funzioni basilari. NumPy ci viene quindi in aiuto con la funzione svd(mat) del package linalg . Ad esempio: >>> ( u , s , v ) = linalg . svd ( mat ) >>> u array ([[ - 0.62732922 , - 0.48645199 , - 0.60813034 ], [ - 0.10481126 , - 0.72105629 , 0.68490322 ], [ - 0.77166874 , 0.49339871 , 0.40135404 ]]) >>> s array ([ 16.33118238 , 4.61369058 , 0.07963155 ]) >>> v array ([[ - 0.39390556 , - 0.00157703 , - 0.91914956 ], [ - 0.41198638 , - 0.89361655 , 0.17809178 ], [ - 0.82164812 , 0.44882844 , 0.35135082 ]])","title":"Decomposizione ai valori singolari"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#autovalori-ed-autovettori","text":"I concetti di autovalore ed autovettore hanno ampia applicazione in numerose discipline scientifiche, arrivando a definire la base su cui vengono elaborati alcuni degli approcci pi\u00f9 avanzati al machine learning. Formalmente, data una matrice quadrata \\(A\\) di ordine \\(n\\) con valori in uno spazio \\(\\mathbb{K}\\) , uno scalare \\(\\lambda_0 \\in \\mathbb{K}\\) \u00e8 definito autovalore di \\(A\\) se esiste un vettore colonna non nullo \\(v_0 \\in K^n\\) tale che: \\[ Av = \\lambda_0v \\] Dal punto di vista \"fisico\", un autovettore non cambia la sua direzione a seguito dell'applicazione di una trasformazione lineare. Possiamo, ad esempio, ruotarlo, ma la sua direzione non verr\u00e0 modificata; l'unico effetto che potremo notare sar\u00e0 una modifica nel modulo o nel verso, a seconda del suo autovalore. Per calcolare gli autovalori e gli autovettori di una matrice, NumPy ci mette a disposizione la funzione eig(a) , sempre appartenente al package linalg , che restituisce gli autovalori e gli autovettori destri di una matrice quadrata: >>> ( w , v ) = linalg . eig ( mat ) >>> w array ([ 15.23391422 , 0.08412242 , 4.68196336 ]) >>> v array ([[ - 0.66930729 , - 0.82394712 , - 0.68445786 ], [ - 0.16856631 , 0.44469209 , - 0.70619627 ], [ - 0.72361119 , 0.35122656 , 0.18111947 ]])","title":"Autovalori ed autovettori"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#norma","text":"La funzione linalg.norm(a) ci permette di calcolare la norma di una matrice. Opzionalmente, possiamo specificare tre parametri, ovvero: ord , che rappresenta l'ordine della norma da calcolare (di default, viene calcolata la norma di Frobenius); axis , che indica l'asse (o gli assi, in caso di array multidimensionale) su cui operare; keepdims , usata per restituire, opzionalmente, l'asse su cui viene calcolata la norma. Per calcolare la norma di Frobenius della matrice mat possiamo usare questa sintassi: >>> linalg . norm ( mat ) 16.97056274847714","title":"Norma"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#determinante-rango-e-traccia","text":"Possiamo calcolare rapidamente determinante, rango e traccia di una matrice mediante le funzioni det(a) , matrix_rank(a) e trace(a) , quest'ultima non appartenente al package linalg . Ad esempio: >>> linalg . det ( mat ) 6.000000000000001 >>> linalg . matrix_rank ( mat ) 3 >>> np . trace ( mat ) 20 Nota La funzione trace pu\u00f2 anche essere usata per calcolare la sommatoria delle sovra/sotto diagonali specificando il parametro offset . Ad esempio: >>> mat array ([[ 5 , 2 , 9 ], [ 2 , 3 , 1 ], [ 4 , - 2 , 12 ]]) >>> np . trace ( mat , offset = 1 ) 3 >>> np . trace ( mat , offset =- 1 ) 0","title":"Determinante, rango e traccia"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#risoluzione-di-sistemi","text":"Chiudiamo questa (necessariamente breve!) carrellata sulle operazioni di algebra lineare con la funzione solve(a, b) , che permette di risolvere un sistema di equazioni lineari nel quale la matrice a \u00e8 la matrice dei coefficienti, mentre il vettore b \u00e8 il vettore dei termini noti. Ad esempio: >>> b = np . array ([ 3 , 2 , 3 ]) >>> linalg . solve ( mat , b ) array ([ - 7.5 , 4.5 , 3.5 ]) Nota Ovviamente, la matrice a deve essere quadrata, mentre il vettore b deve avere esattamente n elementi, con n ordine di a !","title":"Risoluzione di sistemi"},{"location":"material/02_libs/07_numpy/04_algebra/lecture/#conclusioni","text":"In questa lezione, abbiamo visto come NumPy ci offra dei metodi per effettuare le operazioni base di algebra lineare in poche e semplici operazioni. Nella successiva, vedremo i metodi che ci vengono dati per trattare i polinomi reali.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/05_polynomials/exercises/","text":"Risoluzione degli esercizi \u00b6 Scriviamo la funzione somma_polinomi(pol_1, pol_2) che permetta di sommare due polinomi di grandezza arbitraria. def somma_polinomi ( pol_1 , pol_2 ): if len ( pol_1 ) < len ( pol_2 ): while len ( pol_1 ) < len ( pol_2 ): pol_1 . insert ( 0 , 0 ) elif len ( pol_2 ) < len ( pol_1 ): while len ( pol_2 ) < len ( pol_1 ): pol_2 . insert ( 0 , 0 ) return [( pol_1 [ i ] + pol_2 [ i ]) for i in range ( len ( pol_1 ))] somma_polinomi ([ 0 , 1 , 2 ], [ 2 , 2 , 1 ]) somma_polinomi ([ 1 , 2 ], [ 2 , 2 , 1 ]) somma_polinomi ([ 1 , 2 ], [ 2 , 2 , 2 , 1 ]) Scriviamo la funzione calcola_media(array, pesi) che restituisce il valor medio di un array; usiamo una lista. Il parametro pesi \u00e8 opzionale; nel caso sia lasciato il valore opzionale (lista vuota), la media sar\u00e0 aritmetica; in caso contrario, verifichiamo la coerenza delle dimensioni dei vettori e restituiamo la media pesata. def calcola_media ( array , pesi = []): if pesi == []: return sum ( array ) / len ( array ) else : if len ( pesi ) == len ( array ): return sum ([( pesi [ i ] * array [ i ]) for i in range ( len ( array ))]) raise ValueError ( 'La lunghezza dei pesi non corrisponde a quella degli array.' ) calcola_media ([ 5 , 4 , 5 ]) calcola_media ([ 5 , 4 , 5 ], [ 0 , 1 , 0 ]) calcola_media ([ 5 , 4 , 5 ], [ 0 , 1 ]) Scriviamo la funzione descrivi(array) che permette di descrivere un array in termini non parametrici, individuando mediana, deviazione standard e range interquartile (ovvero tra il 25-percentile ed il 75-percentile). def descrivi ( array ): return ( np . median ( array ), np . std ( array ), np . percentile ( array , 25 ), np . percentile ( array , 75 ) ) descrivi ( np . array ([ 3 , 5 , 3 , 2 , 1 , 8 ]))","title":"E7.5 - Polinomi in NumPy"},{"location":"material/02_libs/07_numpy/05_polynomials/exercises/#risoluzione-degli-esercizi","text":"Scriviamo la funzione somma_polinomi(pol_1, pol_2) che permetta di sommare due polinomi di grandezza arbitraria. def somma_polinomi ( pol_1 , pol_2 ): if len ( pol_1 ) < len ( pol_2 ): while len ( pol_1 ) < len ( pol_2 ): pol_1 . insert ( 0 , 0 ) elif len ( pol_2 ) < len ( pol_1 ): while len ( pol_2 ) < len ( pol_1 ): pol_2 . insert ( 0 , 0 ) return [( pol_1 [ i ] + pol_2 [ i ]) for i in range ( len ( pol_1 ))] somma_polinomi ([ 0 , 1 , 2 ], [ 2 , 2 , 1 ]) somma_polinomi ([ 1 , 2 ], [ 2 , 2 , 1 ]) somma_polinomi ([ 1 , 2 ], [ 2 , 2 , 2 , 1 ]) Scriviamo la funzione calcola_media(array, pesi) che restituisce il valor medio di un array; usiamo una lista. Il parametro pesi \u00e8 opzionale; nel caso sia lasciato il valore opzionale (lista vuota), la media sar\u00e0 aritmetica; in caso contrario, verifichiamo la coerenza delle dimensioni dei vettori e restituiamo la media pesata. def calcola_media ( array , pesi = []): if pesi == []: return sum ( array ) / len ( array ) else : if len ( pesi ) == len ( array ): return sum ([( pesi [ i ] * array [ i ]) for i in range ( len ( array ))]) raise ValueError ( 'La lunghezza dei pesi non corrisponde a quella degli array.' ) calcola_media ([ 5 , 4 , 5 ]) calcola_media ([ 5 , 4 , 5 ], [ 0 , 1 , 0 ]) calcola_media ([ 5 , 4 , 5 ], [ 0 , 1 ]) Scriviamo la funzione descrivi(array) che permette di descrivere un array in termini non parametrici, individuando mediana, deviazione standard e range interquartile (ovvero tra il 25-percentile ed il 75-percentile). def descrivi ( array ): return ( np . median ( array ), np . std ( array ), np . percentile ( array , 25 ), np . percentile ( array , 75 ) ) descrivi ( np . array ([ 3 , 5 , 3 , 2 , 1 , 8 ]))","title":"Risoluzione degli esercizi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/","text":"Il modulo polynomial \u00b6 Il modulo numpy.polynomial.polynomial ci offre numerose classi e funzionalit\u00e0 per il trattamento dei polinomi. Vediamo insieme quali sono le principali. Operazioni tra polinomi \u00b6 Immaginiamo di avere due diversi polinomi (cui non associeremo alcun significato fisico), ovvero: \\[ y = 2x + 1 \\\\ y = x^2 + 3x + 2 \\] Vediamo come usare dei metodi forniti dal modulo polynomial per effettuare delle operazioni su di loro. Addizione di polinomi \u00b6 Per effettuare l'addizione di due polinomi, possiamo usare il metodo polyadd(c1, c2) , che accetta come parametri due vettori c1 e c2 che rappresentano, rispettivamente, i coefficienti del polinomio 1 e 2. Volendo sommare il primo ed il secondo polinomio, potremo scrivere: >>> import numpy.polynomial.polynomial as poly >>> c1 = ( 0 , 2 , 1 ) >>> c2 = ( 1 , 3 , 2 ) >>> poly . polyadd ( c1 , c2 ) array ([ 1. , 5. , 3. ]) che \u00e8 il risultato atteso, ovvero \\(x^2 + 5x + 3\\) . Notiamo come le dimensioni di c1 e di c2 debbano essere tra loro coerenti . Se infatti omettessimo il coefficiente \\(0\\) al termine di secondo grado in c1 , il risultato sarebbe il seguente: >>> c1 = ( 2 , 1 ) >>> poly . polyadd ( c1 , c2 ) array ([ 3. , 4. , 2. ]) Ovviamente, il risultato precedente \u00e8 errato. Sottrazione di polinomi \u00b6 Possiamo poi sottrarre due polinomi usando la funzione polysub(c1, c2) , i cui parametri sono identici a quelli passati a polyadd : >>> poly . polysub ( c2 , c1 ) array ([ 1. , 1. , 1. ]) Moltiplicazione di polinomi \u00b6 Le considerazioni precedenti possono essere banalmente traslate al caso della moltiplicazione tra polinomi, ottenibile mediante la funzione polymul(c1, c2) . >>> poly . polymul ( c1 , c2 ) array ([ 0. , 2. , 7. , 7. , 2. ]) Nota Notiamo che il coefficiente del termine di quarto grado viene comunque riportato, nonostante questo sia pari a zero. Divisione tra polinomi \u00b6 La divisione tra polinomi \u00e8 un'operazione leggermente pi\u00f9 complessa delle altre, e prevede l'uso della funzione polydiv(c1, c2) , che restituir\u00e0 stavolta due array: il primo, q , rappresenta i coefficienti del polinomio quoziente, mentre il secondo, r , indica i coefficienti del polinomio resto. Nel nostro caso: >>> ( q , r ) = poly . polydiv ( c1 , c2 ) >>> q array ([ 0.5 ]) >>> r array ([ - 0.5 , 0.5 ]) Elevazione a potenza \u00b6 Chiudiamo questa breve panoramica parlando dell'elevazione a potenza di un polinomio, effettuabile mediante la funzione polypow(c, pow) , con c vettore dei coefficienti, e pow potenza a cui elevare: >>> poly . polypow ( c1 , 2 ) array ([ 0. , 0. , 4. , 4. , 1. ]) Anche in questo caso, vengono riportati i termini pari a zero nei risultati. Visualizzazione di un polinomio \u00b6 Il metodo che abbiamo usato finora per visualizzare i coefficienti di un polinomio \u00e8 alquanto inefficace e poco rappresentativo. Possiamo quindi sfruttare la funzione poly1d(p) di NumPy, che ci offre un oggetto la cui rappresentazione \u00e8 molto pi\u00f9 simile a quella cui siamo abituati nella \"realt\u00e0\": >>> p = np . poly1d ( c1 ) >>> print ( p ) 2 x + 1 Suggerimento Esistono diversi modi di sfruttare questa rappresentazione per mostrare a schermo i polinomi risultanti dalle operazioni che effettuiamo. Uno, banale, \u00e8 convertire il polinomio risultante; altri invece prevedono l'utilizzo delle funzioni polinomiali di NumPy (e non del package polynomial.polynomial ). Valutare un polinomio \u00b6 Per valutare il valore \\(y\\) assunto dal polinomio per un determinato valore di \\(x\\) , usiamo la funzione polyval(x, p) , che accetta come argomento un intero (o una lista di interi) x ed un polinomio p . Se volessimo valutare il valore assunto da \\(y\\) per \\(x \\in [1, 2]\\) sulla retta rappresentata dal polinomio c1 , ad esempio, potremmo usare polyval come segue: >>> poly . polyval ([ 1 , 2 ], c1 ) array ([ 3. , 8. ]) Derivata ed integrale di funzioni polinomiali \u00b6 Concludiamo questa breve carrellata con due metodi in grado di calcolare, rispettivamente, la derivata e l'integrale di una funzione polinomiale. Il metodo polyder(p, m) , infatti, permette di calcolare la derivata di ordine m del polinomio p (di default, m=2 ): >>> c1 = ( 2 , 1 ) >>> poly . polyder ( c1 ) array ([ 1. ]) Attenzione Non inseriamo coefficienti \"extra\" usando polyder e polyints , in quanto potrebbero portare a risultati inattesi. Il metodo duale \u00e8 polyint(p, m) , che prevedibilmente calcola l'integrale di ordine m del polinomio p : >>> poly . polyint ( c1 ) array ([ 0. , 2. , 0.5 ]) Conclusioni \u00b6 In questa lezione, abbiamo dato uno sguardo ad alcune delle funzioni per il trattamento dei polinomi messe a disposizione da NumPy. Nella prossima lezione, daremo uno sguardo ravvicinato alle funzioni statistiche.","title":"07.5 - Polinomi in NumPy"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#il-modulo-polynomial","text":"Il modulo numpy.polynomial.polynomial ci offre numerose classi e funzionalit\u00e0 per il trattamento dei polinomi. Vediamo insieme quali sono le principali.","title":"Il modulo polynomial"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#operazioni-tra-polinomi","text":"Immaginiamo di avere due diversi polinomi (cui non associeremo alcun significato fisico), ovvero: \\[ y = 2x + 1 \\\\ y = x^2 + 3x + 2 \\] Vediamo come usare dei metodi forniti dal modulo polynomial per effettuare delle operazioni su di loro.","title":"Operazioni tra polinomi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#addizione-di-polinomi","text":"Per effettuare l'addizione di due polinomi, possiamo usare il metodo polyadd(c1, c2) , che accetta come parametri due vettori c1 e c2 che rappresentano, rispettivamente, i coefficienti del polinomio 1 e 2. Volendo sommare il primo ed il secondo polinomio, potremo scrivere: >>> import numpy.polynomial.polynomial as poly >>> c1 = ( 0 , 2 , 1 ) >>> c2 = ( 1 , 3 , 2 ) >>> poly . polyadd ( c1 , c2 ) array ([ 1. , 5. , 3. ]) che \u00e8 il risultato atteso, ovvero \\(x^2 + 5x + 3\\) . Notiamo come le dimensioni di c1 e di c2 debbano essere tra loro coerenti . Se infatti omettessimo il coefficiente \\(0\\) al termine di secondo grado in c1 , il risultato sarebbe il seguente: >>> c1 = ( 2 , 1 ) >>> poly . polyadd ( c1 , c2 ) array ([ 3. , 4. , 2. ]) Ovviamente, il risultato precedente \u00e8 errato.","title":"Addizione di polinomi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#sottrazione-di-polinomi","text":"Possiamo poi sottrarre due polinomi usando la funzione polysub(c1, c2) , i cui parametri sono identici a quelli passati a polyadd : >>> poly . polysub ( c2 , c1 ) array ([ 1. , 1. , 1. ])","title":"Sottrazione di polinomi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#moltiplicazione-di-polinomi","text":"Le considerazioni precedenti possono essere banalmente traslate al caso della moltiplicazione tra polinomi, ottenibile mediante la funzione polymul(c1, c2) . >>> poly . polymul ( c1 , c2 ) array ([ 0. , 2. , 7. , 7. , 2. ]) Nota Notiamo che il coefficiente del termine di quarto grado viene comunque riportato, nonostante questo sia pari a zero.","title":"Moltiplicazione di polinomi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#divisione-tra-polinomi","text":"La divisione tra polinomi \u00e8 un'operazione leggermente pi\u00f9 complessa delle altre, e prevede l'uso della funzione polydiv(c1, c2) , che restituir\u00e0 stavolta due array: il primo, q , rappresenta i coefficienti del polinomio quoziente, mentre il secondo, r , indica i coefficienti del polinomio resto. Nel nostro caso: >>> ( q , r ) = poly . polydiv ( c1 , c2 ) >>> q array ([ 0.5 ]) >>> r array ([ - 0.5 , 0.5 ])","title":"Divisione tra polinomi"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#elevazione-a-potenza","text":"Chiudiamo questa breve panoramica parlando dell'elevazione a potenza di un polinomio, effettuabile mediante la funzione polypow(c, pow) , con c vettore dei coefficienti, e pow potenza a cui elevare: >>> poly . polypow ( c1 , 2 ) array ([ 0. , 0. , 4. , 4. , 1. ]) Anche in questo caso, vengono riportati i termini pari a zero nei risultati.","title":"Elevazione a potenza"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#visualizzazione-di-un-polinomio","text":"Il metodo che abbiamo usato finora per visualizzare i coefficienti di un polinomio \u00e8 alquanto inefficace e poco rappresentativo. Possiamo quindi sfruttare la funzione poly1d(p) di NumPy, che ci offre un oggetto la cui rappresentazione \u00e8 molto pi\u00f9 simile a quella cui siamo abituati nella \"realt\u00e0\": >>> p = np . poly1d ( c1 ) >>> print ( p ) 2 x + 1 Suggerimento Esistono diversi modi di sfruttare questa rappresentazione per mostrare a schermo i polinomi risultanti dalle operazioni che effettuiamo. Uno, banale, \u00e8 convertire il polinomio risultante; altri invece prevedono l'utilizzo delle funzioni polinomiali di NumPy (e non del package polynomial.polynomial ).","title":"Visualizzazione di un polinomio"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#valutare-un-polinomio","text":"Per valutare il valore \\(y\\) assunto dal polinomio per un determinato valore di \\(x\\) , usiamo la funzione polyval(x, p) , che accetta come argomento un intero (o una lista di interi) x ed un polinomio p . Se volessimo valutare il valore assunto da \\(y\\) per \\(x \\in [1, 2]\\) sulla retta rappresentata dal polinomio c1 , ad esempio, potremmo usare polyval come segue: >>> poly . polyval ([ 1 , 2 ], c1 ) array ([ 3. , 8. ])","title":"Valutare un polinomio"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#derivata-ed-integrale-di-funzioni-polinomiali","text":"Concludiamo questa breve carrellata con due metodi in grado di calcolare, rispettivamente, la derivata e l'integrale di una funzione polinomiale. Il metodo polyder(p, m) , infatti, permette di calcolare la derivata di ordine m del polinomio p (di default, m=2 ): >>> c1 = ( 2 , 1 ) >>> poly . polyder ( c1 ) array ([ 1. ]) Attenzione Non inseriamo coefficienti \"extra\" usando polyder e polyints , in quanto potrebbero portare a risultati inattesi. Il metodo duale \u00e8 polyint(p, m) , che prevedibilmente calcola l'integrale di ordine m del polinomio p : >>> poly . polyint ( c1 ) array ([ 0. , 2. , 0.5 ])","title":"Derivata ed integrale di funzioni polinomiali"},{"location":"material/02_libs/07_numpy/05_polynomials/lecture/#conclusioni","text":"In questa lezione, abbiamo dato uno sguardo ad alcune delle funzioni per il trattamento dei polinomi messe a disposizione da NumPy. Nella prossima lezione, daremo uno sguardo ravvicinato alle funzioni statistiche.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/06_intro/lecture/","text":"6. Introduzione a NumPy \u00b6 La libreria NumPy , nome derivante dalla crasi tra *Num*erical *Py*thon, \u00e8 una tra le pi\u00f9 utilizzate nelle applicazioni di calcolo scientifico in Python. Nella pratica, possiamo pensare a NumPy come ad uno standard de facto : infatti, le classi ed i metodi messi a disposizione dalla libreria sono estensivamente utilizzate nella quasi totalit\u00e0 degli altri tool Python per le scienze matematiche, chimiche e fisiche, oltre che per l'ingegneria. Partiamo nella nostra disamina dalla procedura di installazione della libreria. Nota In realt\u00e0, partiremo sempre dalla procedura di installazione, qualunque sia la libreria che analizzeremo. 6.1 Installare NumPy \u00b6 Ricordiamo che le diverse opzioni utilizzabili per installare una libreria sono descritte nel dettaglio nell' appendice B . Nel nostro caso, installeremo NumPy mediante 6.1.1 \u00b6 La prima, e forse la pi\u00f9 utilizzata universalmente, \u00e8 quella di utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Possia Per installare NumPy \u00e8 possibile optare per due opzioni. La prima \u00e8 usare una distribuzione scientifica \"predefinita\" di Python (la pi\u00f9 conosciuta \u00e8 Anaconda ); la seconda, che \u00e8 anche quella che seguiremo, \u00e8 creare un apposito ambiente virtuale (cfr. Appendice B) con il gestore delle dipendenze pipenv . Creiamo quindi una nuova cartella all'interno della quale andremo ad ospitare tutti i nostri script, e spostiamoci all'interno della stessa: $ mkdir python-data-science $ cd python-data-science A questo punto, usiamo pipenv per creare un nuovo ambiente virtuale ed installare NumPy: ===\"Pip\" pip install numpy ===\"Pipenv\" pipenv install numpy Una volta terminata la procedura, saranno presenti due file all'interno della cartella python-data-science : Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente questi due file. Per farlo, esistono comandi appositi, che saranno introdotti man mano che li useremo. Importare NumPy \u00b6 Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np Gli ndarray \u00b6 La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy mette a disposizione gli ndarray , che rappresentano degli array ad \\(n\\) dimensioni contenenti dati di tipo omogeneo . Il significato di ndarray ndarray \u00e8 un'abbreviazione che sta per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 in qualche modo simile a quella di una classica lista Python: >>> a = np . array ([ 1 , 2 , 3 ]) In realt\u00e0, volendo essere precisi, possiamo affermare come esista un costruttore che crea un ndarray a partire da una lista, come mostrato nel codice precedente. Questa sintassi, per\u00f2, non deve trarre in inganno. Sono diverse le differenze che intercorrono tra un ndarray ed una classica lista; le principali possono essere riassunte nella seguente tabella. Caratteristica ndarray Lista Dimensione Fissata al momento della creazione Mutabile (ad esempio, con append() ) Elementi Omogenei (stesso tipo) Eterogenei (qualsiasi tipo) Ambito Operazioni algebriche General-purpose Commentiamo brevemente le differenze viste nella tabella precedente: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array comporter\u00e0 quindi la creazione di un nuovo array, con la cancellazione di quello originario. Nella lista, essendo mutabile, questo non avviene; gli elementi di un ndarray devono essere dello stesso tipo, mentre le liste accettano qualsiasi tipo di elemento al loro interno; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni, mentre le liste sono progettate per supportare di ogni tipo. Efficienza di NumPy nelle operazioni algebriche \u00b6 Il punto 3 dell'elenco precedente assume particolare rilevanza ai nostri fini. Per comprenderne il motivo, facciamo un semplice esempio, considerando una moltiplicazione elemento per elemento tra due vettori riga della stessa dimensione. Approccio con liste \u00b6 Usando due liste, potremmo usare un ciclo for o una list comprehension: # ciclo for c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) # list comprehension c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] Il risultato dell'operazione sar\u00e0 in entrambi i casi corretto . Tuttavia, i cicli sono computazionalmente costosi : ci\u00f2 significa che, specialmente all'aumentare del numero di elementi contenuti nei vettori, sar\u00e0 necessario pagare un costo crescente. La soluzione sarebbe quindi quella di ricorrere ad un linguaggio pi\u00f9 efficiente, come il C che, essendo compilato, riduce alcune delle inefficienze tipiche dei linguaggi interpretati. Il codice precedentemente diverrebbe quindi: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Apparentemente s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Il numero di cicli annidati aumenter\u00e0 in maniera direttamente proporzionale alla dimensionalit\u00e0 degli array: ci\u00f2 significa, ad esempio, che per un array a dieci dimensioni avremo altrettanti cicli annidati. Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, per moltiplicare due array in NumPy basta la seguente istruzione: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, anche rispetto alle liste in Python , ed \u00e8 molto simile a quella che si trova sulle formule \"reali\" usate sui libri di testo. Infine, questa istruzione sfrutta codice precompilato : in questo modo, si potranno ottenere delle prestazioni (quasi) equivalenti a quelle del codice scritto direttamente in C. Vettorizzazione e broadcasting Quello che abbiamo appena visto \u00e8 formalmente riassumibile nei concetti di vettorizzazione (ovvero la possibilit\u00e0 di scrivere il codice senza usare esplicitamente dei cicli) e broadcasting (riguardante la possibilit\u00e0 di usare una sintassi comune ed indipendente dalla dimensionalit\u00e0 degli array coinvolti nelle operazioni). Conclusioni \u00b6 In questa lezione, abbiamo dato un breve sguardo su quello che offre NumPy, e sul perch\u00e9 preferirlo in determinate situazioni all'uso delle normali tecniche messe a disposizione da Python. Nella prossima lezione , continueremo il discorso sugli array, scendendo maggiormente nel dettaglio di questa importante struttura dati.","title":"6. Introduzione a NumPy"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#6-introduzione-a-numpy","text":"La libreria NumPy , nome derivante dalla crasi tra *Num*erical *Py*thon, \u00e8 una tra le pi\u00f9 utilizzate nelle applicazioni di calcolo scientifico in Python. Nella pratica, possiamo pensare a NumPy come ad uno standard de facto : infatti, le classi ed i metodi messi a disposizione dalla libreria sono estensivamente utilizzate nella quasi totalit\u00e0 degli altri tool Python per le scienze matematiche, chimiche e fisiche, oltre che per l'ingegneria. Partiamo nella nostra disamina dalla procedura di installazione della libreria. Nota In realt\u00e0, partiremo sempre dalla procedura di installazione, qualunque sia la libreria che analizzeremo.","title":"6. Introduzione a NumPy"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#61-installare-numpy","text":"Ricordiamo che le diverse opzioni utilizzabili per installare una libreria sono descritte nel dettaglio nell' appendice B . Nel nostro caso, installeremo NumPy mediante","title":"6.1 Installare NumPy"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#611","text":"La prima, e forse la pi\u00f9 utilizzata universalmente, \u00e8 quella di utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Possia Per installare NumPy \u00e8 possibile optare per due opzioni. La prima \u00e8 usare una distribuzione scientifica \"predefinita\" di Python (la pi\u00f9 conosciuta \u00e8 Anaconda ); la seconda, che \u00e8 anche quella che seguiremo, \u00e8 creare un apposito ambiente virtuale (cfr. Appendice B) con il gestore delle dipendenze pipenv . Creiamo quindi una nuova cartella all'interno della quale andremo ad ospitare tutti i nostri script, e spostiamoci all'interno della stessa: $ mkdir python-data-science $ cd python-data-science A questo punto, usiamo pipenv per creare un nuovo ambiente virtuale ed installare NumPy: ===\"Pip\" pip install numpy ===\"Pipenv\" pipenv install numpy Una volta terminata la procedura, saranno presenti due file all'interno della cartella python-data-science : Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente questi due file. Per farlo, esistono comandi appositi, che saranno introdotti man mano che li useremo.","title":"6.1.1"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#importare-numpy","text":"Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np","title":"Importare NumPy"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#gli-ndarray","text":"La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy mette a disposizione gli ndarray , che rappresentano degli array ad \\(n\\) dimensioni contenenti dati di tipo omogeneo . Il significato di ndarray ndarray \u00e8 un'abbreviazione che sta per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 in qualche modo simile a quella di una classica lista Python: >>> a = np . array ([ 1 , 2 , 3 ]) In realt\u00e0, volendo essere precisi, possiamo affermare come esista un costruttore che crea un ndarray a partire da una lista, come mostrato nel codice precedente. Questa sintassi, per\u00f2, non deve trarre in inganno. Sono diverse le differenze che intercorrono tra un ndarray ed una classica lista; le principali possono essere riassunte nella seguente tabella. Caratteristica ndarray Lista Dimensione Fissata al momento della creazione Mutabile (ad esempio, con append() ) Elementi Omogenei (stesso tipo) Eterogenei (qualsiasi tipo) Ambito Operazioni algebriche General-purpose Commentiamo brevemente le differenze viste nella tabella precedente: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array comporter\u00e0 quindi la creazione di un nuovo array, con la cancellazione di quello originario. Nella lista, essendo mutabile, questo non avviene; gli elementi di un ndarray devono essere dello stesso tipo, mentre le liste accettano qualsiasi tipo di elemento al loro interno; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni, mentre le liste sono progettate per supportare di ogni tipo.","title":"Gli ndarray"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#efficienza-di-numpy-nelle-operazioni-algebriche","text":"Il punto 3 dell'elenco precedente assume particolare rilevanza ai nostri fini. Per comprenderne il motivo, facciamo un semplice esempio, considerando una moltiplicazione elemento per elemento tra due vettori riga della stessa dimensione.","title":"Efficienza di NumPy nelle operazioni algebriche"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#approccio-con-liste","text":"Usando due liste, potremmo usare un ciclo for o una list comprehension: # ciclo for c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) # list comprehension c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] Il risultato dell'operazione sar\u00e0 in entrambi i casi corretto . Tuttavia, i cicli sono computazionalmente costosi : ci\u00f2 significa che, specialmente all'aumentare del numero di elementi contenuti nei vettori, sar\u00e0 necessario pagare un costo crescente. La soluzione sarebbe quindi quella di ricorrere ad un linguaggio pi\u00f9 efficiente, come il C che, essendo compilato, riduce alcune delle inefficienze tipiche dei linguaggi interpretati. Il codice precedentemente diverrebbe quindi: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Apparentemente s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Il numero di cicli annidati aumenter\u00e0 in maniera direttamente proporzionale alla dimensionalit\u00e0 degli array: ci\u00f2 significa, ad esempio, che per un array a dieci dimensioni avremo altrettanti cicli annidati. Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, per moltiplicare due array in NumPy basta la seguente istruzione: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, anche rispetto alle liste in Python , ed \u00e8 molto simile a quella che si trova sulle formule \"reali\" usate sui libri di testo. Infine, questa istruzione sfrutta codice precompilato : in questo modo, si potranno ottenere delle prestazioni (quasi) equivalenti a quelle del codice scritto direttamente in C. Vettorizzazione e broadcasting Quello che abbiamo appena visto \u00e8 formalmente riassumibile nei concetti di vettorizzazione (ovvero la possibilit\u00e0 di scrivere il codice senza usare esplicitamente dei cicli) e broadcasting (riguardante la possibilit\u00e0 di usare una sintassi comune ed indipendente dalla dimensionalit\u00e0 degli array coinvolti nelle operazioni).","title":"Approccio con liste"},{"location":"material/02_libs/07_numpy/06_intro/lecture/#conclusioni","text":"In questa lezione, abbiamo dato un breve sguardo su quello che offre NumPy, e sul perch\u00e9 preferirlo in determinate situazioni all'uso delle normali tecniche messe a disposizione da Python. Nella prossima lezione , continueremo il discorso sugli array, scendendo maggiormente nel dettaglio di questa importante struttura dati.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/","text":"Le funzioni statistiche \u00b6 NumPy ci mette a disposizione diverse funzioni per il calcolo statistico. Vediamone assieme una breve carrellata. Minimo e massimo di un array \u00b6 Partiamo con due funzioni che possono essere utili per determinare il valore massimo ed il valore minimo di un array a , ovvero amin(a) ed amax(a) . Entrambe queste funzioni accettano (opzionalmente) un valore per il parametro axis , indicante al solito la direzione lungo la quale viene effettuata l'operazione. Ad esempio, se volessimo trovare il minimo ed il massimo di un vettore generato casualmente: >>> rng = np . random . default_rng ( 42 ) >>> a = rng . integers ( low = 0 , high = 10 , size = 5 ) >>> a array ([ 0 , 7 , 6 , 4 ], dtype = int64 ) >>> np . amin ( a ) 0 >>> np . amax ( a ) 7 Attenzione Nel codice precedente abbiamo usato la funzione default_rng del package random di NumPy per generare un vettore di numeri casuali. Per una matrice, ed in generale per ogni array N-dimensionale, il procedimento da seguire \u00e8 analogo: >>> b = rng . integers ( low = 0 , high = 10 , size = ( 3 , 3 )) >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . amin ( b ) 0 >>> np . amax ( b ) 9 Immaginiamo adesso di voler trovare il minimo ed il massimo per colonna per b . Al solito, specifichiamo il parametro axis , che assumer\u00e0 valore pari a 0 : >>> np . amin ( b , axis = 0 ) array ([ 4 , 2 , 0 ], dtype = int64 ) >>> np . amax ( b , axis = 0 ) array ([ 6 , 9 , 7 ], dtype = int64 ) Ovviamente, per trovare il minimo ed il massimo per riga , dovremo cambiare il valore di axis in 1 : >>> np . amin ( b , axis = 1 ) array ([ 0 , 0 , 5 ], dtype = int64 ) >>> np . amax ( b , axis = 1 ) array ([ 8 , 6 , 9 ], dtype = int64 ) Possiamo anche specificare una tupla per il valore del parametro axis ; in tal caso, la ricerca del massimo o del minimo avverr\u00e0 lungo tutti gli assi specificati dalla tupla. Ad esempio, specificando (0, 1) , effettueremo la ricerca del minimo (o del massimo) elemento nella matrice: >>> np . amin ( b , axis = ( 0 , 1 )) 0 >>> np . amax ( b , axis = ( 0 , 1 )) 9 Percentile, quantile e mediana \u00b6 Ricordiamo che il q-percentile di un vettore \\(V\\) di lunghezza \\(N\\) \u00e8 il valore sotto il quale ricade il \\(q\\) % degli elementi di \\(V\\) . Per fare un esempio, supponiamo di avere un vettore ordinato di elementi che vanno da 1 a 10: >>> a = np . arange ( 1 , 11 ) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) Possiamo calcolare il 50-percentile usando la formula classica, che ci dice che questo \u00e8 pari a: \\[ n = \\frac{q}{100} * N = \\frac{50}{100} * 10 = 5 \\] In realt\u00e0, la funzione percentile(a, q) usa, per il 50-percentile, il calcolo della mediana, per cui \u00e8 equivalente alla funzione median(a) . In questo caso specifico, avremo un discostamento dal risultato atteso, dovuto ad errori di interpolazione introdotti da NumPy: >>> np . percentile ( a , 50 ) 5.5 Il concetto di quantile \u00e8 analogo a quello di percentile; tuttavia, in questo caso, non abbiamo a che fare con valori percentuali, bens\u00ec con valori normalizzat tra 0 ed 1. Per cui, se usassimo la funzione quantile(a, q) come in precedenza: >>> np . quantile ( a , .5 ) 5.5 Anche le funzioni percentile e quantile prevedono come argomento opzionale il parametro axis . Ad esempio: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . percentile ( b , 50 , axis = 0 ) array ([ 5. , 8. , 0. ]) >>> np . percentile ( b , 50 , axis = 1 ) array ([ 4. , 2. , 7. ]) Come previsto, dando il valore 0 al parametro axis avremo il calcolo del percentile su ciascuna colonna, mentre passando il valore 1 avremo il calcolo del percentile su ciascuna riga. Media aritmetica e media pesata \u00b6 Per il calcolo del valore medio di un array NumPy ci mette a disposizione due metodi. Il primo \u00e8 la funzione average(a, weights) , che viene usata per calcolare una media pesata degli elementi di a ponderati per gli elementi di weights (a patto che, ovviamente, le dimensioni dei due array siano coerenti). Il calcolo che viene effettuato da NumPy con la funzione average \u00e8 quindi il seguente: avg = sum ( a * weights ) / sum ( weights ) Per cui, se volessimo assegnare un peso maggiore al primo ed al quarto elemento di un array a generato casualmente, potremmo fare come segue: >>> a = rng . integers ( low = 0 , high = 10 , size = 4 ) >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> w = np . array ([ 3 , 1 , 1 , 3 ]) >>> np . average ( a , weights = w ) 6.25 Il risultato si discosta leggermente dalla semplice media: >>> np . average ( a ) 6.5 Suggerimento Teniamo sempre a mente che la media \u00e8 ponderata per la sommatoria dei valori assunti dai pesi! La funzione mean(a) \u00e8 invece rappresentativa della media aritmetica degli elementi di un array, ed equivale alla funzione average(a) senza la specifica del vettore dei pesi. Ad esempio: >>> np . mean ( a ) 6.5 Concludiamo ricordando che anche in questo caso possiamo specificare il valore del parametro axis: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . mean ( b , axis = 0 ) array ([ 5. , 6.33333333 , 2.33333333 ]) >>> np . mean ( b , axis = 1 ) array ([ 4. , 2.66666667 , 7. ]) Varianza e deviazione standard \u00b6 Non possono mancare le funzioni std(a) e var(a) , dedicate al calcolo della deviazione standard e della varianza di un vettore: >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> np . std ( a ) 0.8660254037844386 >>> np . var ( a ) 0.75 Anche in questo caso, possiamo specificare gli assi lungo i quali effettuare l'operazione desiderata: >>> np . var ( b , axis = 0 ) array ([ 0.66666667 , 9.55555556 , 10.88888889 ]) >>> np . var ( b , axis = 1 ) array ([ 10.66666667 , 6.22222222 , 2.66666667 ]) Matrice di covarianza \u00b6 La matrice di covarianza \u00e8 la matrice che racchiude tutti i coefficienti di correlazione , che ci permetteno di valutare come una certa variabile \\(x_i\\) varia al variare di un'altra variabile \\(x_j\\) . In generale, esistono diversi tipi di coefficienti di correlazione; il pi\u00f9 semplice \u00e8 quello di Pearson, che stima una correlazione di tipo lineare (ovvero, \u00e8 tanto pi\u00f9 alto quanto le due variabili crescono secondo un rapporto lineare), ed \u00e8 quello usato dalle funzioni cov(a) e corrcoef(a) , la seconda delle quali riporta i valori normalizzati dei risultati ottenibili anche con la prima. In questo caso, a pu\u00f2 essere monodimensionale o bidimensionale, ma ogni riga di a rappresenta una variabile , mentre ogni colonna rappresenta una osservazione . Facciamo qualche esempio. Immaginiamo di avere due variabili che assumono rispettivamente valori [1, 2, 3] e [4, 5, 6] . In questo caso, \u00e8 evidente come la correlazione sia massima, in quanto le osservazioni della seconda variabile hanno un semplice offset (o bias ) rispetto a quelle della prima. Proviamo a calcolare la matrice di correlazione: >>> x = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> x array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> np . cov ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) Notiamo che, dato che i coefficienti di correlazione assumono valore pari ad 1, le due variabili sono fortemente correlate tra loro. Se invece avessimo una situazione di questo tipo: >>> x = np . array ([[ 1 , 2 , 3 ], [ - 1 , - 2 , - 3 ]]) >>> np . cov ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) In questo caso, \u00e8 evidente come le variabili siano anticorrelate , il che significa che quando la prima sale, la seconda scende, e viceversa. Per apprezzare le differenze tra le funzioni cov e corrcoef , dobbiamo usare valori differenti (e non banali) per x . Ad esempio: >>> x = np . array ([[ 2 , 3 , - 1 ], [ 1 , 5 , 2 ], [ 4 , 2 , 2 ]]) >>> np . cov ( x ) array ([[ 4.33333333 , 2.16666667 , 0.66666667 ], [ 2.16666667 , 4.33333333 , - 1.66666667 ], [ 0.66666667 , - 1.66666667 , 1.33333333 ]]) >>> np . corrcoef ( x ) array ([[ 1. , 0.5 , 0.2773501 ], [ 0.5 , 1. , - 0.69337525 ], [ 0.2773501 , - 0.69337525 , 1. ]]) In sostanza, corrcoef restituisce la matrice dei coefficienti \\(R\\) , la cui relazione con la matrice di covarianza \\(C\\) restituita da cov \u00e8: \\[ R_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} * C_{jj}}} \\] Istogramma \u00b6 Un istogramma offre una visualizzazione grafica dei valori contenuti in un vettore, raggruppandoli all'interno di un certo numero di partizioni ( bin ). Ad esempio, una possibile rappresentazione a due partizioni del vettore \\(A = [1, 2, 3, 4]\\) \u00e8 data dal vettore \\([2, 2]\\) . Questo si spiega col fatto che le due partizioni suddividono il range di valori assunti da \\(A\\) in due parti, con la prima inerente gli elementi \\(1\\) e \\(2\\) , e la seconda gli elementi \\(3\\) e \\(4\\) . Una volta calcolate le partizioni, queste andranno \"riempite\" contando il numero di elementi presenti in ciascuna partizione, il che ci riporta al vettore \\([2, 2]\\) . Nota Ovviamente, \u00e8 possibile specificare, oltre al numero di partizioni, anche gli estremi delle stesse, che potrebbero non coincidere con quelli del vettore. NumPy ci permette di ottenere l'istogramma di un vettore mediante l'insieme di funzioni histogram(a, bins, range) , che ci permette di calcolare l'istogramma (monodimensionale) dell'array a in funzione del numero di partizioni (opzionale) e del range (opzionale). Ad esempio: >>> a = rng . integers ( low = 0 , high = 10 , size = 100 ) >>> h , b = np . histogram ( a ) >>> h array ([ 9 , 9 , 11 , 10 , 15 , 8 , 12 , 11 , 5 , 10 ], dtype = int64 ) >>> b array ([ 0. , 0.9 , 1.8 , 2.7 , 3.6 , 4.5 , 5.4 , 6.3 , 7.2 , 8.1 , 9. ]) In questo caso, abbiamo lasciato il valore di default di bins , ovvero 10. Conclusioni \u00b6 In questa lezione, abbiamo visto alcune delle principali potenzialit\u00e0 offerte da NumPy in ambito statistico. Con questo, abbiamo terminato la nostra \"panoramica\" su NumPy.","title":"07.6 - Statistica in NumPy"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#le-funzioni-statistiche","text":"NumPy ci mette a disposizione diverse funzioni per il calcolo statistico. Vediamone assieme una breve carrellata.","title":"Le funzioni statistiche"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#minimo-e-massimo-di-un-array","text":"Partiamo con due funzioni che possono essere utili per determinare il valore massimo ed il valore minimo di un array a , ovvero amin(a) ed amax(a) . Entrambe queste funzioni accettano (opzionalmente) un valore per il parametro axis , indicante al solito la direzione lungo la quale viene effettuata l'operazione. Ad esempio, se volessimo trovare il minimo ed il massimo di un vettore generato casualmente: >>> rng = np . random . default_rng ( 42 ) >>> a = rng . integers ( low = 0 , high = 10 , size = 5 ) >>> a array ([ 0 , 7 , 6 , 4 ], dtype = int64 ) >>> np . amin ( a ) 0 >>> np . amax ( a ) 7 Attenzione Nel codice precedente abbiamo usato la funzione default_rng del package random di NumPy per generare un vettore di numeri casuali. Per una matrice, ed in generale per ogni array N-dimensionale, il procedimento da seguire \u00e8 analogo: >>> b = rng . integers ( low = 0 , high = 10 , size = ( 3 , 3 )) >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . amin ( b ) 0 >>> np . amax ( b ) 9 Immaginiamo adesso di voler trovare il minimo ed il massimo per colonna per b . Al solito, specifichiamo il parametro axis , che assumer\u00e0 valore pari a 0 : >>> np . amin ( b , axis = 0 ) array ([ 4 , 2 , 0 ], dtype = int64 ) >>> np . amax ( b , axis = 0 ) array ([ 6 , 9 , 7 ], dtype = int64 ) Ovviamente, per trovare il minimo ed il massimo per riga , dovremo cambiare il valore di axis in 1 : >>> np . amin ( b , axis = 1 ) array ([ 0 , 0 , 5 ], dtype = int64 ) >>> np . amax ( b , axis = 1 ) array ([ 8 , 6 , 9 ], dtype = int64 ) Possiamo anche specificare una tupla per il valore del parametro axis ; in tal caso, la ricerca del massimo o del minimo avverr\u00e0 lungo tutti gli assi specificati dalla tupla. Ad esempio, specificando (0, 1) , effettueremo la ricerca del minimo (o del massimo) elemento nella matrice: >>> np . amin ( b , axis = ( 0 , 1 )) 0 >>> np . amax ( b , axis = ( 0 , 1 )) 9","title":"Minimo e massimo di un array"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#percentile-quantile-e-mediana","text":"Ricordiamo che il q-percentile di un vettore \\(V\\) di lunghezza \\(N\\) \u00e8 il valore sotto il quale ricade il \\(q\\) % degli elementi di \\(V\\) . Per fare un esempio, supponiamo di avere un vettore ordinato di elementi che vanno da 1 a 10: >>> a = np . arange ( 1 , 11 ) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) Possiamo calcolare il 50-percentile usando la formula classica, che ci dice che questo \u00e8 pari a: \\[ n = \\frac{q}{100} * N = \\frac{50}{100} * 10 = 5 \\] In realt\u00e0, la funzione percentile(a, q) usa, per il 50-percentile, il calcolo della mediana, per cui \u00e8 equivalente alla funzione median(a) . In questo caso specifico, avremo un discostamento dal risultato atteso, dovuto ad errori di interpolazione introdotti da NumPy: >>> np . percentile ( a , 50 ) 5.5 Il concetto di quantile \u00e8 analogo a quello di percentile; tuttavia, in questo caso, non abbiamo a che fare con valori percentuali, bens\u00ec con valori normalizzat tra 0 ed 1. Per cui, se usassimo la funzione quantile(a, q) come in precedenza: >>> np . quantile ( a , .5 ) 5.5 Anche le funzioni percentile e quantile prevedono come argomento opzionale il parametro axis . Ad esempio: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . percentile ( b , 50 , axis = 0 ) array ([ 5. , 8. , 0. ]) >>> np . percentile ( b , 50 , axis = 1 ) array ([ 4. , 2. , 7. ]) Come previsto, dando il valore 0 al parametro axis avremo il calcolo del percentile su ciascuna colonna, mentre passando il valore 1 avremo il calcolo del percentile su ciascuna riga.","title":"Percentile, quantile e mediana"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#media-aritmetica-e-media-pesata","text":"Per il calcolo del valore medio di un array NumPy ci mette a disposizione due metodi. Il primo \u00e8 la funzione average(a, weights) , che viene usata per calcolare una media pesata degli elementi di a ponderati per gli elementi di weights (a patto che, ovviamente, le dimensioni dei due array siano coerenti). Il calcolo che viene effettuato da NumPy con la funzione average \u00e8 quindi il seguente: avg = sum ( a * weights ) / sum ( weights ) Per cui, se volessimo assegnare un peso maggiore al primo ed al quarto elemento di un array a generato casualmente, potremmo fare come segue: >>> a = rng . integers ( low = 0 , high = 10 , size = 4 ) >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> w = np . array ([ 3 , 1 , 1 , 3 ]) >>> np . average ( a , weights = w ) 6.25 Il risultato si discosta leggermente dalla semplice media: >>> np . average ( a ) 6.5 Suggerimento Teniamo sempre a mente che la media \u00e8 ponderata per la sommatoria dei valori assunti dai pesi! La funzione mean(a) \u00e8 invece rappresentativa della media aritmetica degli elementi di un array, ed equivale alla funzione average(a) senza la specifica del vettore dei pesi. Ad esempio: >>> np . mean ( a ) 6.5 Concludiamo ricordando che anche in questo caso possiamo specificare il valore del parametro axis: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . mean ( b , axis = 0 ) array ([ 5. , 6.33333333 , 2.33333333 ]) >>> np . mean ( b , axis = 1 ) array ([ 4. , 2.66666667 , 7. ])","title":"Media aritmetica e media pesata"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#varianza-e-deviazione-standard","text":"Non possono mancare le funzioni std(a) e var(a) , dedicate al calcolo della deviazione standard e della varianza di un vettore: >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> np . std ( a ) 0.8660254037844386 >>> np . var ( a ) 0.75 Anche in questo caso, possiamo specificare gli assi lungo i quali effettuare l'operazione desiderata: >>> np . var ( b , axis = 0 ) array ([ 0.66666667 , 9.55555556 , 10.88888889 ]) >>> np . var ( b , axis = 1 ) array ([ 10.66666667 , 6.22222222 , 2.66666667 ])","title":"Varianza e deviazione standard"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#matrice-di-covarianza","text":"La matrice di covarianza \u00e8 la matrice che racchiude tutti i coefficienti di correlazione , che ci permetteno di valutare come una certa variabile \\(x_i\\) varia al variare di un'altra variabile \\(x_j\\) . In generale, esistono diversi tipi di coefficienti di correlazione; il pi\u00f9 semplice \u00e8 quello di Pearson, che stima una correlazione di tipo lineare (ovvero, \u00e8 tanto pi\u00f9 alto quanto le due variabili crescono secondo un rapporto lineare), ed \u00e8 quello usato dalle funzioni cov(a) e corrcoef(a) , la seconda delle quali riporta i valori normalizzati dei risultati ottenibili anche con la prima. In questo caso, a pu\u00f2 essere monodimensionale o bidimensionale, ma ogni riga di a rappresenta una variabile , mentre ogni colonna rappresenta una osservazione . Facciamo qualche esempio. Immaginiamo di avere due variabili che assumono rispettivamente valori [1, 2, 3] e [4, 5, 6] . In questo caso, \u00e8 evidente come la correlazione sia massima, in quanto le osservazioni della seconda variabile hanno un semplice offset (o bias ) rispetto a quelle della prima. Proviamo a calcolare la matrice di correlazione: >>> x = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> x array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> np . cov ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) Notiamo che, dato che i coefficienti di correlazione assumono valore pari ad 1, le due variabili sono fortemente correlate tra loro. Se invece avessimo una situazione di questo tipo: >>> x = np . array ([[ 1 , 2 , 3 ], [ - 1 , - 2 , - 3 ]]) >>> np . cov ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) In questo caso, \u00e8 evidente come le variabili siano anticorrelate , il che significa che quando la prima sale, la seconda scende, e viceversa. Per apprezzare le differenze tra le funzioni cov e corrcoef , dobbiamo usare valori differenti (e non banali) per x . Ad esempio: >>> x = np . array ([[ 2 , 3 , - 1 ], [ 1 , 5 , 2 ], [ 4 , 2 , 2 ]]) >>> np . cov ( x ) array ([[ 4.33333333 , 2.16666667 , 0.66666667 ], [ 2.16666667 , 4.33333333 , - 1.66666667 ], [ 0.66666667 , - 1.66666667 , 1.33333333 ]]) >>> np . corrcoef ( x ) array ([[ 1. , 0.5 , 0.2773501 ], [ 0.5 , 1. , - 0.69337525 ], [ 0.2773501 , - 0.69337525 , 1. ]]) In sostanza, corrcoef restituisce la matrice dei coefficienti \\(R\\) , la cui relazione con la matrice di covarianza \\(C\\) restituita da cov \u00e8: \\[ R_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} * C_{jj}}} \\]","title":"Matrice di covarianza"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#istogramma","text":"Un istogramma offre una visualizzazione grafica dei valori contenuti in un vettore, raggruppandoli all'interno di un certo numero di partizioni ( bin ). Ad esempio, una possibile rappresentazione a due partizioni del vettore \\(A = [1, 2, 3, 4]\\) \u00e8 data dal vettore \\([2, 2]\\) . Questo si spiega col fatto che le due partizioni suddividono il range di valori assunti da \\(A\\) in due parti, con la prima inerente gli elementi \\(1\\) e \\(2\\) , e la seconda gli elementi \\(3\\) e \\(4\\) . Una volta calcolate le partizioni, queste andranno \"riempite\" contando il numero di elementi presenti in ciascuna partizione, il che ci riporta al vettore \\([2, 2]\\) . Nota Ovviamente, \u00e8 possibile specificare, oltre al numero di partizioni, anche gli estremi delle stesse, che potrebbero non coincidere con quelli del vettore. NumPy ci permette di ottenere l'istogramma di un vettore mediante l'insieme di funzioni histogram(a, bins, range) , che ci permette di calcolare l'istogramma (monodimensionale) dell'array a in funzione del numero di partizioni (opzionale) e del range (opzionale). Ad esempio: >>> a = rng . integers ( low = 0 , high = 10 , size = 100 ) >>> h , b = np . histogram ( a ) >>> h array ([ 9 , 9 , 11 , 10 , 15 , 8 , 12 , 11 , 5 , 10 ], dtype = int64 ) >>> b array ([ 0. , 0.9 , 1.8 , 2.7 , 3.6 , 4.5 , 5.4 , 6.3 , 7.2 , 8.1 , 9. ]) In questo caso, abbiamo lasciato il valore di default di bins , ovvero 10.","title":"Istogramma"},{"location":"material/02_libs/07_numpy/06_statistics/lecture/#conclusioni","text":"In questa lezione, abbiamo visto alcune delle principali potenzialit\u00e0 offerte da NumPy in ambito statistico. Con questo, abbiamo terminato la nostra \"panoramica\" su NumPy.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/07_array/lecture/","text":"Introduzione agli array \u00b6 Nella scorsa lezione , abbiamo introdotto gli array , ovvero la struttura dati \"centrale\" all'interno dell'ecosistema di NumPy. In questa lezione e nelle successive ne approfondiremo gli aspetti e le caratteristiche principali. Array e liste \u00b6 La prima impressione che si pu\u00f2 avere \u00e8 che gli array siano molto simili alle classiche liste. Esistono per\u00f2 alcune differenze, cui abbiamo gi\u00e0 accennato nella scorsa lezione. In linea di massima, per\u00f2, \u00e8 preferibile usare un array quando si ha a che fare con operazioni di tipo matematico su dati omogenei , ovvero dello stesso tipo. Questo \u00e8 collegato essenzialmente a questioni di ottimizzazione : NumPy sfrutta per le operazioni matematiche del codice precompilato in C, ed inoltre gli array sono pi\u00f9 compatti e veloci da utilizzare rispetto alle liste. La classe ndarray \u00b6 Alle volte, ci si pu\u00f2 riferire ad un array con il termine ndarray , abbreviazione che sta per \\(n\\) -dimensional array. Questa \u00e8, in realt\u00e0, la rappresentazione pi\u00f9 generica degli array di NumPy, e permette di caratterizzare delle strutture dati con un numero arbitrario di dimensioni ( \\(n\\) , per l'appunto). Vettori, matrici e tensori Una struttura di tipo algebrico ad \\(n\\) dimensioni, con \\(n > 2\\) , \u00e8 detta tensore . Se \\(n = 1\\) , abbiamo un vettore , mentre con \\(n = 2\\) abbiamo una matrice . Creazione ed inizializzazione \u00b6 Il primo passo per utilizzare un ndarray \u00e8, ovviamente, crearlo! Per farlo, ci sono diversi metodi, ma il pi\u00f9 semplice \u00e8 sicuramente quello di passare al metodo array() di NumPy una lista di elementi. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) Possiamo passare anche una \"lista di liste\", in modo da ottenere un array multidimensionale: >>> b = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> b array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Gli array non sono necessariamente numerici. Possiamo, ad esempio, creare un array di stringhe: >>> c = np . array ([ \"s1\" , \"s2\" ]) >>> c array ([ 's1' , 's2' ], dtype = '<U2' ) Array eterogenei \u00b6 Abbiamo gi\u00e0 detto che gli array, a differenza delle stringhe, devono contenere dati omogenei , ovvero dello stesso tipo. Cosa succede se proviamo a passare al metodo numpy.array() una lista composta da dati di tipo differente? Facciamo un esempio. >>> d = np . array ([ 1 , 1. ]) >>> d array ([ 1. , 1. ]) Abbiamo passato al metodo array() un valore intero ed un float. Possiamo notare che \u00e8 stato effettuato un casting in maniera implicita, e tutti i valori passati sono stati convertiti in float. Vediamo cosa accade se provassimo a passare un intero ed una stringa. >>> e = np . array ([ 1 , \"s3\" ]) >>> e array ([ '1' , 's3' ], dtype = '<U11' ) Anche in questo caso, \u00e8 stata effettuata la conversione dei dati in automatico, passando stavolta da intero a stringa. La regola da tenere a mente, ad ogni modo, \u00e8 che NumPy (e, in generale, Python) seguono il principio dell' upcasting : in altre parole, quando deve essere fatta una conversione tra diversi tipi di dati, si far\u00e0 in modo da convertire tutte le variabili nel tipo a pi\u00f9 alta precisione , allo scopo di evitare perdite di informazioni. Il numero di elementi di un array \u00b6 Abbiamo detto che un array \u00e8 un \"contenitore\", a dimensione prefissata, per oggetti di un ben determinato tipo e dimensione. Il numero di dimensioni e gli oggetti contenuti all'interno di un array sono definiti a partire da una propriet\u00e0 chiamata shape , liberamente traducibile in \"forma\". Quest'ultima \u00e8 una tupla di numeri interi, ovviamente non negativi, che permette di determinare la dimensionalit\u00e0 dell'array lungo ogni asse (ovvero \\(x\\) , \\(y\\) , \\(z\\) , etc.). Ad esempio, potremo dire che il seguente array bidimensionale ha due assi, il primo di lunghezza due, il secondo di lunghezza tre: >>> a = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]]) >>> a array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Proviamo a valutare la propriet\u00e0 shape del precedente array: >>> a . shape ( 2 , 3 ) Conclusioni \u00b6 In questa lezione, abbiamo dato una breve panoramica introduttiva sugli array. Nella prossima lezione , approfondiremo ulteriormente le loro modalit\u00e0 di creazione ed indicizzazione. Costruzione di un array \u00b6 Nella lezione precedente abbiamo visto come sia possibile creare un array NumPy usando la funzione np.array() , che ci permette di crearlo a partire da una semplice lista: >>> a = np . array ([ 1 , 2 , 3 ]) Volendo, per\u00f2, possiamo usare anche il costruttore della classe ndarray , cui dovremo passare come minimo la shape desiderata: >>> a = np . ndarray ([ 3 , 3 ]) # oppure a = np.ndarray(shape=(3,3)) >>> a array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 3.02368175e-321 ], [ 6.69431255e+151 , 1.68534231e+246 , 6.69431467e+151 ]]) Nota I numeri con cui viene \"riempito\" l'array sono casuali, ed andranno definiti solo in seguito. Al di l\u00e0 di questi metodi base, esistono altri modi per costruire tipi di array ben specifici. Vediamoli brevemente. Costruire un array: alcuni modi alternativi \u00b6 Array con valori zero ed unitari \u00b6 Possiamo creare un array di dimensioni arbitrarie in cui tutti gli elementi sono pari ad 1. Per farlo, usiamo la funzione ones() : >>> u = np . ones ( shape = ( 3 , 3 )) >>> u array ([[ 1. , 1. , 1. ], [ 1. , 1. , 1. ], [ 1. , 1. , 1. ]]) In modo simile, possiamo creare array di dimensioni arbitrarie in cui tutti gli elementi sono pari a zero mediante la funzione zeros() : >>> z = np . zeros ( shape = ( 3 , 3 )) >>> z array ([[ 0. , 0. , 0. ], [ 0. , 0. , 0. ], [ 0. , 0. , 0. ]]) Array vuoti \u00b6 Possiamo creare un array vuoto mediante la funzione empty() : >>> e = np . empty ( shape = ( 3 , 3 )) >>> e array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 1.67982320e-321 ], [ 5.96555652e-302 , 1.14188703e-104 , 9.91401238e-278 ]]) Questa funzione pu\u00f2 risultare utile quando vogliamo preallocare spazio per un array. Nota I pi\u00f9 attenti avranno notato che, in realt\u00e0, l'array generato da empty() non \u00e8 vuoto, ma contiene valori casuali. Matrice identit\u00e0 \u00b6 Possiamo creare una matrice identit\u00e0 usando la funzione eye() : >>> i = np . eye ( 3 ) >>> i array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Attenzione In questo caso, notiamo come non si possa passare una tupla o una lista per indicare le dimensioni dell'array. Tuttavia, possiamo specificare sia il numero delle righe (con il primo parametro) che il numero delle colonne (con il secondo parametro). Matrici diagonali \u00b6 La funzione diag() viene usata sia per creare una matrice diagonale a partire da un vettore (che, ovviamente, sar\u00e0 poi la diagonale della matrice), sia per estrarre la diagonale di una matrice. Facciamo alcuni esempi. Da vettore a matrice \u00b6 Immaginiamo di avere un vettore riga a tre elementi. >>> x = np . array ([ 5 , 2 , 3 ]) >>> x array ([ 5 , 2 , 3 ]) Possiamo creare una matrice diagonale passando questo vettore come argomento alla funzione diag() : >>> d = np . diag ( x ) >>> d array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 3 ]]) Da matrice a vettore \u00b6 Affrontiamo adesso il problema duale. Immaginiamo di avere il seguente array, e volerne estrarre la diagonale: >>> x >>> x array ([[ 5 , 2 , 2 ], [ 2 , 1 , 3 ], [ 4 , 3 , 6 ]]) Per farlo, dovremo anche questa volta usare la funzione diag() , passando per\u00f2 l'array: >>> d = np . diag ( x ) >>> d array ([ 5 , 1 , 6 ]) Suggerimento Il fatto che la funzione diag() sia usata per operazioni duali pu\u00f2, a ragione, causare confusione. Basta per\u00f2 ricordare che passando un vettore si ottiene una matrice, mentre passando una matrice si ottiene un vettore, ed il gioco \u00e8 fatto. Attenzione La funzione diag() accetta solo input monodimensionali (vettori) e bidimensionali (matrici)! Matrici triangolari \u00b6 Concludiamo questa breve carrellata mostrando due metodi in grado di estrarre la matrice triangolare, rispettivamente superiore ed inferiore. Supponiamo di avere la matrice x definita in precedenza. Per estrarre la matrice triangolare superiore, dovremo usare la funzione triu() : >>> tu = np . triu ( x ) >>> tu array ([[ 5 , 2 , 2 ], [ 0 , 1 , 3 ], [ 0 , 0 , 6 ]]) Per estrarre invece la matrice triangolare inferiore, dovremo usare la funzione tril() : >>> tl = np . tril ( x ) >>> tl array ([[ 5 , 0 , 0 ], [ 2 , 1 , 0 ], [ 4 , 3 , 6 ]]) Suggerimento In questo caso, le funzioni tril() e triu() possono tranquillamente essere applicate agli array n-dimensionali. Inoltre, non \u00e8 richiesto che l'array sia quadrato. Conclusioni \u00b6 In questa lezione, abbiamo visto alcuni metodi standard per la costruzione di un array in NumPy. Nella prossima , vedremo come accedere ad uno o pi\u00f9 elementi sulla base di specifiche condizioni.","title":"Introduzione agli array"},{"location":"material/02_libs/07_numpy/07_array/lecture/#introduzione-agli-array","text":"Nella scorsa lezione , abbiamo introdotto gli array , ovvero la struttura dati \"centrale\" all'interno dell'ecosistema di NumPy. In questa lezione e nelle successive ne approfondiremo gli aspetti e le caratteristiche principali.","title":"Introduzione agli array"},{"location":"material/02_libs/07_numpy/07_array/lecture/#array-e-liste","text":"La prima impressione che si pu\u00f2 avere \u00e8 che gli array siano molto simili alle classiche liste. Esistono per\u00f2 alcune differenze, cui abbiamo gi\u00e0 accennato nella scorsa lezione. In linea di massima, per\u00f2, \u00e8 preferibile usare un array quando si ha a che fare con operazioni di tipo matematico su dati omogenei , ovvero dello stesso tipo. Questo \u00e8 collegato essenzialmente a questioni di ottimizzazione : NumPy sfrutta per le operazioni matematiche del codice precompilato in C, ed inoltre gli array sono pi\u00f9 compatti e veloci da utilizzare rispetto alle liste.","title":"Array e liste"},{"location":"material/02_libs/07_numpy/07_array/lecture/#la-classe-ndarray","text":"Alle volte, ci si pu\u00f2 riferire ad un array con il termine ndarray , abbreviazione che sta per \\(n\\) -dimensional array. Questa \u00e8, in realt\u00e0, la rappresentazione pi\u00f9 generica degli array di NumPy, e permette di caratterizzare delle strutture dati con un numero arbitrario di dimensioni ( \\(n\\) , per l'appunto). Vettori, matrici e tensori Una struttura di tipo algebrico ad \\(n\\) dimensioni, con \\(n > 2\\) , \u00e8 detta tensore . Se \\(n = 1\\) , abbiamo un vettore , mentre con \\(n = 2\\) abbiamo una matrice .","title":"La classe ndarray"},{"location":"material/02_libs/07_numpy/07_array/lecture/#creazione-ed-inizializzazione","text":"Il primo passo per utilizzare un ndarray \u00e8, ovviamente, crearlo! Per farlo, ci sono diversi metodi, ma il pi\u00f9 semplice \u00e8 sicuramente quello di passare al metodo array() di NumPy una lista di elementi. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) Possiamo passare anche una \"lista di liste\", in modo da ottenere un array multidimensionale: >>> b = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> b array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Gli array non sono necessariamente numerici. Possiamo, ad esempio, creare un array di stringhe: >>> c = np . array ([ \"s1\" , \"s2\" ]) >>> c array ([ 's1' , 's2' ], dtype = '<U2' )","title":"Creazione ed inizializzazione"},{"location":"material/02_libs/07_numpy/07_array/lecture/#array-eterogenei","text":"Abbiamo gi\u00e0 detto che gli array, a differenza delle stringhe, devono contenere dati omogenei , ovvero dello stesso tipo. Cosa succede se proviamo a passare al metodo numpy.array() una lista composta da dati di tipo differente? Facciamo un esempio. >>> d = np . array ([ 1 , 1. ]) >>> d array ([ 1. , 1. ]) Abbiamo passato al metodo array() un valore intero ed un float. Possiamo notare che \u00e8 stato effettuato un casting in maniera implicita, e tutti i valori passati sono stati convertiti in float. Vediamo cosa accade se provassimo a passare un intero ed una stringa. >>> e = np . array ([ 1 , \"s3\" ]) >>> e array ([ '1' , 's3' ], dtype = '<U11' ) Anche in questo caso, \u00e8 stata effettuata la conversione dei dati in automatico, passando stavolta da intero a stringa. La regola da tenere a mente, ad ogni modo, \u00e8 che NumPy (e, in generale, Python) seguono il principio dell' upcasting : in altre parole, quando deve essere fatta una conversione tra diversi tipi di dati, si far\u00e0 in modo da convertire tutte le variabili nel tipo a pi\u00f9 alta precisione , allo scopo di evitare perdite di informazioni.","title":"Array eterogenei"},{"location":"material/02_libs/07_numpy/07_array/lecture/#il-numero-di-elementi-di-un-array","text":"Abbiamo detto che un array \u00e8 un \"contenitore\", a dimensione prefissata, per oggetti di un ben determinato tipo e dimensione. Il numero di dimensioni e gli oggetti contenuti all'interno di un array sono definiti a partire da una propriet\u00e0 chiamata shape , liberamente traducibile in \"forma\". Quest'ultima \u00e8 una tupla di numeri interi, ovviamente non negativi, che permette di determinare la dimensionalit\u00e0 dell'array lungo ogni asse (ovvero \\(x\\) , \\(y\\) , \\(z\\) , etc.). Ad esempio, potremo dire che il seguente array bidimensionale ha due assi, il primo di lunghezza due, il secondo di lunghezza tre: >>> a = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]]) >>> a array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Proviamo a valutare la propriet\u00e0 shape del precedente array: >>> a . shape ( 2 , 3 )","title":"Il numero di elementi di un array"},{"location":"material/02_libs/07_numpy/07_array/lecture/#conclusioni","text":"In questa lezione, abbiamo dato una breve panoramica introduttiva sugli array. Nella prossima lezione , approfondiremo ulteriormente le loro modalit\u00e0 di creazione ed indicizzazione.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/07_array/lecture/#costruzione-di-un-array","text":"Nella lezione precedente abbiamo visto come sia possibile creare un array NumPy usando la funzione np.array() , che ci permette di crearlo a partire da una semplice lista: >>> a = np . array ([ 1 , 2 , 3 ]) Volendo, per\u00f2, possiamo usare anche il costruttore della classe ndarray , cui dovremo passare come minimo la shape desiderata: >>> a = np . ndarray ([ 3 , 3 ]) # oppure a = np.ndarray(shape=(3,3)) >>> a array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 3.02368175e-321 ], [ 6.69431255e+151 , 1.68534231e+246 , 6.69431467e+151 ]]) Nota I numeri con cui viene \"riempito\" l'array sono casuali, ed andranno definiti solo in seguito. Al di l\u00e0 di questi metodi base, esistono altri modi per costruire tipi di array ben specifici. Vediamoli brevemente.","title":"Costruzione di un array"},{"location":"material/02_libs/07_numpy/07_array/lecture/#costruire-un-array-alcuni-modi-alternativi","text":"","title":"Costruire un array: alcuni modi alternativi"},{"location":"material/02_libs/07_numpy/07_array/lecture/#array-con-valori-zero-ed-unitari","text":"Possiamo creare un array di dimensioni arbitrarie in cui tutti gli elementi sono pari ad 1. Per farlo, usiamo la funzione ones() : >>> u = np . ones ( shape = ( 3 , 3 )) >>> u array ([[ 1. , 1. , 1. ], [ 1. , 1. , 1. ], [ 1. , 1. , 1. ]]) In modo simile, possiamo creare array di dimensioni arbitrarie in cui tutti gli elementi sono pari a zero mediante la funzione zeros() : >>> z = np . zeros ( shape = ( 3 , 3 )) >>> z array ([[ 0. , 0. , 0. ], [ 0. , 0. , 0. ], [ 0. , 0. , 0. ]])","title":"Array con valori zero ed unitari"},{"location":"material/02_libs/07_numpy/07_array/lecture/#array-vuoti","text":"Possiamo creare un array vuoto mediante la funzione empty() : >>> e = np . empty ( shape = ( 3 , 3 )) >>> e array ([[ 0.00000000e+000 , 0.00000000e+000 , 0.00000000e+000 ], [ 0.00000000e+000 , 0.00000000e+000 , 1.67982320e-321 ], [ 5.96555652e-302 , 1.14188703e-104 , 9.91401238e-278 ]]) Questa funzione pu\u00f2 risultare utile quando vogliamo preallocare spazio per un array. Nota I pi\u00f9 attenti avranno notato che, in realt\u00e0, l'array generato da empty() non \u00e8 vuoto, ma contiene valori casuali.","title":"Array vuoti"},{"location":"material/02_libs/07_numpy/07_array/lecture/#matrice-identita","text":"Possiamo creare una matrice identit\u00e0 usando la funzione eye() : >>> i = np . eye ( 3 ) >>> i array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Attenzione In questo caso, notiamo come non si possa passare una tupla o una lista per indicare le dimensioni dell'array. Tuttavia, possiamo specificare sia il numero delle righe (con il primo parametro) che il numero delle colonne (con il secondo parametro).","title":"Matrice identit\u00e0"},{"location":"material/02_libs/07_numpy/07_array/lecture/#matrici-diagonali","text":"La funzione diag() viene usata sia per creare una matrice diagonale a partire da un vettore (che, ovviamente, sar\u00e0 poi la diagonale della matrice), sia per estrarre la diagonale di una matrice. Facciamo alcuni esempi.","title":"Matrici diagonali"},{"location":"material/02_libs/07_numpy/07_array/lecture/#da-vettore-a-matrice","text":"Immaginiamo di avere un vettore riga a tre elementi. >>> x = np . array ([ 5 , 2 , 3 ]) >>> x array ([ 5 , 2 , 3 ]) Possiamo creare una matrice diagonale passando questo vettore come argomento alla funzione diag() : >>> d = np . diag ( x ) >>> d array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 3 ]])","title":"Da vettore a matrice"},{"location":"material/02_libs/07_numpy/07_array/lecture/#da-matrice-a-vettore","text":"Affrontiamo adesso il problema duale. Immaginiamo di avere il seguente array, e volerne estrarre la diagonale: >>> x >>> x array ([[ 5 , 2 , 2 ], [ 2 , 1 , 3 ], [ 4 , 3 , 6 ]]) Per farlo, dovremo anche questa volta usare la funzione diag() , passando per\u00f2 l'array: >>> d = np . diag ( x ) >>> d array ([ 5 , 1 , 6 ]) Suggerimento Il fatto che la funzione diag() sia usata per operazioni duali pu\u00f2, a ragione, causare confusione. Basta per\u00f2 ricordare che passando un vettore si ottiene una matrice, mentre passando una matrice si ottiene un vettore, ed il gioco \u00e8 fatto. Attenzione La funzione diag() accetta solo input monodimensionali (vettori) e bidimensionali (matrici)!","title":"Da matrice a vettore"},{"location":"material/02_libs/07_numpy/07_array/lecture/#matrici-triangolari","text":"Concludiamo questa breve carrellata mostrando due metodi in grado di estrarre la matrice triangolare, rispettivamente superiore ed inferiore. Supponiamo di avere la matrice x definita in precedenza. Per estrarre la matrice triangolare superiore, dovremo usare la funzione triu() : >>> tu = np . triu ( x ) >>> tu array ([[ 5 , 2 , 2 ], [ 0 , 1 , 3 ], [ 0 , 0 , 6 ]]) Per estrarre invece la matrice triangolare inferiore, dovremo usare la funzione tril() : >>> tl = np . tril ( x ) >>> tl array ([[ 5 , 0 , 0 ], [ 2 , 1 , 0 ], [ 4 , 3 , 6 ]]) Suggerimento In questo caso, le funzioni tril() e triu() possono tranquillamente essere applicate agli array n-dimensionali. Inoltre, non \u00e8 richiesto che l'array sia quadrato.","title":"Matrici triangolari"},{"location":"material/02_libs/07_numpy/07_array/lecture/#conclusioni_1","text":"In questa lezione, abbiamo visto alcuni metodi standard per la costruzione di un array in NumPy. Nella prossima , vedremo come accedere ad uno o pi\u00f9 elementi sulla base di specifiche condizioni.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/","text":"Accedere agli elementi di un array \u00b6 Il modo pi\u00f9 immediato per accedere al valore di un elemento in un array \u00e8 usare l'operatore [] , specificando contestualmente l'indice dell'elemento cui si vuole accedere, proprio come avviene per le liste. Ad esempio, possiamo selezionare il primo elemento di un array con questa sintassi: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 ] 1 Nel caso di array ad \\(n\\) dimensioni, \u00e8 necessario indicare l'indice per ciascuna delle dimensioni dell'array. Nel caso di un array bidimensionale, potremmo selezionare l'elemento alla prima riga e prima colonna con una sintassi di questo tipo: >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 ][ 0 ] 1 Maschere booleane \u00b6 Possiamo accedere ad un sottoinsieme di elementi dell'array mediante una \"maschera\", che consiste in un array di dimensioni uguali a quelle di partenza, ma composto soltanto da valori booleani; ovviamente, saranno estratti solo gli elementi il cui indice nella maschera \u00e8 a True . Ad esempio, possiamo selezionare tutti gli elementi appartenenti alla prima colonna dell'array b : >>> mask = ([ True , False ], [ True , False ]) >>> b [ mask ] array ([ 1 , 3 ]) Oppure possiamo scegliere tutti gli elementi che soddisfano una certa condizione logico/matematica: >>> mask = ( b > 2 ) >>> mask array ([[ False , False ], [ True , True ]]) >>> b [ mask ] array ([ 3 , 4 ]) La precedente notazione pu\u00f2 essere ulteriormente sintetizzata \"prendendo in prestito\" i principi della programmazione funzionale: >>> b [ b > 2 ] array ([ 3 , 4 ]) Volendo, possiamo adattare la forma precedente all'uso di espressioni arbitrariamente complesse: >>> b [ b % 2 == 0 ] array ([ 2 , 4 ]) >>> b [( b > 1 ) & ( b < 4 )] array ([ 2 , 3 ]) Slicing degli array \u00b6 Cos\u00ec come le liste, gli array consentono di effettuare lo slicing: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 : 2 ] array ([ 1 , 2 ]) Per gli array multidimensionali, lo slicing si intende sulla n-ma dimensione dell'array. Questo concetto \u00e8 facile da comprendere se si visualizza l'array ad n-dimensioni come un array di array: >>> b array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 : 1 ] # Lo slicing avviene sulla seconda dimensione array ([[ 1 , 2 ]]) La funzione nonzero() \u00b6 Possiamo usare la funzione nonzero() per selezionare gli elementi e gli indici di un array il cui valore non sia pari a zero. Ad esempio: >>> x = np . array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) >>> x array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) Applicando la funzione nonzero() , avremo una tupla con gli indici per riga e colonna degli elementi diversi da zero: >>> np . nonzero ( x ) ( array ([ 0 , 1 , 2 , 2 ], dtype = int64 ), array ([ 0 , 1 , 0 , 1 ], dtype = int64 )) Notiamo che nella tupla \u00e8 presente un array per ciascuna delle dimensioni dell'array x . In questo caso, il primo array rappresenta gli indici relativi alla prima dimensione dei valori non nulli (in questo caso, gli indici di riga), mentre il secondo gli indici relativi alla seconda dimensione (indici di colonna). Volendo, \u00e8 possibile ottenere una lista di tuple rappresentative delle coppie di indici rappresentative dei valori non nulli, ad esempio mediante la funzione zip() : >>> coords = list ( zip ( s [ 0 ], s [ 1 ])) >>> coords [( 0 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 )] Fancy indexing \u00b6 Una tecnica estremamente interessante \u00e8 quella del fancy indexing . Concettualmente, questa indicizzazione prevede che venga passato un array di indici, in modo da accedere a pi\u00f9 elementi di un array contemporaneamente. Facciamo un esempio. >>> rand = np . random . RandomState ( 42 ) >>> x = rand . randint ( 100 , size = 10 ) >>> indexes = np . array ([[ 1 , 4 ],[ 5 , 2 ]]) >>> x array ([ 51 , 92 , 14 , 71 , 60 , 20 , 82 , 86 , 74 , 74 ]) >>> x [ indexes ] array ([[ 92 , 60 ], [ 20 , 14 ]]) Nel codice precedente, stiamo: usando la funzione randint per generare un array di numeri interi casuali compresi tra 0 e 100; generando un array bidimensionale indexes ; restituendo, mediante il fancy indexing, un array con le dimensioni di indexes e gli elementi di x presi nelle posizioni indicate da indexes . La potenza del fancy indexing sta proprio in questo: non solo siamo in grado di accedere facilmente a pi\u00f9 elementi di un array mediante un'unica operazione, ma possiamo anche ridisporre questi elementi come pi\u00f9 ci aggrada!","title":"Accedere agli elementi di un array"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/#accedere-agli-elementi-di-un-array","text":"Il modo pi\u00f9 immediato per accedere al valore di un elemento in un array \u00e8 usare l'operatore [] , specificando contestualmente l'indice dell'elemento cui si vuole accedere, proprio come avviene per le liste. Ad esempio, possiamo selezionare il primo elemento di un array con questa sintassi: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 ] 1 Nel caso di array ad \\(n\\) dimensioni, \u00e8 necessario indicare l'indice per ciascuna delle dimensioni dell'array. Nel caso di un array bidimensionale, potremmo selezionare l'elemento alla prima riga e prima colonna con una sintassi di questo tipo: >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 ][ 0 ] 1","title":"Accedere agli elementi di un array"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/#maschere-booleane","text":"Possiamo accedere ad un sottoinsieme di elementi dell'array mediante una \"maschera\", che consiste in un array di dimensioni uguali a quelle di partenza, ma composto soltanto da valori booleani; ovviamente, saranno estratti solo gli elementi il cui indice nella maschera \u00e8 a True . Ad esempio, possiamo selezionare tutti gli elementi appartenenti alla prima colonna dell'array b : >>> mask = ([ True , False ], [ True , False ]) >>> b [ mask ] array ([ 1 , 3 ]) Oppure possiamo scegliere tutti gli elementi che soddisfano una certa condizione logico/matematica: >>> mask = ( b > 2 ) >>> mask array ([[ False , False ], [ True , True ]]) >>> b [ mask ] array ([ 3 , 4 ]) La precedente notazione pu\u00f2 essere ulteriormente sintetizzata \"prendendo in prestito\" i principi della programmazione funzionale: >>> b [ b > 2 ] array ([ 3 , 4 ]) Volendo, possiamo adattare la forma precedente all'uso di espressioni arbitrariamente complesse: >>> b [ b % 2 == 0 ] array ([ 2 , 4 ]) >>> b [( b > 1 ) & ( b < 4 )] array ([ 2 , 3 ])","title":"Maschere booleane"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/#slicing-degli-array","text":"Cos\u00ec come le liste, gli array consentono di effettuare lo slicing: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a [ 0 : 2 ] array ([ 1 , 2 ]) Per gli array multidimensionali, lo slicing si intende sulla n-ma dimensione dell'array. Questo concetto \u00e8 facile da comprendere se si visualizza l'array ad n-dimensioni come un array di array: >>> b array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b [ 0 : 1 ] # Lo slicing avviene sulla seconda dimensione array ([[ 1 , 2 ]])","title":"Slicing degli array"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/#la-funzione-nonzero","text":"Possiamo usare la funzione nonzero() per selezionare gli elementi e gli indici di un array il cui valore non sia pari a zero. Ad esempio: >>> x = np . array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) >>> x array ([[ 3 , 0 , 0 ], [ 0 , 4 , 0 ], [ 5 , 6 , 0 ]]) Applicando la funzione nonzero() , avremo una tupla con gli indici per riga e colonna degli elementi diversi da zero: >>> np . nonzero ( x ) ( array ([ 0 , 1 , 2 , 2 ], dtype = int64 ), array ([ 0 , 1 , 0 , 1 ], dtype = int64 )) Notiamo che nella tupla \u00e8 presente un array per ciascuna delle dimensioni dell'array x . In questo caso, il primo array rappresenta gli indici relativi alla prima dimensione dei valori non nulli (in questo caso, gli indici di riga), mentre il secondo gli indici relativi alla seconda dimensione (indici di colonna). Volendo, \u00e8 possibile ottenere una lista di tuple rappresentative delle coppie di indici rappresentative dei valori non nulli, ad esempio mediante la funzione zip() : >>> coords = list ( zip ( s [ 0 ], s [ 1 ])) >>> coords [( 0 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 )]","title":"La funzione nonzero()"},{"location":"material/02_libs/07_numpy/08_indexing/lecture/#fancy-indexing","text":"Una tecnica estremamente interessante \u00e8 quella del fancy indexing . Concettualmente, questa indicizzazione prevede che venga passato un array di indici, in modo da accedere a pi\u00f9 elementi di un array contemporaneamente. Facciamo un esempio. >>> rand = np . random . RandomState ( 42 ) >>> x = rand . randint ( 100 , size = 10 ) >>> indexes = np . array ([[ 1 , 4 ],[ 5 , 2 ]]) >>> x array ([ 51 , 92 , 14 , 71 , 60 , 20 , 82 , 86 , 74 , 74 ]) >>> x [ indexes ] array ([[ 92 , 60 ], [ 20 , 14 ]]) Nel codice precedente, stiamo: usando la funzione randint per generare un array di numeri interi casuali compresi tra 0 e 100; generando un array bidimensionale indexes ; restituendo, mediante il fancy indexing, un array con le dimensioni di indexes e gli elementi di x presi nelle posizioni indicate da indexes . La potenza del fancy indexing sta proprio in questo: non solo siamo in grado di accedere facilmente a pi\u00f9 elementi di un array mediante un'unica operazione, ma possiamo anche ridisporre questi elementi come pi\u00f9 ci aggrada!","title":"Fancy indexing"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/","text":"Operare sugli array \u00b6 NumPy offre numerose modalit\u00e0 per operare sugli array e manipolarli. Vediamone alcune. Operazioni algebriche di base \u00b6 Possiamo usare due array per effettuare diversi tipi di operazioni algebriche di base. Ad esempio, per sommare due array: >>> a = np . array ([ 1 , 2 ]) >>> b = np . array ([ 3 , 4 ]) >>> a + b array ([ 4 , 6 ]) Possiamo ovviamente anche fare le altre operazioni fondamentali: >>> a - b array ([ - 2 , - 2 ]) >>> a * b array ([ 3 , 8 ]) >>> a / b array ([ 0.33333333 , 0.5 ]) >>> b / a array ([ 3. , 2. ]) Moltiplicazione e divisione Per comprendere appieno il comportamento degli operatori * e /, dovremo parlare del broadcasting. Lo faremo in una delle prossime lezioni. La funzione sum \u00b6 La funzione sum(axis=None) ci permette di sommare tutti gli elementi di un array lungo l'asse specificato. Ad esempio, per sommare tutti gli elementi di un vettore: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a . sum () 10 In caso di array multidimensionale, dovremo specificare, come gi\u00e0 detto, l'asse. Ad esempio, per sommare gli elementi per colonna, dovremo passare il parametro 0 : >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b . sum ( axis = 0 ) array ([ 4 , 6 ]) Per sommare gli elementi per riga, invece, dovremo passare il parametro 1 : >>> b . sum ( axis = 1 ) array ([ 3 , 7 ]) La funzione dot() \u00b6 La funzione dot() ci permette di effettuare l'operazione di moltiplicazione matriciale standard: >>> a = np . array ([[ 1 , 2 ]]) >>> b = np . array ([[ 3 ], [ 4 ]]) >>> a . dot ( b ) array ([ 11 ]) >>> b . dot ( a ) array ([[ 3 , 6 ], [ 4 , 8 ]]) Ordinamento degli elementi di un array \u00b6 Ordinare gli elementi di un array \u00e8 possibile usando la funzione sort() . Ad esempio: >>> arr = np . array ([ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ]) >>> np . sort ( arr ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) L'ordine avviene, di default, in maniera ascendente . In caso di array n-dimensionale, possiamo anche specificare l'asse lungo il quale avviene l'ordinamento, specificando il parametro axis. Ad esempio: >>> mat = np . array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) >>> mat array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) Per ordinare lungo le colonne: >>> np . sort ( mat , axis = 0 ) array ([[ 2 , 2 , 1 ], [ 4 , 3 , 1 ], [ 7 , 5 , 6 ]]) Mentre per ordinare lungo le righe: >>> np . sort ( mat , axis = 1 ) array ([[ 1 , 2 , 3 ], [ 2 , 4 , 6 ], [ 1 , 5 , 7 ]]) Nota Esistono anche altre funzioni per l'ordinamento di un array, che per\u00f2 non tratteremo in questo corso. Concatenazione di pi\u00f9 array \u00b6 Possiamo concatenare due array usando la funzione concatenate() : >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> b = np . array ([ 5 , 6 , 7 , 8 ]) >>> np . concatenate (( a , b )) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) Si pu\u00f2 anche in questo caso usare il parametro axis per specificare l'asse lungo quale concatenare due diversi array: >>> x = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> y = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 1 ) array ([[ 1 , 2 , 5 , 6 ], [ 3 , 4 , 7 , 8 ]]) Ovviamente, le dimensioni degli array devono essere coerenti affinch\u00e9 vengano concatenati. Ad esempio, con questo array: >>> z = np . array ([[ 9 , 10 ]]) la concatenazione per righe \u00e8 ammissibile: >>> np . concatenate (( x , z ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 9 , 10 ]]) mentre la concatenazione per colonne non \u00e8 possibile: >>> np . concatenate (( x , z ), axis = 1 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<__array_function__ internals>\" , line 5 , in concatenate ValueError : all the input array dimensions for the concatenation axis must match exactly , but along dimension 0 , the array at index 0 has size 2 and the array at index 1 has size 1 Rimozione ed inserimento di elementi in un array \u00b6 La funzione delete \u00b6 La funzione delete(arr, obj, axis=None) ci permette di rimuovere uno o pi\u00f9 elementi di un array specificandone gli indici. La funzione accetta i seguenti parametri: arr : l'array sul quale vogliamo effettuare l'operazione di rimozione; obj : gli indici degli elementi da rimuovere; axis : l'asse su cui vogliamo operare. Ad esempio, immaginiamo di voler rimuovere il primo elemento di un vettore: >>> arr = np . array ([ 1 , 2 , 3 , 4 ]) >>> np . delete ( arr , 0 ) array ([ 2 , 3 , 4 ]) >>> arr La funzione pu\u00f2 essere anche applicata su pi\u00f9 indici usando una sequenza: >>> np . delete ( arr , range ( 2 )) array ([ 3 , 4 ]) Possiamo anche usare lo slicing: >>> idx = range ( 4 ) >>> np . delete ( arr , idx [ 0 : 2 ]) array ([ 3 , 4 ]) Suggerimento La precedente notazione pu\u00f2 essere rimpiazzata dalla funzione slice(start, stop, step) , che crea un oggetto di classe slice sugli indici che vanno da start a stop con passo step . Questo pu\u00f2 essere usato per scopi analoghi ai precedenti; ad esempio: >>> np . delete ( a , slice ( 0 , 2 , 1 )) array ([ 3 , 4 ]) Array multidimensionali \u00b6 La funzione pu\u00f2 essere usata anche su array multidimensionali. In questo caso, \u00e8 opportuno specificare l'asse su cui operare. Ad esempio, se vogliamo rimuovere la prima riga dal seguente array, dobbiamo dare il valore 0 al parametro axis : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) >>> np . delete ( mat , 0 , 0 ) array ([[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) Invece, se vogliamo rimuovere la prima colonna, dobbiamo passare il valore 1 : >>> np . delete ( mat , 0 , 1 ) array ([[ 2 , 3 ], [ 5 , 6 ], [ 8 , 9 ]]) Se non specificassimo alcun valore per il parametro axis , otterremmo questo risultato: >>> np . delete ( mat , 0 ) array ([ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Cosa \u00e8 accaduto? In pratica, \u00e8 stato rimosso il primo elemento dell'array vettorizzato ( flattened ). Rimozione di elementi mediante maschere booleane \u00b6 Spesso \u00e8 preferibile usare, al posto della notazione precedente, una maschera booleana: >>> mask = [ False , False , True , True ] >>> arr [ mask ] array ([ 3 , 4 ]) La funzione insert \u00b6 La funzione insert(arr, obj, values, axis=None) permette di inserire un elemento all'interno di un array. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; obj : gli indici su cui inserire i nuovi valori; values : i valori da inserire agli indici specificati da obj ; axis : l'asse su cui vogliamo operare. Ad esempio, per inserire una nuova riga nella matrice precedente, dovremo specificare l'indice di riga ( 3 ), gli elementi della riga da inserire ( [10, 11, 12] ) e l'asse ( 0 ): >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Cambiando l'asse in 1 , si effettua l'inserzione sulle colonne: >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Non specificando alcun asse, infine, si inserisce l'elemento specificato nella matrice vettorizzata: >>> np . insert ( mat , 9 , 10 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) La funzione append \u00b6 La funzione append(arr, values, axis=None) permette di inserire in coda ad un array i valori specificati. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; values : i valori da inserire in coda all'array; axis : l'asse su cui vogliamo operare. Al solito, non specificando l'asse effettuiamo la concatenazione sulla matrice vettorizzata: >>> np . append ( mat , [[ 10 , 11 , 12 ]]) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ]) Se specifichiamo il valore 0 sul parametro axis , effettuiamo la concatenazione per righe: >>> np . append ( mat , [[ 10 , 11 , 12 ]], axis = 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Se specifichiamo il valore 1 sul parametro axis , invece, effettuiamo la concatenazione per colonne: >>> np . append ( mat , [[ 10 ], [ 11 ], [ 12 ]], axis = 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Attenzione Nell'ultima istruzione, abbiamo usato un vettore colonna , mentre nella penultima un vettore riga . Dimensioni e forma di un array \u00b6 Esistono diverse propriet\u00e0 di un array che ne descrivono dimensioni e forma. Tornando alla nostra matrice mat , possiamo conoscere il numero di assi mediante l'attributo ndarray.ndim : >>> mat . ndim 2 Il numero di elementi \u00e8 invece definito dall'attributo ndarray.size : >>> mat . size 9 L'attributo ndarray.shape restituisce invece una tupla di interi che indica il numero di elementi per ciascuno degli assi dell'array: >>> mat . shape ( 3 , 3 ) Modificare le dimensioni di un array \u00b6 Possiamo modificare le dimensioni di un array mediante la funzione reshape(arr, new_shape) . I parametri passati alla funzione sono: arr : l'array di cui modificare le dimensioni; new_shape : le nuove dimensioni dell'array. Se volessimo modificare le dimensioni di una matrice da \\(4 \\times 4\\) a \\(2 \\times 8\\) , potremmo usare la funzione reshape come segue: >>> mat = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ], [ 13 , 14 , 15 , 16 ]]) >>> np . reshape ( mat , ( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Suggerimento Una forma alternativa \u00e8 la seguente: >>> mat . reshape (( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Ci\u00f2 significa che la funzione reshape \u00e8 sia disponibile nella libreria NumPy, sia come metodo sugli oggetti di classe ndarray . Attenzione Le nuove dimensioni dell'array devono essere coerenti con quelle dell'array di partenza! Flattening (o vettorizzazione) \u00b6 Abbiamo gi\u00e0 visto in precedenza la vettorizzazione di un array, effettuata in automatico in alcune situazioni (come ad esempio la chiamata di delete o insert senza specificare il parametro axis ). Tuttavia, possiamo usare la funzione flatten per effettuare manualmente questa operazione: >>> mat . flatten () array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Conclusioni \u00b6 In questa lezione, abbiamo visto alcuni fondamentali modi di manipolare un array che NumPy ci mette a disposizione. Nella prossima , parleremo pi\u00f9 in dettaglio delle operazioni algebriche.","title":"Operare sugli array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#operare-sugli-array","text":"NumPy offre numerose modalit\u00e0 per operare sugli array e manipolarli. Vediamone alcune.","title":"Operare sugli array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#operazioni-algebriche-di-base","text":"Possiamo usare due array per effettuare diversi tipi di operazioni algebriche di base. Ad esempio, per sommare due array: >>> a = np . array ([ 1 , 2 ]) >>> b = np . array ([ 3 , 4 ]) >>> a + b array ([ 4 , 6 ]) Possiamo ovviamente anche fare le altre operazioni fondamentali: >>> a - b array ([ - 2 , - 2 ]) >>> a * b array ([ 3 , 8 ]) >>> a / b array ([ 0.33333333 , 0.5 ]) >>> b / a array ([ 3. , 2. ]) Moltiplicazione e divisione Per comprendere appieno il comportamento degli operatori * e /, dovremo parlare del broadcasting. Lo faremo in una delle prossime lezioni.","title":"Operazioni algebriche di base"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#la-funzione-sum","text":"La funzione sum(axis=None) ci permette di sommare tutti gli elementi di un array lungo l'asse specificato. Ad esempio, per sommare tutti gli elementi di un vettore: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> a . sum () 10 In caso di array multidimensionale, dovremo specificare, come gi\u00e0 detto, l'asse. Ad esempio, per sommare gli elementi per colonna, dovremo passare il parametro 0 : >>> b = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b . sum ( axis = 0 ) array ([ 4 , 6 ]) Per sommare gli elementi per riga, invece, dovremo passare il parametro 1 : >>> b . sum ( axis = 1 ) array ([ 3 , 7 ])","title":"La funzione sum"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#la-funzione-dot","text":"La funzione dot() ci permette di effettuare l'operazione di moltiplicazione matriciale standard: >>> a = np . array ([[ 1 , 2 ]]) >>> b = np . array ([[ 3 ], [ 4 ]]) >>> a . dot ( b ) array ([ 11 ]) >>> b . dot ( a ) array ([[ 3 , 6 ], [ 4 , 8 ]])","title":"La funzione dot()"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#ordinamento-degli-elementi-di-un-array","text":"Ordinare gli elementi di un array \u00e8 possibile usando la funzione sort() . Ad esempio: >>> arr = np . array ([ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ]) >>> np . sort ( arr ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) L'ordine avviene, di default, in maniera ascendente . In caso di array n-dimensionale, possiamo anche specificare l'asse lungo il quale avviene l'ordinamento, specificando il parametro axis. Ad esempio: >>> mat = np . array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) >>> mat array ([[ 2 , 3 , 1 ], [ 4 , 2 , 6 ], [ 7 , 5 , 1 ]]) Per ordinare lungo le colonne: >>> np . sort ( mat , axis = 0 ) array ([[ 2 , 2 , 1 ], [ 4 , 3 , 1 ], [ 7 , 5 , 6 ]]) Mentre per ordinare lungo le righe: >>> np . sort ( mat , axis = 1 ) array ([[ 1 , 2 , 3 ], [ 2 , 4 , 6 ], [ 1 , 5 , 7 ]]) Nota Esistono anche altre funzioni per l'ordinamento di un array, che per\u00f2 non tratteremo in questo corso.","title":"Ordinamento degli elementi di un array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#concatenazione-di-piu-array","text":"Possiamo concatenare due array usando la funzione concatenate() : >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> b = np . array ([ 5 , 6 , 7 , 8 ]) >>> np . concatenate (( a , b )) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) Si pu\u00f2 anche in questo caso usare il parametro axis per specificare l'asse lungo quale concatenare due diversi array: >>> x = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> y = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ]]) >>> np . concatenate (( x , y ), axis = 1 ) array ([[ 1 , 2 , 5 , 6 ], [ 3 , 4 , 7 , 8 ]]) Ovviamente, le dimensioni degli array devono essere coerenti affinch\u00e9 vengano concatenati. Ad esempio, con questo array: >>> z = np . array ([[ 9 , 10 ]]) la concatenazione per righe \u00e8 ammissibile: >>> np . concatenate (( x , z ), axis = 0 ) array ([[ 1 , 2 ], [ 3 , 4 ], [ 9 , 10 ]]) mentre la concatenazione per colonne non \u00e8 possibile: >>> np . concatenate (( x , z ), axis = 1 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<__array_function__ internals>\" , line 5 , in concatenate ValueError : all the input array dimensions for the concatenation axis must match exactly , but along dimension 0 , the array at index 0 has size 2 and the array at index 1 has size 1","title":"Concatenazione di pi\u00f9 array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#rimozione-ed-inserimento-di-elementi-in-un-array","text":"","title":"Rimozione ed inserimento di elementi in un array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#la-funzione-delete","text":"La funzione delete(arr, obj, axis=None) ci permette di rimuovere uno o pi\u00f9 elementi di un array specificandone gli indici. La funzione accetta i seguenti parametri: arr : l'array sul quale vogliamo effettuare l'operazione di rimozione; obj : gli indici degli elementi da rimuovere; axis : l'asse su cui vogliamo operare. Ad esempio, immaginiamo di voler rimuovere il primo elemento di un vettore: >>> arr = np . array ([ 1 , 2 , 3 , 4 ]) >>> np . delete ( arr , 0 ) array ([ 2 , 3 , 4 ]) >>> arr La funzione pu\u00f2 essere anche applicata su pi\u00f9 indici usando una sequenza: >>> np . delete ( arr , range ( 2 )) array ([ 3 , 4 ]) Possiamo anche usare lo slicing: >>> idx = range ( 4 ) >>> np . delete ( arr , idx [ 0 : 2 ]) array ([ 3 , 4 ]) Suggerimento La precedente notazione pu\u00f2 essere rimpiazzata dalla funzione slice(start, stop, step) , che crea un oggetto di classe slice sugli indici che vanno da start a stop con passo step . Questo pu\u00f2 essere usato per scopi analoghi ai precedenti; ad esempio: >>> np . delete ( a , slice ( 0 , 2 , 1 )) array ([ 3 , 4 ])","title":"La funzione delete"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#array-multidimensionali","text":"La funzione pu\u00f2 essere usata anche su array multidimensionali. In questo caso, \u00e8 opportuno specificare l'asse su cui operare. Ad esempio, se vogliamo rimuovere la prima riga dal seguente array, dobbiamo dare il valore 0 al parametro axis : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) >>> np . delete ( mat , 0 , 0 ) array ([[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) Invece, se vogliamo rimuovere la prima colonna, dobbiamo passare il valore 1 : >>> np . delete ( mat , 0 , 1 ) array ([[ 2 , 3 ], [ 5 , 6 ], [ 8 , 9 ]]) Se non specificassimo alcun valore per il parametro axis , otterremmo questo risultato: >>> np . delete ( mat , 0 ) array ([ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) Cosa \u00e8 accaduto? In pratica, \u00e8 stato rimosso il primo elemento dell'array vettorizzato ( flattened ).","title":"Array multidimensionali"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#rimozione-di-elementi-mediante-maschere-booleane","text":"Spesso \u00e8 preferibile usare, al posto della notazione precedente, una maschera booleana: >>> mask = [ False , False , True , True ] >>> arr [ mask ] array ([ 3 , 4 ])","title":"Rimozione di elementi mediante maschere booleane"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#la-funzione-insert","text":"La funzione insert(arr, obj, values, axis=None) permette di inserire un elemento all'interno di un array. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; obj : gli indici su cui inserire i nuovi valori; values : i valori da inserire agli indici specificati da obj ; axis : l'asse su cui vogliamo operare. Ad esempio, per inserire una nuova riga nella matrice precedente, dovremo specificare l'indice di riga ( 3 ), gli elementi della riga da inserire ( [10, 11, 12] ) e l'asse ( 0 ): >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Cambiando l'asse in 1 , si effettua l'inserzione sulle colonne: >>> np . insert ( mat , 3 , [ 10 , 11 , 12 ], 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Non specificando alcun asse, infine, si inserisce l'elemento specificato nella matrice vettorizzata: >>> np . insert ( mat , 9 , 10 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ])","title":"La funzione insert"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#la-funzione-append","text":"La funzione append(arr, values, axis=None) permette di inserire in coda ad un array i valori specificati. I parametri accettati dalla funzione sono: arr : l'array sul quale vogliamo effettuare l'operazione di inserzione; values : i valori da inserire in coda all'array; axis : l'asse su cui vogliamo operare. Al solito, non specificando l'asse effettuiamo la concatenazione sulla matrice vettorizzata: >>> np . append ( mat , [[ 10 , 11 , 12 ]]) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ]) Se specifichiamo il valore 0 sul parametro axis , effettuiamo la concatenazione per righe: >>> np . append ( mat , [[ 10 , 11 , 12 ]], axis = 0 ) array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ], [ 7 , 8 , 9 ], [ 10 , 11 , 12 ]]) Se specifichiamo il valore 1 sul parametro axis , invece, effettuiamo la concatenazione per colonne: >>> np . append ( mat , [[ 10 ], [ 11 ], [ 12 ]], axis = 1 ) array ([[ 1 , 2 , 3 , 10 ], [ 4 , 5 , 6 , 11 ], [ 7 , 8 , 9 , 12 ]]) Attenzione Nell'ultima istruzione, abbiamo usato un vettore colonna , mentre nella penultima un vettore riga .","title":"La funzione append"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#dimensioni-e-forma-di-un-array","text":"Esistono diverse propriet\u00e0 di un array che ne descrivono dimensioni e forma. Tornando alla nostra matrice mat , possiamo conoscere il numero di assi mediante l'attributo ndarray.ndim : >>> mat . ndim 2 Il numero di elementi \u00e8 invece definito dall'attributo ndarray.size : >>> mat . size 9 L'attributo ndarray.shape restituisce invece una tupla di interi che indica il numero di elementi per ciascuno degli assi dell'array: >>> mat . shape ( 3 , 3 )","title":"Dimensioni e forma di un array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#modificare-le-dimensioni-di-un-array","text":"Possiamo modificare le dimensioni di un array mediante la funzione reshape(arr, new_shape) . I parametri passati alla funzione sono: arr : l'array di cui modificare le dimensioni; new_shape : le nuove dimensioni dell'array. Se volessimo modificare le dimensioni di una matrice da \\(4 \\times 4\\) a \\(2 \\times 8\\) , potremmo usare la funzione reshape come segue: >>> mat = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ], [ 13 , 14 , 15 , 16 ]]) >>> np . reshape ( mat , ( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Suggerimento Una forma alternativa \u00e8 la seguente: >>> mat . reshape (( 2 , 8 )) array ([[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ]]) Ci\u00f2 significa che la funzione reshape \u00e8 sia disponibile nella libreria NumPy, sia come metodo sugli oggetti di classe ndarray . Attenzione Le nuove dimensioni dell'array devono essere coerenti con quelle dell'array di partenza!","title":"Modificare le dimensioni di un array"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#flattening-o-vettorizzazione","text":"Abbiamo gi\u00e0 visto in precedenza la vettorizzazione di un array, effettuata in automatico in alcune situazioni (come ad esempio la chiamata di delete o insert senza specificare il parametro axis ). Tuttavia, possiamo usare la funzione flatten per effettuare manualmente questa operazione: >>> mat . flatten () array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ])","title":"Flattening (o vettorizzazione)"},{"location":"material/02_libs/07_numpy/09_arithmetics/lecture/#conclusioni","text":"In questa lezione, abbiamo visto alcuni fondamentali modi di manipolare un array che NumPy ci mette a disposizione. Nella prossima , parleremo pi\u00f9 in dettaglio delle operazioni algebriche.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/","text":"Operazioni matriciali \u00b6 La maggior parte delle operazioni matriciali possono essere svolte usando il package linalg di NumPy. Tutti gli esempi che faremo nel prosieguo, quindi, prevederanno l'importazione di questo package; facciamolo scrivendo l'opportuna istruzione import . from numpy import linalg Trasposta di una matrice \u00b6 La prima operazione che vedremo non richiede l'uso del modulo linalg , ed \u00e8 quella che ci permette di effettuare la trasposta di una matrice. Per farlo, usiamo la funzione transpose . >>> np . transpose ( x ) Matrice inversa \u00b6 Possiamo calcolare l'inversa di una matrice usando la funzione inv(mat) del package linalg , dove mat \u00e8 la matrice da invertire. Ad esempio: >>> mat = np . array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 4 ]]) >>> mat_inv = linalg . inv ( mat ) >>> mat_inv array ([[ 0.2 , 0. , 0. ], [ 0. , 0.5 , 0. ], [ 0. , 0. , 0.25 ]]) Ovviamente, la matrice mat deve essere invertibile. Nel caso passassimo una matrice rettangolare, infatti,verrebbe lanciato un LinAlgError : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Last 2 dimensions of the array must be square Lo stesso accade per una matrice singolare: >>> mat = np . array ([[ 1 , 1 , 1 ],[ 2 , 2 , 2 ],[ 0 , 0 , 1 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Singular matrix Curiosit\u00e0 La matrice inversa che viene calcolata dalla funzione inv() \u00e8 quella che, moltiplicata per la matrice iniziale, restituisce la matrice identit\u00e0. Verifichiamolo: >>> mat . dot ( mat_inv ) array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Prodotti vettoriali e matriciali \u00b6 La funzione dot() \u00b6 Abbiamo gi\u00e0 visto nella lezione precedente un esempio di uso della funzione dot(a, b) , utile a calcolare il prodotto matriciale tra gli array a ed b . Ovviamente, si applicano tutte le regole valevoli per il calcolo del prodotto matriciale (ovvero quello relativo alla moltiplicazione righe per colonne); riassumiamole nella seguente tabella sulla base delle dimensionalit\u00e0 di a ed b . Dimensionalit\u00e0 a Dimensionalit\u00e0 b Risultato Note Monodimensionale (vettore) Monodimensionale (vettore) Prodotto scalare / Bidimensionale (matrice) Bidimensionale (matrice) Prodotto matriciale Preferire la funzione matmul Scalare N-dimensionale Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * N-dimensionale Scalare Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * Nel caso entrambi gli array siano N-dimensionali, si applicano altre regole che non approfondiremo in questa sede (\u00e8 possibile recuperarle a questo indirizzo ). Prodotto interno \u00b6 Possiamo usare la funzione inner(a, b) per calcolare il prodotto interno (o scalare ) tra i vettori a e b : >>> np . inner ( a , b ) 11 Prodotto esterno \u00b6 Possiamo usare la funzione outer(a, b) per calcolare il prodotto esterno tra due vettori. In particolare, dati due vettori \\(a = [a_1, a_2, \\ldots, a_n]\\) e \\(b = [b_1, b_2, \\ldots, b_n]\\) , il prodotto esterno \u00e8 definito come la matrice \\(P\\) tale che: P = [[ a_1 * b_1 ... a_1 * b_n ], ... , [ a_n * b_1 ... a_n * b_n ]] Ad esempio: >>> np . outer ( a , b ) array ([[ 3 , 4 ], [ 6 , 8 ]]) La funzione matmul \u00b6 Quando abbiamo parlato della funzione dot(a, b) abbiamo visto come sia possibile usarla per effettuare il prodotto matriciale tra le matrici mat_1 e mat_2 . Tuttavia, esiste un'altra possibilit\u00e0, che \u00e8 anche quella consigliata , ovvero usare la funzione matmul(a, b) : >>> a = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . matmul ( a , b ) array ([[ 19 , 22 ], [ 43 , 50 ]]) La funzione matmul() ha una differenza fondamentale rispetto alla funzione dot() , in quanto non accetta scalari come parametro (anche se \u00e8 possibile passare vettori ed array N-dimensionali). Esiste in realt\u00e0 un'altra differenza importante, che riguarda le operazioni N-dimensionali, ma che non tratteremo in questa sede. Potenza di matrice \u00b6 La funzione matrix_power(a, n) del package linalg permette di elevare a potenza n della matrice a . Ad esempio: >>> matrix_power ( a , 5 ) array ([[ 1069 , 1558 ], [ 2337 , 3406 ]]) Decomposizione di matrice \u00b6 Decomposizione QR \u00b6 La decomposizione (o fattorizzazione ) \\(QR\\) di una matrice invertibile \\(A\\) si definisce come il prodotto di una matrice ortogonale \\(Q\\) \u00e8 una matrice ortogonale per una matrice triangolare superiore \\(R\\) : \\[ A = QR \\] Matrice ortogonale Una matrice ortogonale \u00e8 una matrice quadrata la cui inversa coincide con la trasposta. NumPy ci offre un metodo per effettuare la decomposizione QR in un'unica istruzione mediante la funzione qr(a) del package linalg . Ad esempio: >>> ( q , r ) = qr ( mat ) >>> q array ([[ - 0.74535599 , - 0.28151707 , - 0.60431166 ], [ - 0.2981424 , - 0.67001063 , 0.67985062 ], [ - 0.59628479 , 0.68690166 , 0.41546427 ]]) >>> r array ([[ - 6.70820393 , - 1.19256959 , - 14.16176386 ], [ 0. , - 3.94686936 , 5.03915561 ], [ 0. , 0. , 0.22661687 ]]) Notiamo che il valore restituito dalla funzione \u00e8 una tupla il cui primo elemento \u00e8 la matrice \\(Q\\) , mentre il secondo \u00e8 \\(R\\) . Decomposizione ai valori singolari \u00b6 La decomposizione ai valori singolari , detta anche SVD (dall'inglese Singular Value Decomposition ), \u00e8 un tipo di fattorizzazione basato sul concetto di autovalore ed autovettore . In particolare, data una matrice \\(A\\) di dimensioni \\(m \\times n\\) , questa \u00e8 decomponibile come segue: \\[ A = U \\Sigma V^* \\] dove \\(U\\) \u00e8 una matrice unitaria di dimensioni \\(m \\times m\\) , \\(\\Sigma\\) \u00e8 una matrice diagonale rettangolare di dimensioni \\(m \\times n\\) , e \\(V^*\\) \u00e8 la trasposta coinugata di una matrice unitaria di dimensioni \\(n \\times n\\) . Trasposta coniugata La trasposta coniugata di una matrice \u00e8 ottenuta effettuandone la trasposizione e scambiando ogni elemento con il suo complesso coniugato. Anche in questo caso, la SVD \u00e8 estremamente complessa da implementare a partire dalle sue funzioni basilari. NumPy ci viene quindi in aiuto con la funzione svd(mat) del package linalg . Ad esempio: >>> ( u , s , v ) = linalg . svd ( mat ) >>> u array ([[ - 0.62732922 , - 0.48645199 , - 0.60813034 ], [ - 0.10481126 , - 0.72105629 , 0.68490322 ], [ - 0.77166874 , 0.49339871 , 0.40135404 ]]) >>> s array ([ 16.33118238 , 4.61369058 , 0.07963155 ]) >>> v array ([[ - 0.39390556 , - 0.00157703 , - 0.91914956 ], [ - 0.41198638 , - 0.89361655 , 0.17809178 ], [ - 0.82164812 , 0.44882844 , 0.35135082 ]]) Autovalori ed autovettori \u00b6 I concetti di autovalore ed autovettore hanno ampia applicazione in numerose discipline scientifiche, arrivando a definire la base su cui vengono elaborati alcuni degli approcci pi\u00f9 avanzati al machine learning. Formalmente, data una matrice quadrata \\(A\\) di ordine \\(n\\) con valori in uno spazio \\(\\mathbb{K}\\) , uno scalare \\(\\lambda_0 \\in \\mathbb{K}\\) \u00e8 definito autovalore di \\(A\\) se esiste un vettore colonna non nullo \\(v_0 \\in K^n\\) tale che: \\[ Av = \\lambda_0v \\] Dal punto di vista \"fisico\", un autovettore non cambia la sua direzione a seguito dell'applicazione di una trasformazione lineare. Possiamo, ad esempio, ruotarlo, ma la sua direzione non verr\u00e0 modificata; l'unico effetto che potremo notare sar\u00e0 una modifica nel modulo o nel verso, a seconda del suo autovalore. Per calcolare gli autovalori e gli autovettori di una matrice, NumPy ci mette a disposizione la funzione eig(a) , sempre appartenente al package linalg , che restituisce gli autovalori e gli autovettori destri di una matrice quadrata: >>> ( w , v ) = linalg . eig ( mat ) >>> w array ([ 15.23391422 , 0.08412242 , 4.68196336 ]) >>> v array ([[ - 0.66930729 , - 0.82394712 , - 0.68445786 ], [ - 0.16856631 , 0.44469209 , - 0.70619627 ], [ - 0.72361119 , 0.35122656 , 0.18111947 ]]) Norma \u00b6 La funzione linalg.norm(a) ci permette di calcolare la norma di una matrice. Opzionalmente, possiamo specificare tre parametri, ovvero: ord , che rappresenta l'ordine della norma da calcolare (di default, viene calcolata la norma di Frobenius); axis , che indica l'asse (o gli assi, in caso di array multidimensionale) su cui operare; keepdims , usata per restituire, opzionalmente, l'asse su cui viene calcolata la norma. Per calcolare la norma di Frobenius della matrice mat possiamo usare questa sintassi: >>> linalg . norm ( mat ) 16.97056274847714 Determinante, rango e traccia \u00b6 Possiamo calcolare rapidamente determinante, rango e traccia di una matrice mediante le funzioni det(a) , matrix_rank(a) e trace(a) , quest'ultima non appartenente al package linalg . Ad esempio: >>> linalg . det ( mat ) 6.000000000000001 >>> linalg . matrix_rank ( mat ) 3 >>> np . trace ( mat ) 20 Nota La funzione trace pu\u00f2 anche essere usata per calcolare la sommatoria delle sovra/sotto diagonali specificando il parametro offset . Ad esempio: >>> mat array ([[ 5 , 2 , 9 ], [ 2 , 3 , 1 ], [ 4 , - 2 , 12 ]]) >>> np . trace ( mat , offset = 1 ) 3 >>> np . trace ( mat , offset =- 1 ) 0 Risoluzione di sistemi \u00b6 Chiudiamo questa (necessariamente breve!) carrellata sulle operazioni di algebra lineare con la funzione solve(a, b) , che permette di risolvere un sistema di equazioni lineari nel quale la matrice a \u00e8 la matrice dei coefficienti, mentre il vettore b \u00e8 il vettore dei termini noti. Ad esempio: >>> b = np . array ([ 3 , 2 , 3 ]) >>> linalg . solve ( mat , b ) array ([ - 7.5 , 4.5 , 3.5 ]) Nota Ovviamente, la matrice a deve essere quadrata, mentre il vettore b deve avere esattamente n elementi, con n ordine di a ! Conclusioni \u00b6 In questa lezione, abbiamo visto come NumPy ci offra dei metodi per effettuare le operazioni base di algebra lineare in poche e semplici operazioni. Nella successiva , vedremo i metodi che ci vengono dati per trattare i polinomi reali.","title":"Operazioni matriciali"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#operazioni-matriciali","text":"La maggior parte delle operazioni matriciali possono essere svolte usando il package linalg di NumPy. Tutti gli esempi che faremo nel prosieguo, quindi, prevederanno l'importazione di questo package; facciamolo scrivendo l'opportuna istruzione import . from numpy import linalg","title":"Operazioni matriciali"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#trasposta-di-una-matrice","text":"La prima operazione che vedremo non richiede l'uso del modulo linalg , ed \u00e8 quella che ci permette di effettuare la trasposta di una matrice. Per farlo, usiamo la funzione transpose . >>> np . transpose ( x )","title":"Trasposta di una matrice"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#matrice-inversa","text":"Possiamo calcolare l'inversa di una matrice usando la funzione inv(mat) del package linalg , dove mat \u00e8 la matrice da invertire. Ad esempio: >>> mat = np . array ([[ 5 , 0 , 0 ], [ 0 , 2 , 0 ], [ 0 , 0 , 4 ]]) >>> mat_inv = linalg . inv ( mat ) >>> mat_inv array ([[ 0.2 , 0. , 0. ], [ 0. , 0.5 , 0. ], [ 0. , 0. , 0.25 ]]) Ovviamente, la matrice mat deve essere invertibile. Nel caso passassimo una matrice rettangolare, infatti,verrebbe lanciato un LinAlgError : >>> mat = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Last 2 dimensions of the array must be square Lo stesso accade per una matrice singolare: >>> mat = np . array ([[ 1 , 1 , 1 ],[ 2 , 2 , 2 ],[ 0 , 0 , 1 ]]) >>> linalg . inv ( mat ) Traceback ( most recent call last ): numpy . linalg . LinAlgError : Singular matrix Curiosit\u00e0 La matrice inversa che viene calcolata dalla funzione inv() \u00e8 quella che, moltiplicata per la matrice iniziale, restituisce la matrice identit\u00e0. Verifichiamolo: >>> mat . dot ( mat_inv ) array ([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]])","title":"Matrice inversa"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#prodotti-vettoriali-e-matriciali","text":"","title":"Prodotti vettoriali e matriciali"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#la-funzione-dot","text":"Abbiamo gi\u00e0 visto nella lezione precedente un esempio di uso della funzione dot(a, b) , utile a calcolare il prodotto matriciale tra gli array a ed b . Ovviamente, si applicano tutte le regole valevoli per il calcolo del prodotto matriciale (ovvero quello relativo alla moltiplicazione righe per colonne); riassumiamole nella seguente tabella sulla base delle dimensionalit\u00e0 di a ed b . Dimensionalit\u00e0 a Dimensionalit\u00e0 b Risultato Note Monodimensionale (vettore) Monodimensionale (vettore) Prodotto scalare / Bidimensionale (matrice) Bidimensionale (matrice) Prodotto matriciale Preferire la funzione matmul Scalare N-dimensionale Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * N-dimensionale Scalare Prodotto scalare per array N-dimensionale Preferire la funzione multiply(a, b) o l'operatore * Nel caso entrambi gli array siano N-dimensionali, si applicano altre regole che non approfondiremo in questa sede (\u00e8 possibile recuperarle a questo indirizzo ).","title":"La funzione dot()"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#prodotto-interno","text":"Possiamo usare la funzione inner(a, b) per calcolare il prodotto interno (o scalare ) tra i vettori a e b : >>> np . inner ( a , b ) 11","title":"Prodotto interno"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#prodotto-esterno","text":"Possiamo usare la funzione outer(a, b) per calcolare il prodotto esterno tra due vettori. In particolare, dati due vettori \\(a = [a_1, a_2, \\ldots, a_n]\\) e \\(b = [b_1, b_2, \\ldots, b_n]\\) , il prodotto esterno \u00e8 definito come la matrice \\(P\\) tale che: P = [[ a_1 * b_1 ... a_1 * b_n ], ... , [ a_n * b_1 ... a_n * b_n ]] Ad esempio: >>> np . outer ( a , b ) array ([[ 3 , 4 ], [ 6 , 8 ]])","title":"Prodotto esterno"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#la-funzione-matmul","text":"Quando abbiamo parlato della funzione dot(a, b) abbiamo visto come sia possibile usarla per effettuare il prodotto matriciale tra le matrici mat_1 e mat_2 . Tuttavia, esiste un'altra possibilit\u00e0, che \u00e8 anche quella consigliata , ovvero usare la funzione matmul(a, b) : >>> a = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> b = np . array ([[ 5 , 6 ], [ 7 , 8 ]]) >>> np . matmul ( a , b ) array ([[ 19 , 22 ], [ 43 , 50 ]]) La funzione matmul() ha una differenza fondamentale rispetto alla funzione dot() , in quanto non accetta scalari come parametro (anche se \u00e8 possibile passare vettori ed array N-dimensionali). Esiste in realt\u00e0 un'altra differenza importante, che riguarda le operazioni N-dimensionali, ma che non tratteremo in questa sede.","title":"La funzione matmul"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#potenza-di-matrice","text":"La funzione matrix_power(a, n) del package linalg permette di elevare a potenza n della matrice a . Ad esempio: >>> matrix_power ( a , 5 ) array ([[ 1069 , 1558 ], [ 2337 , 3406 ]])","title":"Potenza di matrice"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#decomposizione-di-matrice","text":"","title":"Decomposizione di matrice"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#decomposizione-qr","text":"La decomposizione (o fattorizzazione ) \\(QR\\) di una matrice invertibile \\(A\\) si definisce come il prodotto di una matrice ortogonale \\(Q\\) \u00e8 una matrice ortogonale per una matrice triangolare superiore \\(R\\) : \\[ A = QR \\] Matrice ortogonale Una matrice ortogonale \u00e8 una matrice quadrata la cui inversa coincide con la trasposta. NumPy ci offre un metodo per effettuare la decomposizione QR in un'unica istruzione mediante la funzione qr(a) del package linalg . Ad esempio: >>> ( q , r ) = qr ( mat ) >>> q array ([[ - 0.74535599 , - 0.28151707 , - 0.60431166 ], [ - 0.2981424 , - 0.67001063 , 0.67985062 ], [ - 0.59628479 , 0.68690166 , 0.41546427 ]]) >>> r array ([[ - 6.70820393 , - 1.19256959 , - 14.16176386 ], [ 0. , - 3.94686936 , 5.03915561 ], [ 0. , 0. , 0.22661687 ]]) Notiamo che il valore restituito dalla funzione \u00e8 una tupla il cui primo elemento \u00e8 la matrice \\(Q\\) , mentre il secondo \u00e8 \\(R\\) .","title":"Decomposizione QR"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#decomposizione-ai-valori-singolari","text":"La decomposizione ai valori singolari , detta anche SVD (dall'inglese Singular Value Decomposition ), \u00e8 un tipo di fattorizzazione basato sul concetto di autovalore ed autovettore . In particolare, data una matrice \\(A\\) di dimensioni \\(m \\times n\\) , questa \u00e8 decomponibile come segue: \\[ A = U \\Sigma V^* \\] dove \\(U\\) \u00e8 una matrice unitaria di dimensioni \\(m \\times m\\) , \\(\\Sigma\\) \u00e8 una matrice diagonale rettangolare di dimensioni \\(m \\times n\\) , e \\(V^*\\) \u00e8 la trasposta coinugata di una matrice unitaria di dimensioni \\(n \\times n\\) . Trasposta coniugata La trasposta coniugata di una matrice \u00e8 ottenuta effettuandone la trasposizione e scambiando ogni elemento con il suo complesso coniugato. Anche in questo caso, la SVD \u00e8 estremamente complessa da implementare a partire dalle sue funzioni basilari. NumPy ci viene quindi in aiuto con la funzione svd(mat) del package linalg . Ad esempio: >>> ( u , s , v ) = linalg . svd ( mat ) >>> u array ([[ - 0.62732922 , - 0.48645199 , - 0.60813034 ], [ - 0.10481126 , - 0.72105629 , 0.68490322 ], [ - 0.77166874 , 0.49339871 , 0.40135404 ]]) >>> s array ([ 16.33118238 , 4.61369058 , 0.07963155 ]) >>> v array ([[ - 0.39390556 , - 0.00157703 , - 0.91914956 ], [ - 0.41198638 , - 0.89361655 , 0.17809178 ], [ - 0.82164812 , 0.44882844 , 0.35135082 ]])","title":"Decomposizione ai valori singolari"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#autovalori-ed-autovettori","text":"I concetti di autovalore ed autovettore hanno ampia applicazione in numerose discipline scientifiche, arrivando a definire la base su cui vengono elaborati alcuni degli approcci pi\u00f9 avanzati al machine learning. Formalmente, data una matrice quadrata \\(A\\) di ordine \\(n\\) con valori in uno spazio \\(\\mathbb{K}\\) , uno scalare \\(\\lambda_0 \\in \\mathbb{K}\\) \u00e8 definito autovalore di \\(A\\) se esiste un vettore colonna non nullo \\(v_0 \\in K^n\\) tale che: \\[ Av = \\lambda_0v \\] Dal punto di vista \"fisico\", un autovettore non cambia la sua direzione a seguito dell'applicazione di una trasformazione lineare. Possiamo, ad esempio, ruotarlo, ma la sua direzione non verr\u00e0 modificata; l'unico effetto che potremo notare sar\u00e0 una modifica nel modulo o nel verso, a seconda del suo autovalore. Per calcolare gli autovalori e gli autovettori di una matrice, NumPy ci mette a disposizione la funzione eig(a) , sempre appartenente al package linalg , che restituisce gli autovalori e gli autovettori destri di una matrice quadrata: >>> ( w , v ) = linalg . eig ( mat ) >>> w array ([ 15.23391422 , 0.08412242 , 4.68196336 ]) >>> v array ([[ - 0.66930729 , - 0.82394712 , - 0.68445786 ], [ - 0.16856631 , 0.44469209 , - 0.70619627 ], [ - 0.72361119 , 0.35122656 , 0.18111947 ]])","title":"Autovalori ed autovettori"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#norma","text":"La funzione linalg.norm(a) ci permette di calcolare la norma di una matrice. Opzionalmente, possiamo specificare tre parametri, ovvero: ord , che rappresenta l'ordine della norma da calcolare (di default, viene calcolata la norma di Frobenius); axis , che indica l'asse (o gli assi, in caso di array multidimensionale) su cui operare; keepdims , usata per restituire, opzionalmente, l'asse su cui viene calcolata la norma. Per calcolare la norma di Frobenius della matrice mat possiamo usare questa sintassi: >>> linalg . norm ( mat ) 16.97056274847714","title":"Norma"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#determinante-rango-e-traccia","text":"Possiamo calcolare rapidamente determinante, rango e traccia di una matrice mediante le funzioni det(a) , matrix_rank(a) e trace(a) , quest'ultima non appartenente al package linalg . Ad esempio: >>> linalg . det ( mat ) 6.000000000000001 >>> linalg . matrix_rank ( mat ) 3 >>> np . trace ( mat ) 20 Nota La funzione trace pu\u00f2 anche essere usata per calcolare la sommatoria delle sovra/sotto diagonali specificando il parametro offset . Ad esempio: >>> mat array ([[ 5 , 2 , 9 ], [ 2 , 3 , 1 ], [ 4 , - 2 , 12 ]]) >>> np . trace ( mat , offset = 1 ) 3 >>> np . trace ( mat , offset =- 1 ) 0","title":"Determinante, rango e traccia"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#risoluzione-di-sistemi","text":"Chiudiamo questa (necessariamente breve!) carrellata sulle operazioni di algebra lineare con la funzione solve(a, b) , che permette di risolvere un sistema di equazioni lineari nel quale la matrice a \u00e8 la matrice dei coefficienti, mentre il vettore b \u00e8 il vettore dei termini noti. Ad esempio: >>> b = np . array ([ 3 , 2 , 3 ]) >>> linalg . solve ( mat , b ) array ([ - 7.5 , 4.5 , 3.5 ]) Nota Ovviamente, la matrice a deve essere quadrata, mentre il vettore b deve avere esattamente n elementi, con n ordine di a !","title":"Risoluzione di sistemi"},{"location":"material/02_libs/07_numpy/10_algebra/lecture/#conclusioni","text":"In questa lezione, abbiamo visto come NumPy ci offra dei metodi per effettuare le operazioni base di algebra lineare in poche e semplici operazioni. Nella successiva , vedremo i metodi che ci vengono dati per trattare i polinomi reali.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/","text":"Il modulo polynomial \u00b6 Il modulo numpy.polynomial.polynomial ci offre numerose classi e funzionalit\u00e0 per il trattamento dei polinomi. Vediamo insieme quali sono le principali. Operazioni tra polinomi \u00b6 Immaginiamo di avere due diversi polinomi (cui non associeremo alcun significato fisico), ovvero: \\[ y = 2x + 1 \\\\ y = x^2 + 3x + 2 \\] Vediamo come usare dei metodi forniti dal modulo polynomial per effettuare delle operazioni su di loro. Addizione di polinomi \u00b6 Per effettuare l'addizione di due polinomi, possiamo usare il metodo polyadd(c1, c2) , che accetta come parametri due vettori c1 e c2 che rappresentano, rispettivamente, i coefficienti del polinomio 1 e 2. Volendo sommare il primo ed il secondo polinomio, potremo scrivere: >>> import numpy.polynomial.polynomial as poly >>> c1 = ( 0 , 2 , 1 ) >>> c2 = ( 1 , 3 , 2 ) >>> poly . polyadd ( c1 , c2 ) array ([ 1. , 5. , 3. ]) che \u00e8 il risultato atteso, ovvero \\(x^2 + 5x + 3\\) . Notiamo come le dimensioni di c1 e di c2 debbano essere tra loro coerenti . Se infatti omettessimo il coefficiente \\(0\\) al termine di secondo grado in c1 , il risultato sarebbe il seguente: >>> c1 = ( 2 , 1 ) >>> poly . polyadd ( c1 , c2 ) array ([ 3. , 4. , 2. ]) Ovviamente, il risultato precedente \u00e8 errato. Sottrazione di polinomi \u00b6 Possiamo poi sottrarre due polinomi usando la funzione polysub(c1, c2) , i cui parametri sono identici a quelli passati a polyadd : >>> poly . polysub ( c2 , c1 ) array ([ 1. , 1. , 1. ]) Moltiplicazione di polinomi \u00b6 Le considerazioni precedenti possono essere banalmente traslate al caso della moltiplicazione tra polinomi, ottenibile mediante la funzione polymul(c1, c2) . >>> poly . polymul ( c1 , c2 ) array ([ 0. , 2. , 7. , 7. , 2. ]) Nota Notiamo che il coefficiente del termine di quarto grado viene comunque riportato, nonostante questo sia pari a zero. Divisione tra polinomi \u00b6 La divisione tra polinomi \u00e8 un'operazione leggermente pi\u00f9 complessa delle altre, e prevede l'uso della funzione polydiv(c1, c2) , che restituir\u00e0 stavolta due array: il primo, q , rappresenta i coefficienti del polinomio quoziente, mentre il secondo, r , indica i coefficienti del polinomio resto. Nel nostro caso: >>> ( q , r ) = poly . polydiv ( c1 , c2 ) >>> q array ([ 0.5 ]) >>> r array ([ - 0.5 , 0.5 ]) Elevazione a potenza \u00b6 Chiudiamo questa breve panoramica parlando dell'elevazione a potenza di un polinomio, effettuabile mediante la funzione polypow(c, pow) , con c vettore dei coefficienti, e pow potenza a cui elevare: >>> poly . polypow ( c1 , 2 ) array ([ 0. , 0. , 4. , 4. , 1. ]) Anche in questo caso, vengono riportati i termini pari a zero nei risultati. Visualizzazione di un polinomio \u00b6 Il metodo che abbiamo usato finora per visualizzare i coefficienti di un polinomio \u00e8 alquanto inefficace e poco rappresentativo. Possiamo quindi sfruttare la funzione poly1d(p) di NumPy, che ci offre un oggetto la cui rappresentazione \u00e8 molto pi\u00f9 simile a quella cui siamo abituati nella \"realt\u00e0\": >>> p = np . poly1d ( c1 ) >>> print ( p ) 2 x + 1 Suggerimento Esistono diversi modi di sfruttare questa rappresentazione per mostrare a schermo i polinomi risultanti dalle operazioni che effettuiamo. Uno, banale, \u00e8 convertire il polinomio risultante; altri invece prevedono l'utilizzo delle funzioni polinomiali di NumPy (e non del package polynomial.polynomial ). Valutare un polinomio \u00b6 Per valutare il valore \\(y\\) assunto dal polinomio per un determinato valore di \\(x\\) , usiamo la funzione polyval(x, p) , che accetta come argomento un intero (o una lista di interi) x ed un polinomio p . Se volessimo valutare il valore assunto da \\(y\\) per \\(x \\in [1, 2]\\) sulla retta rappresentata dal polinomio c1 , ad esempio, potremmo usare polyval come segue: >>> poly . polyval ([ 1 , 2 ], c1 ) array ([ 3. , 8. ]) Derivata ed integrale di funzioni polinomiali \u00b6 Concludiamo questa breve carrellata con due metodi in grado di calcolare, rispettivamente, la derivata e l'integrale di una funzione polinomiale. Il metodo polyder(p, m) , infatti, permette di calcolare la derivata di ordine m del polinomio p (di default, m=2 ): >>> c1 = ( 2 , 1 ) >>> poly . polyder ( c1 ) array ([ 1. ]) Attenzione Non inseriamo coefficienti \"extra\" usando polyder e polyints , in quanto potrebbero portare a risultati inattesi. Il metodo duale \u00e8 polyint(p, m) , che prevedibilmente calcola l'integrale di ordine m del polinomio p : >>> poly . polyint ( c1 ) array ([ 0. , 2. , 0.5 ]) Conclusioni \u00b6 In questa lezione, abbiamo dato uno sguardo ad alcune delle funzioni per il trattamento dei polinomi messe a disposizione da NumPy. Nella prossima lezione , daremo uno sguardo ravvicinato alle funzioni statistiche.","title":"Il modulo `polynomial`"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#il-modulo-polynomial","text":"Il modulo numpy.polynomial.polynomial ci offre numerose classi e funzionalit\u00e0 per il trattamento dei polinomi. Vediamo insieme quali sono le principali.","title":"Il modulo polynomial"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#operazioni-tra-polinomi","text":"Immaginiamo di avere due diversi polinomi (cui non associeremo alcun significato fisico), ovvero: \\[ y = 2x + 1 \\\\ y = x^2 + 3x + 2 \\] Vediamo come usare dei metodi forniti dal modulo polynomial per effettuare delle operazioni su di loro.","title":"Operazioni tra polinomi"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#addizione-di-polinomi","text":"Per effettuare l'addizione di due polinomi, possiamo usare il metodo polyadd(c1, c2) , che accetta come parametri due vettori c1 e c2 che rappresentano, rispettivamente, i coefficienti del polinomio 1 e 2. Volendo sommare il primo ed il secondo polinomio, potremo scrivere: >>> import numpy.polynomial.polynomial as poly >>> c1 = ( 0 , 2 , 1 ) >>> c2 = ( 1 , 3 , 2 ) >>> poly . polyadd ( c1 , c2 ) array ([ 1. , 5. , 3. ]) che \u00e8 il risultato atteso, ovvero \\(x^2 + 5x + 3\\) . Notiamo come le dimensioni di c1 e di c2 debbano essere tra loro coerenti . Se infatti omettessimo il coefficiente \\(0\\) al termine di secondo grado in c1 , il risultato sarebbe il seguente: >>> c1 = ( 2 , 1 ) >>> poly . polyadd ( c1 , c2 ) array ([ 3. , 4. , 2. ]) Ovviamente, il risultato precedente \u00e8 errato.","title":"Addizione di polinomi"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#sottrazione-di-polinomi","text":"Possiamo poi sottrarre due polinomi usando la funzione polysub(c1, c2) , i cui parametri sono identici a quelli passati a polyadd : >>> poly . polysub ( c2 , c1 ) array ([ 1. , 1. , 1. ])","title":"Sottrazione di polinomi"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#moltiplicazione-di-polinomi","text":"Le considerazioni precedenti possono essere banalmente traslate al caso della moltiplicazione tra polinomi, ottenibile mediante la funzione polymul(c1, c2) . >>> poly . polymul ( c1 , c2 ) array ([ 0. , 2. , 7. , 7. , 2. ]) Nota Notiamo che il coefficiente del termine di quarto grado viene comunque riportato, nonostante questo sia pari a zero.","title":"Moltiplicazione di polinomi"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#divisione-tra-polinomi","text":"La divisione tra polinomi \u00e8 un'operazione leggermente pi\u00f9 complessa delle altre, e prevede l'uso della funzione polydiv(c1, c2) , che restituir\u00e0 stavolta due array: il primo, q , rappresenta i coefficienti del polinomio quoziente, mentre il secondo, r , indica i coefficienti del polinomio resto. Nel nostro caso: >>> ( q , r ) = poly . polydiv ( c1 , c2 ) >>> q array ([ 0.5 ]) >>> r array ([ - 0.5 , 0.5 ])","title":"Divisione tra polinomi"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#elevazione-a-potenza","text":"Chiudiamo questa breve panoramica parlando dell'elevazione a potenza di un polinomio, effettuabile mediante la funzione polypow(c, pow) , con c vettore dei coefficienti, e pow potenza a cui elevare: >>> poly . polypow ( c1 , 2 ) array ([ 0. , 0. , 4. , 4. , 1. ]) Anche in questo caso, vengono riportati i termini pari a zero nei risultati.","title":"Elevazione a potenza"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#visualizzazione-di-un-polinomio","text":"Il metodo che abbiamo usato finora per visualizzare i coefficienti di un polinomio \u00e8 alquanto inefficace e poco rappresentativo. Possiamo quindi sfruttare la funzione poly1d(p) di NumPy, che ci offre un oggetto la cui rappresentazione \u00e8 molto pi\u00f9 simile a quella cui siamo abituati nella \"realt\u00e0\": >>> p = np . poly1d ( c1 ) >>> print ( p ) 2 x + 1 Suggerimento Esistono diversi modi di sfruttare questa rappresentazione per mostrare a schermo i polinomi risultanti dalle operazioni che effettuiamo. Uno, banale, \u00e8 convertire il polinomio risultante; altri invece prevedono l'utilizzo delle funzioni polinomiali di NumPy (e non del package polynomial.polynomial ).","title":"Visualizzazione di un polinomio"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#valutare-un-polinomio","text":"Per valutare il valore \\(y\\) assunto dal polinomio per un determinato valore di \\(x\\) , usiamo la funzione polyval(x, p) , che accetta come argomento un intero (o una lista di interi) x ed un polinomio p . Se volessimo valutare il valore assunto da \\(y\\) per \\(x \\in [1, 2]\\) sulla retta rappresentata dal polinomio c1 , ad esempio, potremmo usare polyval come segue: >>> poly . polyval ([ 1 , 2 ], c1 ) array ([ 3. , 8. ])","title":"Valutare un polinomio"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#derivata-ed-integrale-di-funzioni-polinomiali","text":"Concludiamo questa breve carrellata con due metodi in grado di calcolare, rispettivamente, la derivata e l'integrale di una funzione polinomiale. Il metodo polyder(p, m) , infatti, permette di calcolare la derivata di ordine m del polinomio p (di default, m=2 ): >>> c1 = ( 2 , 1 ) >>> poly . polyder ( c1 ) array ([ 1. ]) Attenzione Non inseriamo coefficienti \"extra\" usando polyder e polyints , in quanto potrebbero portare a risultati inattesi. Il metodo duale \u00e8 polyint(p, m) , che prevedibilmente calcola l'integrale di ordine m del polinomio p : >>> poly . polyint ( c1 ) array ([ 0. , 2. , 0.5 ])","title":"Derivata ed integrale di funzioni polinomiali"},{"location":"material/02_libs/07_numpy/11_polynomials/lecture/#conclusioni","text":"In questa lezione, abbiamo dato uno sguardo ad alcune delle funzioni per il trattamento dei polinomi messe a disposizione da NumPy. Nella prossima lezione , daremo uno sguardo ravvicinato alle funzioni statistiche.","title":"Conclusioni"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/","text":"Le funzioni statistiche \u00b6 NumPy ci mette a disposizione diverse funzioni per il calcolo statistico. Vediamone assieme una breve carrellata. Minimo e massimo di un array \u00b6 Partiamo con due funzioni che possono essere utili per determinare il valore massimo ed il valore minimo di un array a , ovvero amin(a) ed amax(a) . Entrambe queste funzioni accettano (opzionalmente) un valore per il parametro axis , indicante al solito la direzione lungo la quale viene effettuata l'operazione. Ad esempio, se volessimo trovare il minimo ed il massimo di un vettore generato casualmente: >>> rng = np . random . default_rng ( 42 ) >>> a = rng . integers ( low = 0 , high = 10 , size = 5 ) >>> a array ([ 0 , 7 , 6 , 4 ], dtype = int64 ) >>> np . amin ( a ) 0 >>> np . amax ( a ) 7 Attenzione Nel codice precedente abbiamo usato la funzione default_rng del package random di NumPy per generare un vettore di numeri casuali. Per una matrice, ed in generale per ogni array N-dimensionale, il procedimento da seguire \u00e8 analogo: >>> b = rng . integers ( low = 0 , high = 10 , size = ( 3 , 3 )) >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . amin ( b ) 0 >>> np . amax ( b ) 9 Immaginiamo adesso di voler trovare il minimo ed il massimo per colonna per b . Al solito, specifichiamo il parametro axis , che assumer\u00e0 valore pari a 0 : >>> np . amin ( b , axis = 0 ) array ([ 4 , 2 , 0 ], dtype = int64 ) >>> np . amax ( b , axis = 0 ) array ([ 6 , 9 , 7 ], dtype = int64 ) Ovviamente, per trovare il minimo ed il massimo per riga , dovremo cambiare il valore di axis in 1 : >>> np . amin ( b , axis = 1 ) array ([ 0 , 0 , 5 ], dtype = int64 ) >>> np . amax ( b , axis = 1 ) array ([ 8 , 6 , 9 ], dtype = int64 ) Possiamo anche specificare una tupla per il valore del parametro axis ; in tal caso, la ricerca del massimo o del minimo avverr\u00e0 lungo tutti gli assi specificati dalla tupla. Ad esempio, specificando (0, 1) , effettueremo la ricerca del minimo (o del massimo) elemento nella matrice: >>> np . amin ( b , axis = ( 0 , 1 )) 0 >>> np . amax ( b , axis = ( 0 , 1 )) 9 Percentile, quantile e mediana \u00b6 Ricordiamo che il q-percentile di un vettore \\(V\\) di lunghezza \\(N\\) \u00e8 il valore sotto il quale ricade il \\(q\\) % degli elementi di \\(V\\) . Per fare un esempio, supponiamo di avere un vettore ordinato di elementi che vanno da 1 a 10: >>> a = np . arange ( 1 , 11 ) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) Possiamo calcolare il 50-percentile usando la formula classica, che ci dice che questo \u00e8 pari a: \\[ n = \\frac{q}{100} * N = \\frac{50}{100} * 10 = 5 \\] In realt\u00e0, la funzione percentile(a, q) usa, per il 50-percentile, il calcolo della mediana, per cui \u00e8 equivalente alla funzione median(a) . In questo caso specifico, avremo un discostamento dal risultato atteso, dovuto ad errori di interpolazione introdotti da NumPy: >>> np . percentile ( a , 50 ) 5.5 Il concetto di quantile \u00e8 analogo a quello di percentile; tuttavia, in questo caso, non abbiamo a che fare con valori percentuali, bens\u00ec con valori normalizzat tra 0 ed 1. Per cui, se usassimo la funzione quantile(a, q) come in precedenza: >>> np . quantile ( a , .5 ) 5.5 Anche le funzioni percentile e quantile prevedono come argomento opzionale il parametro axis . Ad esempio: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . percentile ( b , 50 , axis = 0 ) array ([ 5. , 8. , 0. ]) >>> np . percentile ( b , 50 , axis = 1 ) array ([ 4. , 2. , 7. ]) Come previsto, dando il valore 0 al parametro axis avremo il calcolo del percentile su ciascuna colonna, mentre passando il valore 1 avremo il calcolo del percentile su ciascuna riga. Media aritmetica e media pesata \u00b6 Per il calcolo del valore medio di un array NumPy ci mette a disposizione due metodi. Il primo \u00e8 la funzione average(a, weights) , che viene usata per calcolare una media pesata degli elementi di a ponderati per gli elementi di weights (a patto che, ovviamente, le dimensioni dei due array siano coerenti). Il calcolo che viene effettuato da NumPy con la funzione average \u00e8 quindi il seguente: avg = sum ( a * weights ) / sum ( weights ) Per cui, se volessimo assegnare un peso maggiore al primo ed al quarto elemento di un array a generato casualmente, potremmo fare come segue: >>> a = rng . integers ( low = 0 , high = 10 , size = 4 ) >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> w = np . array ([ 3 , 1 , 1 , 3 ]) >>> np . average ( a , weights = w ) 6.25 Il risultato si discosta leggermente dalla semplice media: >>> np . average ( a ) 6.5 Suggerimento Teniamo sempre a mente che la media \u00e8 ponderata per la sommatoria dei valori assunti dai pesi! La funzione mean(a) \u00e8 invece rappresentativa della media aritmetica degli elementi di un array, ed equivale alla funzione average(a) senza la specifica del vettore dei pesi. Ad esempio: >>> np . mean ( a ) 6.5 Concludiamo ricordando che anche in questo caso possiamo specificare il valore del parametro axis: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . mean ( b , axis = 0 ) array ([ 5. , 6.33333333 , 2.33333333 ]) >>> np . mean ( b , axis = 1 ) array ([ 4. , 2.66666667 , 7. ]) Varianza e deviazione standard \u00b6 Non possono mancare le funzioni std(a) e var(a) , dedicate al calcolo della deviazione standard e della varianza di un vettore: >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> np . std ( a ) 0.8660254037844386 >>> np . var ( a ) 0.75 Anche in questo caso, possiamo specificare gli assi lungo i quali effettuare l'operazione desiderata: >>> np . var ( b , axis = 0 ) array ([ 0.66666667 , 9.55555556 , 10.88888889 ]) >>> np . var ( b , axis = 1 ) array ([ 10.66666667 , 6.22222222 , 2.66666667 ]) Matrice di covarianza \u00b6 La matrice di covarianza \u00e8 la matrice che racchiude tutti i coefficienti di correlazione , che ci permetteno di valutare come una certa variabile \\(x_i\\) varia al variare di un'altra variabile \\(x_j\\) . In generale, esistono diversi tipi di coefficienti di correlazione; il pi\u00f9 semplice \u00e8 quello di Pearson, che stima una correlazione di tipo lineare (ovvero, \u00e8 tanto pi\u00f9 alto quanto le due variabili crescono secondo un rapporto lineare), ed \u00e8 quello usato dalle funzioni cov(a) e corrcoef(a) , la seconda delle quali riporta i valori normalizzati dei risultati ottenibili anche con la prima. In questo caso, a pu\u00f2 essere monodimensionale o bidimensionale, ma ogni riga di a rappresenta una variabile , mentre ogni colonna rappresenta una osservazione . Facciamo qualche esempio. Immaginiamo di avere due variabili che assumono rispettivamente valori [1, 2, 3] e [4, 5, 6] . In questo caso, \u00e8 evidente come la correlazione sia massima, in quanto le osservazioni della seconda variabile hanno un semplice offset (o bias ) rispetto a quelle della prima. Proviamo a calcolare la matrice di correlazione: >>> x = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> x array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> np . cov ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) Notiamo che, dato che i coefficienti di correlazione assumono valore pari ad 1, le due variabili sono fortemente correlate tra loro. Se invece avessimo una situazione di questo tipo: >>> x = np . array ([[ 1 , 2 , 3 ], [ - 1 , - 2 , - 3 ]]) >>> np . cov ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) In questo caso, \u00e8 evidente come le variabili siano anticorrelate , il che significa che quando la prima sale, la seconda scende, e viceversa. Per apprezzare le differenze tra le funzioni cov e corrcoef , dobbiamo usare valori differenti (e non banali) per x . Ad esempio: >>> x = np . array ([[ 2 , 3 , - 1 ], [ 1 , 5 , 2 ], [ 4 , 2 , 2 ]]) >>> np . cov ( x ) array ([[ 4.33333333 , 2.16666667 , 0.66666667 ], [ 2.16666667 , 4.33333333 , - 1.66666667 ], [ 0.66666667 , - 1.66666667 , 1.33333333 ]]) >>> np . corrcoef ( x ) array ([[ 1. , 0.5 , 0.2773501 ], [ 0.5 , 1. , - 0.69337525 ], [ 0.2773501 , - 0.69337525 , 1. ]]) In sostanza, corrcoef restituisce la matrice dei coefficienti \\(R\\) , la cui relazione con la matrice di covarianza \\(C\\) restituita da cov \u00e8: \\[ R_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} * C_{jj}}} \\] Istogramma \u00b6 Un istogramma offre una visualizzazione grafica dei valori contenuti in un vettore, raggruppandoli all'interno di un certo numero di partizioni ( bin ). Ad esempio, una possibile rappresentazione a due partizioni del vettore \\(A = [1, 2, 3, 4]\\) \u00e8 data dal vettore \\([2, 2]\\) . Questo si spiega col fatto che le due partizioni suddividono il range di valori assunti da \\(A\\) in due parti, con la prima inerente gli elementi \\(1\\) e \\(2\\) , e la seconda gli elementi \\(3\\) e \\(4\\) . Una volta calcolate le partizioni, queste andranno \"riempite\" contando il numero di elementi presenti in ciascuna partizione, il che ci riporta al vettore \\([2, 2]\\) . Nota Ovviamente, \u00e8 possibile specificare, oltre al numero di partizioni, anche gli estremi delle stesse, che potrebbero non coincidere con quelli del vettore. NumPy ci permette di ottenere l'istogramma di un vettore mediante l'insieme di funzioni histogram(a, bins, range) , che ci permette di calcolare l'istogramma (monodimensionale) dell'array a in funzione del numero di partizioni (opzionale) e del range (opzionale). Ad esempio: >>> a = rng . integers ( low = 0 , high = 10 , size = 100 ) >>> h , b = np . histogram ( a ) >>> h array ([ 9 , 9 , 11 , 10 , 15 , 8 , 12 , 11 , 5 , 10 ], dtype = int64 ) >>> b array ([ 0. , 0.9 , 1.8 , 2.7 , 3.6 , 4.5 , 5.4 , 6.3 , 7.2 , 8.1 , 9. ]) In questo caso, abbiamo lasciato il valore di default di bins , ovvero 10. Conclusioni \u00b6 In questa lezione, abbiamo visto alcune delle principali potenzialit\u00e0 offerte da NumPy in ambito statistico. Con questo, abbiamo terminato la nostra \"panoramica\" su NumPy.","title":"Le funzioni statistiche"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#le-funzioni-statistiche","text":"NumPy ci mette a disposizione diverse funzioni per il calcolo statistico. Vediamone assieme una breve carrellata.","title":"Le funzioni statistiche"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#minimo-e-massimo-di-un-array","text":"Partiamo con due funzioni che possono essere utili per determinare il valore massimo ed il valore minimo di un array a , ovvero amin(a) ed amax(a) . Entrambe queste funzioni accettano (opzionalmente) un valore per il parametro axis , indicante al solito la direzione lungo la quale viene effettuata l'operazione. Ad esempio, se volessimo trovare il minimo ed il massimo di un vettore generato casualmente: >>> rng = np . random . default_rng ( 42 ) >>> a = rng . integers ( low = 0 , high = 10 , size = 5 ) >>> a array ([ 0 , 7 , 6 , 4 ], dtype = int64 ) >>> np . amin ( a ) 0 >>> np . amax ( a ) 7 Attenzione Nel codice precedente abbiamo usato la funzione default_rng del package random di NumPy per generare un vettore di numeri casuali. Per una matrice, ed in generale per ogni array N-dimensionale, il procedimento da seguire \u00e8 analogo: >>> b = rng . integers ( low = 0 , high = 10 , size = ( 3 , 3 )) >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . amin ( b ) 0 >>> np . amax ( b ) 9 Immaginiamo adesso di voler trovare il minimo ed il massimo per colonna per b . Al solito, specifichiamo il parametro axis , che assumer\u00e0 valore pari a 0 : >>> np . amin ( b , axis = 0 ) array ([ 4 , 2 , 0 ], dtype = int64 ) >>> np . amax ( b , axis = 0 ) array ([ 6 , 9 , 7 ], dtype = int64 ) Ovviamente, per trovare il minimo ed il massimo per riga , dovremo cambiare il valore di axis in 1 : >>> np . amin ( b , axis = 1 ) array ([ 0 , 0 , 5 ], dtype = int64 ) >>> np . amax ( b , axis = 1 ) array ([ 8 , 6 , 9 ], dtype = int64 ) Possiamo anche specificare una tupla per il valore del parametro axis ; in tal caso, la ricerca del massimo o del minimo avverr\u00e0 lungo tutti gli assi specificati dalla tupla. Ad esempio, specificando (0, 1) , effettueremo la ricerca del minimo (o del massimo) elemento nella matrice: >>> np . amin ( b , axis = ( 0 , 1 )) 0 >>> np . amax ( b , axis = ( 0 , 1 )) 9","title":"Minimo e massimo di un array"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#percentile-quantile-e-mediana","text":"Ricordiamo che il q-percentile di un vettore \\(V\\) di lunghezza \\(N\\) \u00e8 il valore sotto il quale ricade il \\(q\\) % degli elementi di \\(V\\) . Per fare un esempio, supponiamo di avere un vettore ordinato di elementi che vanno da 1 a 10: >>> a = np . arange ( 1 , 11 ) >>> a array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) Possiamo calcolare il 50-percentile usando la formula classica, che ci dice che questo \u00e8 pari a: \\[ n = \\frac{q}{100} * N = \\frac{50}{100} * 10 = 5 \\] In realt\u00e0, la funzione percentile(a, q) usa, per il 50-percentile, il calcolo della mediana, per cui \u00e8 equivalente alla funzione median(a) . In questo caso specifico, avremo un discostamento dal risultato atteso, dovuto ad errori di interpolazione introdotti da NumPy: >>> np . percentile ( a , 50 ) 5.5 Il concetto di quantile \u00e8 analogo a quello di percentile; tuttavia, in questo caso, non abbiamo a che fare con valori percentuali, bens\u00ec con valori normalizzat tra 0 ed 1. Per cui, se usassimo la funzione quantile(a, q) come in precedenza: >>> np . quantile ( a , .5 ) 5.5 Anche le funzioni percentile e quantile prevedono come argomento opzionale il parametro axis . Ad esempio: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . percentile ( b , 50 , axis = 0 ) array ([ 5. , 8. , 0. ]) >>> np . percentile ( b , 50 , axis = 1 ) array ([ 4. , 2. , 7. ]) Come previsto, dando il valore 0 al parametro axis avremo il calcolo del percentile su ciascuna colonna, mentre passando il valore 1 avremo il calcolo del percentile su ciascuna riga.","title":"Percentile, quantile e mediana"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#media-aritmetica-e-media-pesata","text":"Per il calcolo del valore medio di un array NumPy ci mette a disposizione due metodi. Il primo \u00e8 la funzione average(a, weights) , che viene usata per calcolare una media pesata degli elementi di a ponderati per gli elementi di weights (a patto che, ovviamente, le dimensioni dei due array siano coerenti). Il calcolo che viene effettuato da NumPy con la funzione average \u00e8 quindi il seguente: avg = sum ( a * weights ) / sum ( weights ) Per cui, se volessimo assegnare un peso maggiore al primo ed al quarto elemento di un array a generato casualmente, potremmo fare come segue: >>> a = rng . integers ( low = 0 , high = 10 , size = 4 ) >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> w = np . array ([ 3 , 1 , 1 , 3 ]) >>> np . average ( a , weights = w ) 6.25 Il risultato si discosta leggermente dalla semplice media: >>> np . average ( a ) 6.5 Suggerimento Teniamo sempre a mente che la media \u00e8 ponderata per la sommatoria dei valori assunti dai pesi! La funzione mean(a) \u00e8 invece rappresentativa della media aritmetica degli elementi di un array, ed equivale alla funzione average(a) senza la specifica del vettore dei pesi. Ad esempio: >>> np . mean ( a ) 6.5 Concludiamo ricordando che anche in questo caso possiamo specificare il valore del parametro axis: >>> b array ([[ 4 , 8 , 0 ], [ 6 , 2 , 0 ], [ 5 , 9 , 7 ]], dtype = int64 ) >>> np . mean ( b , axis = 0 ) array ([ 5. , 6.33333333 , 2.33333333 ]) >>> np . mean ( b , axis = 1 ) array ([ 4. , 2.66666667 , 7. ])","title":"Media aritmetica e media pesata"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#varianza-e-deviazione-standard","text":"Non possono mancare le funzioni std(a) e var(a) , dedicate al calcolo della deviazione standard e della varianza di un vettore: >>> a array ([ 7 , 7 , 7 , 5 ], dtype = int64 ) >>> np . std ( a ) 0.8660254037844386 >>> np . var ( a ) 0.75 Anche in questo caso, possiamo specificare gli assi lungo i quali effettuare l'operazione desiderata: >>> np . var ( b , axis = 0 ) array ([ 0.66666667 , 9.55555556 , 10.88888889 ]) >>> np . var ( b , axis = 1 ) array ([ 10.66666667 , 6.22222222 , 2.66666667 ])","title":"Varianza e deviazione standard"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#matrice-di-covarianza","text":"La matrice di covarianza \u00e8 la matrice che racchiude tutti i coefficienti di correlazione , che ci permetteno di valutare come una certa variabile \\(x_i\\) varia al variare di un'altra variabile \\(x_j\\) . In generale, esistono diversi tipi di coefficienti di correlazione; il pi\u00f9 semplice \u00e8 quello di Pearson, che stima una correlazione di tipo lineare (ovvero, \u00e8 tanto pi\u00f9 alto quanto le due variabili crescono secondo un rapporto lineare), ed \u00e8 quello usato dalle funzioni cov(a) e corrcoef(a) , la seconda delle quali riporta i valori normalizzati dei risultati ottenibili anche con la prima. In questo caso, a pu\u00f2 essere monodimensionale o bidimensionale, ma ogni riga di a rappresenta una variabile , mentre ogni colonna rappresenta una osservazione . Facciamo qualche esempio. Immaginiamo di avere due variabili che assumono rispettivamente valori [1, 2, 3] e [4, 5, 6] . In questo caso, \u00e8 evidente come la correlazione sia massima, in quanto le osservazioni della seconda variabile hanno un semplice offset (o bias ) rispetto a quelle della prima. Proviamo a calcolare la matrice di correlazione: >>> x = np . array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> x array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> np . cov ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , 1. ], [ 1. , 1. ]]) Notiamo che, dato che i coefficienti di correlazione assumono valore pari ad 1, le due variabili sono fortemente correlate tra loro. Se invece avessimo una situazione di questo tipo: >>> x = np . array ([[ 1 , 2 , 3 ], [ - 1 , - 2 , - 3 ]]) >>> np . cov ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) >>> np . corrcoef ( x ) array ([[ 1. , - 1. ], [ - 1. , 1. ]]) In questo caso, \u00e8 evidente come le variabili siano anticorrelate , il che significa che quando la prima sale, la seconda scende, e viceversa. Per apprezzare le differenze tra le funzioni cov e corrcoef , dobbiamo usare valori differenti (e non banali) per x . Ad esempio: >>> x = np . array ([[ 2 , 3 , - 1 ], [ 1 , 5 , 2 ], [ 4 , 2 , 2 ]]) >>> np . cov ( x ) array ([[ 4.33333333 , 2.16666667 , 0.66666667 ], [ 2.16666667 , 4.33333333 , - 1.66666667 ], [ 0.66666667 , - 1.66666667 , 1.33333333 ]]) >>> np . corrcoef ( x ) array ([[ 1. , 0.5 , 0.2773501 ], [ 0.5 , 1. , - 0.69337525 ], [ 0.2773501 , - 0.69337525 , 1. ]]) In sostanza, corrcoef restituisce la matrice dei coefficienti \\(R\\) , la cui relazione con la matrice di covarianza \\(C\\) restituita da cov \u00e8: \\[ R_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} * C_{jj}}} \\]","title":"Matrice di covarianza"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#istogramma","text":"Un istogramma offre una visualizzazione grafica dei valori contenuti in un vettore, raggruppandoli all'interno di un certo numero di partizioni ( bin ). Ad esempio, una possibile rappresentazione a due partizioni del vettore \\(A = [1, 2, 3, 4]\\) \u00e8 data dal vettore \\([2, 2]\\) . Questo si spiega col fatto che le due partizioni suddividono il range di valori assunti da \\(A\\) in due parti, con la prima inerente gli elementi \\(1\\) e \\(2\\) , e la seconda gli elementi \\(3\\) e \\(4\\) . Una volta calcolate le partizioni, queste andranno \"riempite\" contando il numero di elementi presenti in ciascuna partizione, il che ci riporta al vettore \\([2, 2]\\) . Nota Ovviamente, \u00e8 possibile specificare, oltre al numero di partizioni, anche gli estremi delle stesse, che potrebbero non coincidere con quelli del vettore. NumPy ci permette di ottenere l'istogramma di un vettore mediante l'insieme di funzioni histogram(a, bins, range) , che ci permette di calcolare l'istogramma (monodimensionale) dell'array a in funzione del numero di partizioni (opzionale) e del range (opzionale). Ad esempio: >>> a = rng . integers ( low = 0 , high = 10 , size = 100 ) >>> h , b = np . histogram ( a ) >>> h array ([ 9 , 9 , 11 , 10 , 15 , 8 , 12 , 11 , 5 , 10 ], dtype = int64 ) >>> b array ([ 0. , 0.9 , 1.8 , 2.7 , 3.6 , 4.5 , 5.4 , 6.3 , 7.2 , 8.1 , 9. ]) In questo caso, abbiamo lasciato il valore di default di bins , ovvero 10.","title":"Istogramma"},{"location":"material/02_libs/07_numpy/12_statistics/lecture/#conclusioni","text":"In questa lezione, abbiamo visto alcune delle principali potenzialit\u00e0 offerte da NumPy in ambito statistico. Con questo, abbiamo terminato la nostra \"panoramica\" su NumPy.","title":"Conclusioni"},{"location":"material/02_libs/08_matplotlib/lecture/","text":"Visualizzare i dati con Matplotlib (e Seaborn) \u00b6 Finora ci siamo limitati a visualizzare dati e risultati usando esclusivamente la riga di comando. Evidentemente, per\u00f2, questo non \u00e8 il modo ottimale di procedere: cosa ne \u00e8, infatti, di tutti quei coloratissimi grafici che si vedono in giro? In realt\u00e0, visualizzarli \u00e8 abbastanza semplice: abbiamo bisogno, infatti, di integrare il nostro ambiente con delle altre librerie, ovvero Matplotlib e, opzionalmente, Seaborn . Matplotlib \u00b6 Installazione \u00b6 Partiamo proprio da Matplotlib , che \u00e8 probabilmente la pi\u00f9 usata tra le librerie disponibili per la visualizzazione dati. Iniziamo installandola all'interno del nostro ambiente di lavoro: ===\"Pip\" pip install matplotlib ===\"Pipenv\" pipenv install matplotlib Nel prosieguo, presupporremo che siano stati effettuati gli import necessari, riassumibili nelle seguenti istruzioni: import numpy as np import matplotlib.pylot as plt Il primo plot \u00b6 Una volta installata Matplotlib, proviamo a creare il nostro primo plot. Per farlo, apriamo il nostro solito terminale Python, ed inseriamo le seguenti istruzioni: rng = np . random . default_rng ( 42 ) x = np . arange ( 1 , 6 ) y = rng . integers ( low = 0 , high = 10 , size = 5 ) fig , ax = plt . subplots () ax . plot ( x , y ) plt . show () Se tutto \u00e8 andato per il verso giusto, dovremmo vedere a schermo un'immagine simile a questa (data la natura casuale di y ): A questo punto, \u00e8 arrivato il momento di descrivere maggiormente nel dettaglio ci\u00f2 che abbiamo fatto. Figure, assi ed artisti \u00b6 Alla base del funzionamento di Matplotlib abbiamo quattro classi fondamentali. Per prima cosa, ci sono le Figure , che rappresentano l'intera figura mostrata da Matplotlib. Questa, ovviamente, terr\u00e0 traccia di tutto ci\u00f2 che vi \u00e8 al suo interno, e potr\u00e0 contenere un numero arbitrario degli elementi che vedremo a breve. Abbiamo poi gli Axes , oggetti che rappresentano il plot vero e proprio, ovvero la regione dell'immagine all'interno del quale vengono \"disegnati\" i dati. La relazione tra Figure ed Axes \u00e8 strettamente gerarchica: una Figure pu\u00f2 avere diversi Axes , ma ogni Axes appartiene esclusivamente ad una Figure . All'interno di un oggetto Axes troviamo poi due o tre oggetti di tipo Axis , ognuno dei quali rappresenta l'asse vero e proprio (in altri termini, \\(x\\) , \\(y\\) e, per le figure tridimensionali, \\(z\\) ). Gli oggetti Axis ci permettono quindi di definire gli intervalli dati, l'eventuale griglia, e via discorrendo. Attenzione Fate attenzione a non confondere gli Axes con gli Axis , nonostante l'infelice scelta dei nomi! In ultimo, abbiamo gli artist , che rappresentano tutto quello che \u00e8 possibile visualizzare su una figura, incluso testo, label, plot, numeri, e via discorrendo. Torniamo brevemente al precedente snippet. Dopo aver importato i package necessari, ed aver creato un vettore di numeri interi casuali, abbiamo creato una Figure ed un Axes usando la funzione subplots() : fig , ax = plt . subplots () A quel punto, abbiamo effettuato il plot dei valori di x ed y su nostro oggetto Axes : ax . plot ( x , y ) In ultimo, abbiamo mostrato a schermo la figura usando la funzione plt.show() . Vediamo qualche esempio pi\u00f9 \"corposo\". Esempio 1: Plot di pi\u00f9 funzioni \u00b6 In questo esempio, vogliamo mostrare sullo stesso Axes il plot di due diverse funzioni, in particolare una retta ed un seno. Ricordiamo che questo \u00e8 possibile grazie al fatto che i plot vengono considerati degli artist, e quindi \u00e8 possibile inserirne un numero arbitrario. Vediamo come fare. Per prima cosa, definiamo i nostri dati: x = np . arange ( 0. , 10. , 0.01 ) y_1 = 1 + 2 * x y_2 = np . sin ( x ) Notiamo che stiamo usando un unico vettore per le ascisse, di modo da fornire una base comune al nostro plot. Adesso, creiamo la nostra Figure con relativo Axes , ed effettuiamo il plot di entrambe le funzioni. fig , ax = plt . subplots () ax . plot ( x , y_1 ) ax . plot ( x , y_2 ) Possiamo impostare il titolo e le label sugli assi \\(x\\) ed \\(y\\) usando rispettivamente le funzioni set_title , set_xlabel e set_ylabel : ax . set_title ( 'Plot di due funzioni matematiche' ) ax . set_xlabel ( 'Asse x' ) ax . set_ylabel ( 'Asse y' ) ax . grid () Abbiamo anche usato la funzione grid() per far apparire una griglia sulla figura. In ultimo, possiamo plottare a schermo la figura con la funzione show() : plt . show () Il risultato ottenuto \u00e8 mostrato in figura. Esempio 2: Subplot \u00b6 Abbiamo detto che possiamo definire pi\u00f9 Axes per un'unica Figure ; per farlo, possiamo parametrizzare la funzione subplots(i, j) , in maniera tale che vengano creati \\(i \\times j\\) plot all'interno della stessa figura. Per creare 2 subplot in \"riga\", ad esempio, usiamo questa istruzione: fig , ( ax_1 , ax_2 ) = plt . subplots ( 2 , 1 ) Possiamo poi usare la funzione suptitle() per dare un titolo all'intera figura: fig . suptitle ( 'Due subplot di pi\u00f9 funzioni matematiche' ) A questo punto, procediamo ad effettuare i plot sui relativi assi nella solita maniera: # Primo subplot ax_1 . plot ( x , y_1 ) ax_1 . set_ylabel ( 'Asse y' ) ax_1 . grid () # Secondo subplot ax_2 . plot ( x , y_2 ) ax_2 . set_xlabel ( 'Asse x' ) ax_2 . set_ylabel ( 'Asse y' ) ax_2 . grid () # Mostro la figura plt . show () Il risultato sar\u00e0 simile a quello mostrato in figura: Esempio 3: Rappresentazione di un istogramma \u00b6 Abbiamo gi\u00e0 parlato degli istogrammi in precedenza. Tuttavia, la loro vera potenza sta nella rappresentazione visiva che offrono, ed in tal senso Matplotlib ci viene in soccorso offrendoci la funzione hist . Per prima cosa, creiamo un vettore di interi. x = rng . integers ( low = 0 , high = 100 , size = 1000 ) Al solito, creiamo la nostra figura, ed usiamo la funzione hist passandogli il vettore x creato in precedenza ed il parametro density , che ci permetter\u00e0 di normalizzare l'istogramma (ovvero, fare in modo tale che la sommatoria dei singoli bin sia esattamente pari ad 1). fig , ax = plt . subplots () ax . hist ( x , density = True ) Al solito, usiamo i metodi opportuni per impostare titolo e label degli assi, e mostriamo la figura. ax . set_xlabel ( 'Bin' ) ax . set_ylabel ( 'Conteggio dei singoli elementi' ) ax . set_title ( 'Esempio di istogramma' ) plt . show () Il risultato sar\u00e0 simile a quello mostrato nella figura successiva. Esempio 4: Plot tridimensionale \u00b6 Concludiamo questa breve carrellata mostrando un esempio di plot a tre dimensioni. Questa volta, dovremo passare alla funzione subplots l'argomento 'projection': '3d' , per indicargli che il plot ha tre assi al posto dei soliti due. fig , ax = plt . subplots ( subplot_kw = { \"projection\" : \"3d\" }) Creiamo i nostri dati, avendo cura di usare la funzione meshgrid() per creare una griglia rettangolare a partire dai valori iniziali degli array x ed y , grazie a cui potremo poi creare la figura tridimensionale vera e propria. x = np . arange ( - 10 , 10 , 0.25 ) y = np . arange ( - 5 , 15 , 0.25 ) x , y = np . meshgrid ( z , y ) z = np . cos ( np . sqrt ( x ** 2 + y ** 2 )) A questo punto, usiamo la funzione plot_surface() per plottare i tre assi, impostiamone il titolo e mostriamo l'immagine a schermo. ax . plot_surface ( x , y , z ) ax . set_title ( 'Un esempio di plot tridimensionale' ) plt . show () Il risultato che otterremo sar\u00e0 simile a questo. Seaborn \u00b6 Seaborn \u00e8 una libreria che estende Matplotlib, integrando diverse opzioni e funzionalit\u00e0 a quelle gi\u00e0 esistenti. Vediamo rapidamente un esempio. Installazione \u00b6 Per prima cosa, installiamo la libreria nel modo usuale: ===\"Pip\" pip install seaborn ===\"Pipenv\" pipenv install seaborn Importiamo poi Seaborn nel nostro script: import seaborn as sns Esempio: Heatmap \u00b6 La sintassi usata da Seaborn \u00e8 molto simile a quella usata da Matplotlib, con qualche piccola ed ovvia differenza. Una funzione molto utile \u00e8 quella che ci permette di visualizzare le heatmap , che ci permettono di visualizzare rapidamente i valori in diversi tipi di matrici, come ad esempio quelle di correlazione (o, come vedremo pi\u00f9 avanti, quelle di confusione). Questa funzione, quasi \"banalmente\", \u00e8 chiamata heatmap() , e richiede almeno un parametro in ingresso, rappresentativo della matrice da cui sar\u00e0 estratta la figura: a = rng . integers ( low = 0 , high = 100 , size = ( 20 , 20 )) coeff = np . corrcoef ( a ) fig , ax = plt . subplots () sns . heatmap ( corr ) plt . show () Il risultato che otterremo sar\u00e0 simile a questo: Conclusioni \u00b6 In questa lezione, abbiamo dato una panoramica su due delle librerie pi\u00f9 usate per la visualizzazione dei dati in Python. Nella prossima lezione, toccheremo brevemente un'altra libreria, molto usata soprattutto in ambito scientifico, ovvero SciPy.","title":"08 - Visualizzazione di dati"},{"location":"material/02_libs/08_matplotlib/lecture/#visualizzare-i-dati-con-matplotlib-e-seaborn","text":"Finora ci siamo limitati a visualizzare dati e risultati usando esclusivamente la riga di comando. Evidentemente, per\u00f2, questo non \u00e8 il modo ottimale di procedere: cosa ne \u00e8, infatti, di tutti quei coloratissimi grafici che si vedono in giro? In realt\u00e0, visualizzarli \u00e8 abbastanza semplice: abbiamo bisogno, infatti, di integrare il nostro ambiente con delle altre librerie, ovvero Matplotlib e, opzionalmente, Seaborn .","title":"Visualizzare i dati con Matplotlib (e Seaborn)"},{"location":"material/02_libs/08_matplotlib/lecture/#matplotlib","text":"","title":"Matplotlib"},{"location":"material/02_libs/08_matplotlib/lecture/#installazione","text":"Partiamo proprio da Matplotlib , che \u00e8 probabilmente la pi\u00f9 usata tra le librerie disponibili per la visualizzazione dati. Iniziamo installandola all'interno del nostro ambiente di lavoro: ===\"Pip\" pip install matplotlib ===\"Pipenv\" pipenv install matplotlib Nel prosieguo, presupporremo che siano stati effettuati gli import necessari, riassumibili nelle seguenti istruzioni: import numpy as np import matplotlib.pylot as plt","title":"Installazione"},{"location":"material/02_libs/08_matplotlib/lecture/#il-primo-plot","text":"Una volta installata Matplotlib, proviamo a creare il nostro primo plot. Per farlo, apriamo il nostro solito terminale Python, ed inseriamo le seguenti istruzioni: rng = np . random . default_rng ( 42 ) x = np . arange ( 1 , 6 ) y = rng . integers ( low = 0 , high = 10 , size = 5 ) fig , ax = plt . subplots () ax . plot ( x , y ) plt . show () Se tutto \u00e8 andato per il verso giusto, dovremmo vedere a schermo un'immagine simile a questa (data la natura casuale di y ): A questo punto, \u00e8 arrivato il momento di descrivere maggiormente nel dettaglio ci\u00f2 che abbiamo fatto.","title":"Il primo plot"},{"location":"material/02_libs/08_matplotlib/lecture/#figure-assi-ed-artisti","text":"Alla base del funzionamento di Matplotlib abbiamo quattro classi fondamentali. Per prima cosa, ci sono le Figure , che rappresentano l'intera figura mostrata da Matplotlib. Questa, ovviamente, terr\u00e0 traccia di tutto ci\u00f2 che vi \u00e8 al suo interno, e potr\u00e0 contenere un numero arbitrario degli elementi che vedremo a breve. Abbiamo poi gli Axes , oggetti che rappresentano il plot vero e proprio, ovvero la regione dell'immagine all'interno del quale vengono \"disegnati\" i dati. La relazione tra Figure ed Axes \u00e8 strettamente gerarchica: una Figure pu\u00f2 avere diversi Axes , ma ogni Axes appartiene esclusivamente ad una Figure . All'interno di un oggetto Axes troviamo poi due o tre oggetti di tipo Axis , ognuno dei quali rappresenta l'asse vero e proprio (in altri termini, \\(x\\) , \\(y\\) e, per le figure tridimensionali, \\(z\\) ). Gli oggetti Axis ci permettono quindi di definire gli intervalli dati, l'eventuale griglia, e via discorrendo. Attenzione Fate attenzione a non confondere gli Axes con gli Axis , nonostante l'infelice scelta dei nomi! In ultimo, abbiamo gli artist , che rappresentano tutto quello che \u00e8 possibile visualizzare su una figura, incluso testo, label, plot, numeri, e via discorrendo. Torniamo brevemente al precedente snippet. Dopo aver importato i package necessari, ed aver creato un vettore di numeri interi casuali, abbiamo creato una Figure ed un Axes usando la funzione subplots() : fig , ax = plt . subplots () A quel punto, abbiamo effettuato il plot dei valori di x ed y su nostro oggetto Axes : ax . plot ( x , y ) In ultimo, abbiamo mostrato a schermo la figura usando la funzione plt.show() . Vediamo qualche esempio pi\u00f9 \"corposo\".","title":"Figure, assi ed artisti"},{"location":"material/02_libs/08_matplotlib/lecture/#esempio-1-plot-di-piu-funzioni","text":"In questo esempio, vogliamo mostrare sullo stesso Axes il plot di due diverse funzioni, in particolare una retta ed un seno. Ricordiamo che questo \u00e8 possibile grazie al fatto che i plot vengono considerati degli artist, e quindi \u00e8 possibile inserirne un numero arbitrario. Vediamo come fare. Per prima cosa, definiamo i nostri dati: x = np . arange ( 0. , 10. , 0.01 ) y_1 = 1 + 2 * x y_2 = np . sin ( x ) Notiamo che stiamo usando un unico vettore per le ascisse, di modo da fornire una base comune al nostro plot. Adesso, creiamo la nostra Figure con relativo Axes , ed effettuiamo il plot di entrambe le funzioni. fig , ax = plt . subplots () ax . plot ( x , y_1 ) ax . plot ( x , y_2 ) Possiamo impostare il titolo e le label sugli assi \\(x\\) ed \\(y\\) usando rispettivamente le funzioni set_title , set_xlabel e set_ylabel : ax . set_title ( 'Plot di due funzioni matematiche' ) ax . set_xlabel ( 'Asse x' ) ax . set_ylabel ( 'Asse y' ) ax . grid () Abbiamo anche usato la funzione grid() per far apparire una griglia sulla figura. In ultimo, possiamo plottare a schermo la figura con la funzione show() : plt . show () Il risultato ottenuto \u00e8 mostrato in figura.","title":"Esempio 1: Plot di pi\u00f9 funzioni"},{"location":"material/02_libs/08_matplotlib/lecture/#esempio-2-subplot","text":"Abbiamo detto che possiamo definire pi\u00f9 Axes per un'unica Figure ; per farlo, possiamo parametrizzare la funzione subplots(i, j) , in maniera tale che vengano creati \\(i \\times j\\) plot all'interno della stessa figura. Per creare 2 subplot in \"riga\", ad esempio, usiamo questa istruzione: fig , ( ax_1 , ax_2 ) = plt . subplots ( 2 , 1 ) Possiamo poi usare la funzione suptitle() per dare un titolo all'intera figura: fig . suptitle ( 'Due subplot di pi\u00f9 funzioni matematiche' ) A questo punto, procediamo ad effettuare i plot sui relativi assi nella solita maniera: # Primo subplot ax_1 . plot ( x , y_1 ) ax_1 . set_ylabel ( 'Asse y' ) ax_1 . grid () # Secondo subplot ax_2 . plot ( x , y_2 ) ax_2 . set_xlabel ( 'Asse x' ) ax_2 . set_ylabel ( 'Asse y' ) ax_2 . grid () # Mostro la figura plt . show () Il risultato sar\u00e0 simile a quello mostrato in figura:","title":"Esempio 2: Subplot"},{"location":"material/02_libs/08_matplotlib/lecture/#esempio-3-rappresentazione-di-un-istogramma","text":"Abbiamo gi\u00e0 parlato degli istogrammi in precedenza. Tuttavia, la loro vera potenza sta nella rappresentazione visiva che offrono, ed in tal senso Matplotlib ci viene in soccorso offrendoci la funzione hist . Per prima cosa, creiamo un vettore di interi. x = rng . integers ( low = 0 , high = 100 , size = 1000 ) Al solito, creiamo la nostra figura, ed usiamo la funzione hist passandogli il vettore x creato in precedenza ed il parametro density , che ci permetter\u00e0 di normalizzare l'istogramma (ovvero, fare in modo tale che la sommatoria dei singoli bin sia esattamente pari ad 1). fig , ax = plt . subplots () ax . hist ( x , density = True ) Al solito, usiamo i metodi opportuni per impostare titolo e label degli assi, e mostriamo la figura. ax . set_xlabel ( 'Bin' ) ax . set_ylabel ( 'Conteggio dei singoli elementi' ) ax . set_title ( 'Esempio di istogramma' ) plt . show () Il risultato sar\u00e0 simile a quello mostrato nella figura successiva.","title":"Esempio 3: Rappresentazione di un istogramma"},{"location":"material/02_libs/08_matplotlib/lecture/#esempio-4-plot-tridimensionale","text":"Concludiamo questa breve carrellata mostrando un esempio di plot a tre dimensioni. Questa volta, dovremo passare alla funzione subplots l'argomento 'projection': '3d' , per indicargli che il plot ha tre assi al posto dei soliti due. fig , ax = plt . subplots ( subplot_kw = { \"projection\" : \"3d\" }) Creiamo i nostri dati, avendo cura di usare la funzione meshgrid() per creare una griglia rettangolare a partire dai valori iniziali degli array x ed y , grazie a cui potremo poi creare la figura tridimensionale vera e propria. x = np . arange ( - 10 , 10 , 0.25 ) y = np . arange ( - 5 , 15 , 0.25 ) x , y = np . meshgrid ( z , y ) z = np . cos ( np . sqrt ( x ** 2 + y ** 2 )) A questo punto, usiamo la funzione plot_surface() per plottare i tre assi, impostiamone il titolo e mostriamo l'immagine a schermo. ax . plot_surface ( x , y , z ) ax . set_title ( 'Un esempio di plot tridimensionale' ) plt . show () Il risultato che otterremo sar\u00e0 simile a questo.","title":"Esempio 4: Plot tridimensionale"},{"location":"material/02_libs/08_matplotlib/lecture/#seaborn","text":"Seaborn \u00e8 una libreria che estende Matplotlib, integrando diverse opzioni e funzionalit\u00e0 a quelle gi\u00e0 esistenti. Vediamo rapidamente un esempio.","title":"Seaborn"},{"location":"material/02_libs/08_matplotlib/lecture/#installazione_1","text":"Per prima cosa, installiamo la libreria nel modo usuale: ===\"Pip\" pip install seaborn ===\"Pipenv\" pipenv install seaborn Importiamo poi Seaborn nel nostro script: import seaborn as sns","title":"Installazione"},{"location":"material/02_libs/08_matplotlib/lecture/#esempio-heatmap","text":"La sintassi usata da Seaborn \u00e8 molto simile a quella usata da Matplotlib, con qualche piccola ed ovvia differenza. Una funzione molto utile \u00e8 quella che ci permette di visualizzare le heatmap , che ci permettono di visualizzare rapidamente i valori in diversi tipi di matrici, come ad esempio quelle di correlazione (o, come vedremo pi\u00f9 avanti, quelle di confusione). Questa funzione, quasi \"banalmente\", \u00e8 chiamata heatmap() , e richiede almeno un parametro in ingresso, rappresentativo della matrice da cui sar\u00e0 estratta la figura: a = rng . integers ( low = 0 , high = 100 , size = ( 20 , 20 )) coeff = np . corrcoef ( a ) fig , ax = plt . subplots () sns . heatmap ( corr ) plt . show () Il risultato che otterremo sar\u00e0 simile a questo:","title":"Esempio: Heatmap"},{"location":"material/02_libs/08_matplotlib/lecture/#conclusioni","text":"In questa lezione, abbiamo dato una panoramica su due delle librerie pi\u00f9 usate per la visualizzazione dei dati in Python. Nella prossima lezione, toccheremo brevemente un'altra libreria, molto usata soprattutto in ambito scientifico, ovvero SciPy.","title":"Conclusioni"},{"location":"material/02_libs/09_scipy/exercises/","text":"Risoluzione degli esercizi \u00b6 Scrivere due funzioni tali che: la prima restituisca un booleano se una matrice passata in ingresso \u00e8 invertibile; la seconda inverta la matrice in base ai risultati della funzione precedente. Usare SciPy. from scipy import linalg def invertibile ( mat ): if linalg . det ( mat ) != 0. : return True else : return False def inverti_se_invertibile ( mat ): if invertibile ( mat ): return linalg . inv ( mat ) else : return None","title":"E9 - Introduzione a SciPy"},{"location":"material/02_libs/09_scipy/exercises/#risoluzione-degli-esercizi","text":"Scrivere due funzioni tali che: la prima restituisca un booleano se una matrice passata in ingresso \u00e8 invertibile; la seconda inverta la matrice in base ai risultati della funzione precedente. Usare SciPy. from scipy import linalg def invertibile ( mat ): if linalg . det ( mat ) != 0. : return True else : return False def inverti_se_invertibile ( mat ): if invertibile ( mat ): return linalg . inv ( mat ) else : return None","title":"Risoluzione degli esercizi"},{"location":"material/02_libs/09_scipy/lecture/","text":"L'ecosistema SciPy \u00b6 Finora abbiamo parlato prevalentemente di NumPy e (soltanto in piccola parte) di Matplotlib. Tuttavia, entrambe queste librerie fanno parte di un ecosistema pi\u00f9 ampio per il calcolo scientifico, comprendente anche le librerie SciPy , iPython , Pandas e SimPy . Questo ecosistema \u00e8, per l'appunto, chiamato come una delle librerie che lo compongono, che \u00e8 anche quella di cui tratteremo (giocoforza limitatamente) in questa lezione, ovvero SciPy . La libreria SciPy \u00b6 La libreria SciPy rappresenta un insieme di algoritmi e funzioni matematiche costruite a partire da NumPy. Tuttavia, come \u00e8 possibile vedere dalla reference , il numero e la variet\u00e0 delle funzioni offerte \u00e8 notevolmente maggiore rispetto a NumPy. Per iniziare, quindi, procediamo installandola nel nostro ambiente di sviluppo. ===\"Pip\" pip install scipy ===\"Pipenv\" pipenv install scipy Nel prosieguo, presupporremo che siano stati gi\u00e0 importati NumPy e Matplotlib. import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt Esempio 1: Distribuzione di probabilit\u00e0 \u00b6 Vediamo come comparare visivamente il valore teorico assunto da due distribuzioni di probabilit\u00e0 \"standard\" (ovvero la uniforme e la normale) e l'istogramma ottenuto a partire da un elevato numero di elementi generati casualmente ma appartenenti a quella distribuzione. Useremo questo codice: from scipy.stats import norm , uniform x_1 = np . linspace ( norm . ppf ( 0.01 ), norm . ppf ( 0.99 ), 100 ) x_2 = np . linspace ( uniform . ppf ( 0.01 ), uniform . ppf ( 0.99 ), 100 ) r_1 = norm . rvs ( size = 1000 ) r_2 = uniform . rvs ( size = 1000 ) fig , ( ax_1 , ax_2 ) = plt . subplots ( 2 , 1 ) ax_1 . plot ( x_1 , norm . pdf ( x_1 )) ax_1 . hist ( r_1 , density = True ) ax_2 . plot ( x_2 , uniform . pdf ( x_2 )) ax_2 . hist ( r_2 , density = True ) plt . show () In primis, importiamo i moduli norm ed uniform del package scipy.stats , che contengono tutto quello di cui abbiamo bisogno per la modellazione delle distribuzioni normali ( norm ) ed uniformi ( uniform ). Successivamente, usiamo la funzione linspace di NumPy, il cui funzionamento \u00e8 molto simile a range ed arange , ma che restituisce risultati consistenti anche nel caso di uso di step non interi (il che non \u00e8 sempre garantito con arange ). In particolare, genereremo 100 campioni equidistanziati e compresi tra l'1 ed il 99 percentile delle funzioni; per individuare questi valori, usiamo la funzione ppf(p) : x_1 = np . linspace ( norm . ppf ( 0.01 ), norm . ppf ( 0.99 ), 100 ) x_2 = np . linspace ( uniform . ppf ( 0.01 ), uniform . ppf ( 0.99 ), 100 ) Nota Intuitivamente, individuare 100 valori compresi tra l'1 ed il 99 percentile significa in pratica modellare la maggior parte dell'intervallo dei valori assunti \"normalmente\" dalla funzione. A questo punto, calcoliamo 1000 valori generati casualmente seguendo entrambe le distribuzioni mediante la funzione rvs() : r_1 = norm . rvs ( size = 1000 ) r_2 = uniform . rvs ( size = 1000 ) Per terminare, generemo due subplot, uno relativo alla funzione densit\u00e0 di probabilit\u00e0 normale, ed uno relativo alla funzione densit\u00e0 di probabilit\u00e0 uniforme. Nei subplot, compareremo i valori equispaziati generati in precedenza ( x_1 ed x_2 ) con l'istogramma dei 1000 valori generati casualmente ( r_1 ed r_2 ); ovviamente, ricordiamo di inserire il valore density=True per normalizzare l'istogramma. Il risultato dovrebbe essere simile a quello mostrato in figura: Esempio 2: calcolo del determinante e dell'inversa \u00b6 Un altro esempio delle potenzialit\u00e0 offerte da SciPy sta nel calcolo algebrico, che offre molte pi\u00f9 funzioni rispetto a quelle presenti in NumPy, specialmente per quello che riguarda la fattorizzazione di matrici. Per fare un rapido esempio, vediamo come \u00e8 possibile calcolare il determinante e l'inversa di una matrice. from scipy import linalg # ... matrice mat creata sotto forma di array NumPy # Determinante d = linalg . det ( mat ) # Inversa i = linalg . inv ( mat ) Nota E' molto semplice otare come la sintassi richiami quella di NumPy e, in realt\u00e0, anche il funzionamento sia il medesimo, per cui \u00e8 possibile usare indifferentemente entrambe le librerie. Dove SciPy \"spicca\" \u00e8 in tutte quelle funzioni che non sono presenti in NumPy. Esempio 3: Trasformata di Fourier \u00b6 SciPy non \u00e8 limitato al calcolo algebrico e matriciale, e pu\u00f2 essere usato, come dicevamo, in molti altri ambiti, come ad esempio il signal processing. Ad esempio, possiamo sfruttarlo per calcolare la trasformata di Fourier di un segnale sinusoidale: from scipy.fft import fft x = np . linspace ( 0. , 10 , 1000 ) y = np . sin ( 2.0 * np . pi * x ) yf = fft ( y ) fig , ax = plt . subplots () ax . plot ( np . abs ( yf [ 0 : 500 ])) plt . show () Nell'esempio precedente, generiamo 1000 campioni equidistanziati tra 0 e 10, e quindi creiamo il vettore y la cui formula sar\u00e0 associata a \\(f(x) = 2\\pi x\\) . A quel punto, calcoliamo la trasformata di Fourier di y , e ne visualizziamo a schermo il modulo. Attenzione Ricordiamo che la trasformata di Fourier \u00e8 simmetrica. Per questo, visualizzeremo soltanto la prima met\u00e0 dei valori estratti per il modulo. Possiamo estendere il precedente esperimento vedendo cosa accade per una somma di seni: y_tr = np . sin ( 2.0 * np . pi * x ) + np . sin ( 20 * 2.0 * np . pi * x ) y_trf = fft ( y_tr ) ax . plot ( np . abs ( y_trf [ 0 : 500 ])) Come si deve dalla figura, avremo come risultato due impulsi: In ultimo, possiamo valutare anche cosa accade riducendo l'ampiezza di una delle due sinusoidi: y_tr = np . sin ( 2.0 * np . pi * x ) + 0.5 * np . sin ( 20 * 2.0 * np . pi * x ) y_trf = fft ( y_tr ) ax . plot ( np . abs ( y_trf [ 0 : 500 ])) Conclusioni \u00b6 In questa lezione, abbiamo dato una breve panoramica sulle possibilit\u00e0 offerte da SciPy. Nelle prossime, vedremo come funzionano altre due librerie, ovvero iPython e Pandas .","title":"09 - Introduzione a SciPy"},{"location":"material/02_libs/09_scipy/lecture/#lecosistema-scipy","text":"Finora abbiamo parlato prevalentemente di NumPy e (soltanto in piccola parte) di Matplotlib. Tuttavia, entrambe queste librerie fanno parte di un ecosistema pi\u00f9 ampio per il calcolo scientifico, comprendente anche le librerie SciPy , iPython , Pandas e SimPy . Questo ecosistema \u00e8, per l'appunto, chiamato come una delle librerie che lo compongono, che \u00e8 anche quella di cui tratteremo (giocoforza limitatamente) in questa lezione, ovvero SciPy .","title":"L'ecosistema SciPy"},{"location":"material/02_libs/09_scipy/lecture/#la-libreria-scipy","text":"La libreria SciPy rappresenta un insieme di algoritmi e funzioni matematiche costruite a partire da NumPy. Tuttavia, come \u00e8 possibile vedere dalla reference , il numero e la variet\u00e0 delle funzioni offerte \u00e8 notevolmente maggiore rispetto a NumPy. Per iniziare, quindi, procediamo installandola nel nostro ambiente di sviluppo. ===\"Pip\" pip install scipy ===\"Pipenv\" pipenv install scipy Nel prosieguo, presupporremo che siano stati gi\u00e0 importati NumPy e Matplotlib. import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt","title":"La libreria SciPy"},{"location":"material/02_libs/09_scipy/lecture/#esempio-1-distribuzione-di-probabilita","text":"Vediamo come comparare visivamente il valore teorico assunto da due distribuzioni di probabilit\u00e0 \"standard\" (ovvero la uniforme e la normale) e l'istogramma ottenuto a partire da un elevato numero di elementi generati casualmente ma appartenenti a quella distribuzione. Useremo questo codice: from scipy.stats import norm , uniform x_1 = np . linspace ( norm . ppf ( 0.01 ), norm . ppf ( 0.99 ), 100 ) x_2 = np . linspace ( uniform . ppf ( 0.01 ), uniform . ppf ( 0.99 ), 100 ) r_1 = norm . rvs ( size = 1000 ) r_2 = uniform . rvs ( size = 1000 ) fig , ( ax_1 , ax_2 ) = plt . subplots ( 2 , 1 ) ax_1 . plot ( x_1 , norm . pdf ( x_1 )) ax_1 . hist ( r_1 , density = True ) ax_2 . plot ( x_2 , uniform . pdf ( x_2 )) ax_2 . hist ( r_2 , density = True ) plt . show () In primis, importiamo i moduli norm ed uniform del package scipy.stats , che contengono tutto quello di cui abbiamo bisogno per la modellazione delle distribuzioni normali ( norm ) ed uniformi ( uniform ). Successivamente, usiamo la funzione linspace di NumPy, il cui funzionamento \u00e8 molto simile a range ed arange , ma che restituisce risultati consistenti anche nel caso di uso di step non interi (il che non \u00e8 sempre garantito con arange ). In particolare, genereremo 100 campioni equidistanziati e compresi tra l'1 ed il 99 percentile delle funzioni; per individuare questi valori, usiamo la funzione ppf(p) : x_1 = np . linspace ( norm . ppf ( 0.01 ), norm . ppf ( 0.99 ), 100 ) x_2 = np . linspace ( uniform . ppf ( 0.01 ), uniform . ppf ( 0.99 ), 100 ) Nota Intuitivamente, individuare 100 valori compresi tra l'1 ed il 99 percentile significa in pratica modellare la maggior parte dell'intervallo dei valori assunti \"normalmente\" dalla funzione. A questo punto, calcoliamo 1000 valori generati casualmente seguendo entrambe le distribuzioni mediante la funzione rvs() : r_1 = norm . rvs ( size = 1000 ) r_2 = uniform . rvs ( size = 1000 ) Per terminare, generemo due subplot, uno relativo alla funzione densit\u00e0 di probabilit\u00e0 normale, ed uno relativo alla funzione densit\u00e0 di probabilit\u00e0 uniforme. Nei subplot, compareremo i valori equispaziati generati in precedenza ( x_1 ed x_2 ) con l'istogramma dei 1000 valori generati casualmente ( r_1 ed r_2 ); ovviamente, ricordiamo di inserire il valore density=True per normalizzare l'istogramma. Il risultato dovrebbe essere simile a quello mostrato in figura:","title":"Esempio 1: Distribuzione di probabilit\u00e0"},{"location":"material/02_libs/09_scipy/lecture/#esempio-2-calcolo-del-determinante-e-dellinversa","text":"Un altro esempio delle potenzialit\u00e0 offerte da SciPy sta nel calcolo algebrico, che offre molte pi\u00f9 funzioni rispetto a quelle presenti in NumPy, specialmente per quello che riguarda la fattorizzazione di matrici. Per fare un rapido esempio, vediamo come \u00e8 possibile calcolare il determinante e l'inversa di una matrice. from scipy import linalg # ... matrice mat creata sotto forma di array NumPy # Determinante d = linalg . det ( mat ) # Inversa i = linalg . inv ( mat ) Nota E' molto semplice otare come la sintassi richiami quella di NumPy e, in realt\u00e0, anche il funzionamento sia il medesimo, per cui \u00e8 possibile usare indifferentemente entrambe le librerie. Dove SciPy \"spicca\" \u00e8 in tutte quelle funzioni che non sono presenti in NumPy.","title":"Esempio 2: calcolo del determinante e dell'inversa"},{"location":"material/02_libs/09_scipy/lecture/#esempio-3-trasformata-di-fourier","text":"SciPy non \u00e8 limitato al calcolo algebrico e matriciale, e pu\u00f2 essere usato, come dicevamo, in molti altri ambiti, come ad esempio il signal processing. Ad esempio, possiamo sfruttarlo per calcolare la trasformata di Fourier di un segnale sinusoidale: from scipy.fft import fft x = np . linspace ( 0. , 10 , 1000 ) y = np . sin ( 2.0 * np . pi * x ) yf = fft ( y ) fig , ax = plt . subplots () ax . plot ( np . abs ( yf [ 0 : 500 ])) plt . show () Nell'esempio precedente, generiamo 1000 campioni equidistanziati tra 0 e 10, e quindi creiamo il vettore y la cui formula sar\u00e0 associata a \\(f(x) = 2\\pi x\\) . A quel punto, calcoliamo la trasformata di Fourier di y , e ne visualizziamo a schermo il modulo. Attenzione Ricordiamo che la trasformata di Fourier \u00e8 simmetrica. Per questo, visualizzeremo soltanto la prima met\u00e0 dei valori estratti per il modulo. Possiamo estendere il precedente esperimento vedendo cosa accade per una somma di seni: y_tr = np . sin ( 2.0 * np . pi * x ) + np . sin ( 20 * 2.0 * np . pi * x ) y_trf = fft ( y_tr ) ax . plot ( np . abs ( y_trf [ 0 : 500 ])) Come si deve dalla figura, avremo come risultato due impulsi: In ultimo, possiamo valutare anche cosa accade riducendo l'ampiezza di una delle due sinusoidi: y_tr = np . sin ( 2.0 * np . pi * x ) + 0.5 * np . sin ( 20 * 2.0 * np . pi * x ) y_trf = fft ( y_tr ) ax . plot ( np . abs ( y_trf [ 0 : 500 ]))","title":"Esempio 3: Trasformata di Fourier"},{"location":"material/02_libs/09_scipy/lecture/#conclusioni","text":"In questa lezione, abbiamo dato una breve panoramica sulle possibilit\u00e0 offerte da SciPy. Nelle prossime, vedremo come funzionano altre due librerie, ovvero iPython e Pandas .","title":"Conclusioni"},{"location":"material/02_libs/10_pandas/lecture/","text":"Introduzione a Pandas \u00b6 Pandas \u00e8 l'ultima delle librerie dell'ecosistema SciPy che tratteremo, ma ci\u00f2 non toglie che \u00e8 un pezzo fondamentale dell'intero framework, in quanto viene usata per la lettura ed elaborazione dei dati provenienti da sorgenti di vario tipo. Installazione e configurazione di Pandas \u00b6 Al solito, provvediamo per prima cosa ad installare Pandas nel nostro ambiente di lavoro. ===\"Pip\" pip install pandas ===\"Pipenv\" pipenv install pandas Cos\u00ec come per le altre librerie (eccetto Jupyter), nel prosieguo presupporemo che Pandas sia importato nel nostro script (o, ancora meglio, nel nostro notebook): import pandas as pd I dati gestiti da Pandas \u00b6 Pandas gestisce dati tabulari , ossia dello stesso tipo di quelli comunemente contenuti nei fogli di calcolo o nei database. Questi dati sono sicuramente tra i pi\u00f9 diffusi ed utilizzati nell'ambito dell'analisi dati, se si escludono le immagini; per modellarli, Pandas ci mette a disposizione un'apposita struttura denominata DataFrame . Un DataFrame altro non \u00e8 se non una struttura dati di tipo bidimensionale, adatta a memorizzare dati di ogni tipo, inclusi stringhe, interi, float, ed altro. I dati sono organizzati in righe ( rows ) e colonne ( columns ), in maniera concettualmente analoga ad un foglio di calcolo o database; tuttavia, \u00e8 importante sottolinare come, per convenzione, le singole righe rappresentino i campioni del dataset, mentre le singole colonne siano associate ai valori assunti dalle feature per ciascun campione. Il primo DataFrame \u00b6 Facciamo un esempio. Scarichiamo il Titanic Dataset , e scompattiamo l'archivio. Al suo interno, troveremo tre file, ovvero gender_submission.csv , test.csv e train.csv . Per gli scopi di questa lezione, ci concentreremo soltanto sull'ultimo. Spostiamolo per prima cosa all'interno della nostra cartella di lavoro. A quel punto, usiamo questo codice per caricarlo all'interno di un DataFrame : df = pd . read_csv ( 'train.csv' ) Usiamo il metodo head() per mostrare a schermo le prime cinque righe del DataFrame. >>> df . head () PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund , Mr . Owen Harris male 22.0 1 0 A / 5 21171 7.2500 NaN S 1 2 1 1 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen , Miss . Laina female 26.0 0 0 STON / O2 . 3101282 7.9250 NaN S 3 4 1 1 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen , Mr . William Henry male 35.0 0 0 373450 8.0500 NaN S Vediamo poi i tipi di ciascuna delle colonne. >>> df . dtypes PassengerId int64 Survived int64 Pclass int64 Name object Sex object Age float64 SibSp int64 Parch int64 Ticket object Fare float64 Cabin object Embarked object dtype : object Notiamo subito la presenza di tre tipi di colonna, ovvero int64 , float64 ed object . Laddove i primi due sono autoesplicativi, merita una particolare menzione il tipo object , che viene associato automaticamente a tutte le stringhe. Suggerimento Normalmente, usare il tipo object comporta diversi problemi nella successiva fase di analisi dei dati. Potrebbe quindi essere una buona idea parametrizzare la funzione read_csv mediante il parametro dtype , che accetta un dizionario che specifica il tipo di una o pi\u00f9 colonne. Ad esempio, se volessimo specificare che i nomi sono delle stringhe, potremmo usare il tipo string : >>> types = { 'Name' : 'string' } >>> df = pd . read_csv ( 'train.csv' , dtype = types ) >>> df . dtypes # ... Name string # ... Le Series \u00b6 Abbiamo visto come ogni DataFrame sia composto da un insieme di colonne, ciascuna rappresentativa di una feature specifica. In realt\u00e0, Pandas offre una rappresentazione apposita per ciascuna di queste colonne, chiamata Series . Ad esempio, se volessimo isolare la colonna relativa agli identificativi numerici dei passeggeri, potremmo usare le seguenti istruzioni: >>> df [ 'PassengerId' ] . head () 0 1 1 2 2 3 3 4 4 5 Name : PassengerId , dtype : int64 >>> type ( df [ 'PassengerId' ]) < class ' pandas . core . series . Series '> Nota Possiamo creare sia una Series sia un DataFrame da zero usando gli appositi costruttori. Tuttavia, nella maggior parte dei casi, ci limiteremo a manipolare dati gi\u00e0 esistenti. L'indice del DataFrame \u00b6 Molto importante \u00e8 l' indice associato al DataFrame od alla Series . Notiamo infatti che, in entrambi i casi precedenti, \u00e8 stato associato ad ogni riga un indice numerico crescente, che possiamo utilizzare per recuperare uno specifico campione. Potremmo per\u00f2 decidere di usare una colonna del DataFrame come indice (nel nostro caso, ad esempio, PassengerId ); per farlo, possiamo passare l'apposito parametro index_col all'interno del metodo read_csv : df = pd . read_csv ( 'train.csv' , index_col = 'PassengerId' ) Verifichiamo che il nuovo DataFrame abbia come indice la colonna PassengerId : >>> df . head () Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund , Mr . Owen Harris male 22.0 1 0 A / 5 21171 7.2500 NaN S 2 1 1 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen , Miss . Laina female 26.0 0 0 STON / O2 . 3101282 7.9250 NaN S 4 1 1 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen , Mr . William Henry male 35.0 0 0 373450 8.0500 NaN S >>> df . index Int64Index ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , ... 882 , 883 , 884 , 885 , 886 , 887 , 888 , 889 , 890 , 891 ], dtype = 'int64' , name = 'PassengerId' , length = 891 ) Formati di dato (in ingresso ed in uscita) \u00b6 Finora abbiamo usato la funzione read_csv per creare un DataFrame a partire dai dati memorizzati in un file in formato CSV. Tuttavia, Pandas, supporta molti altri formati: ad esempio, potremmo leggere un file XLSX (Excel): df = pd . read_excel ( 'dati.xlsx' ) Attenzione Per leggere (e scrivere) da (su) Excel \u00e8 necessario installare la libreria openpyxl ( pip install openpyxl ). oppure un file in formato JSON: df = pd . read_json ( 'dati.json' ) o ancora direttamente da un database: df = pd . read_sql ( SQL_QUERY ) Per un elenco completo delle funzioni disponibili, il rimando \u00e8 alla reference ; la sintassi \u00e8 comunque quasi sempre read_*(data_source) , con * da sostituire con il tipo di sorgente dati ( csv , excel , etc.). Esiste anche la funzione duale, che usa il suffisso to_ al posto di read_ , e permette di scrivere un DataFrame su file. Ad esempio, se volessimo scrivere su un file XLSX: df . to_excel ( 'train.xlsx' ) Aggiungere feature e dati \u00b6 Aggiunta di una nuova feature \u00b6 Immaginiamo di voler aggiungere una nuova feature ad un DataFrame esistente. Per farlo, iniziamo creando un DataFrame di esempio: >>> df = pd . DataFrame ([ 1 , 2 , 3 , 4 , 5 ], columns = [ 'one' ]) >>> df one 0 1 1 2 2 3 3 4 4 5 Possiamo aggiungere una nuova colonna semplicemente usando l'operatore di assegnazione e specificandone il nome: >>> df [ 'two' ] = df [ 'one' ] * 2 >>> df one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10 Aggiunta di nuovi campioni \u00b6 Possiamo poi aggiungere nuovi campioni in coda al DataFrame . Per farlo, possiamo creare un nuovo DataFrame , le cui colonne devono essere coerenti con quello gi\u00e0 esistente, e poi usare la funzione insert : >>> df_add = pd . DataFrame ([[ 6 , 7 ]], columns = [ 'one' , 'two' ]) >>> df . append ( df_add ) one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10 0 6 7 Concatenazione di DataFrame \u00b6 Possiamo usare la funzione concat per concatenare due (o pi\u00f9) DataFrame . Ad esempio, possiamo concatenare due DataFrame per colonne usando il parametro axis=1 : >>> df_con_col = pd . DataFrame ([ 3 , 6 , 9 , 12 , 15 ], columns = [ 'three' ]) >>> pd . concat ([ df , df_con_col ], axis = 1 ) one two three 0 1 2 3 1 2 4 6 2 3 6 9 3 4 8 12 4 5 10 15 Usando il parametro axis=0 , si effettua una concatenazione per righe (campioni): >>> df_con_row = pd . DataFrame ([[ 6 , 7 ]], columns = [ 'one' , 'two' ]) >>> pd . concat ([ df , df_con_row ]) one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10 0 6 7 Nota Notiamo che concat accetta una lista di DataFrame . Scegliere i dati \u00b6 Dimensioni del DataFrame \u00b6 Per conoscere le dimensioni del DataFrame sotto analisi, possiamo usare l'attributo shape . Ovviamente, l'attributo \u00e8 analogo a quello usato in NumPy, e restituisce il numero di campioni e feature contenuti nel DataFrame . Ad esempio: >>> df . shape ( 891 , 11 ) Selezionare un insieme di colonne \u00b6 Immaginiamo di voler selezionare soltanto le colonne relative alle caratteristiche anagrafiche dei passeggeri, ad esempio nome, genere ed et\u00e0. In modo simile a come si opera su un array NumPy, possiamo usare la seguente notazione: >>> passengers_anagraphical = df [[ 'Name' , 'Sex' , 'Age' ]] >>> passengers_anagraphical . head () Name Sex Age PassengerId 1 Braund , Mr . Owen Harris male 22.0 2 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 3 Heikkinen , Miss . Laina female 26.0 4 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 5 Allen , Mr . William Henry male 35.0 In pratica, stiamo semplicemente selezionando alcune colonne del DataFrame . Attenzione I nomi delle colonne devono essere validi e presenti nel DataFrame . Selezionare un insieme di campioni in base ad una o pi\u00f9 condizioni \u00b6 Supponiamo di voler selezionare soltanto gli uomini maggiorenni presenti nel DataFrame . Per farlo, usiamo la seguente istruzione: >>> men = df [( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' )] >>> men . head () Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.2500 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.0500 NaN S 7 0 1 McCarthy , Mr . Timothy J male ... 17463 51.8625 E46 S 13 0 3 Saundercock , Mr . William Henry male ... A / 5. 2151 8.0500 NaN S 14 0 3 Andersson , Mr . Anders Johan male ... 347082 31.2750 NaN S In pratica, stiamo filtrando il DataFrame in base a due condizioni: df['Age'] > 18 : questa condizione genera una maschera booleana che \u00e8 True soltanto se l'et\u00e0 per quel passeggero \u00e8 maggiore di 18 anni; df['Sex'] == 'male' : questa condizione genera una maschera booleana che \u00e8 vera soltanto se il genere del passeggero \u00e8 maschile. Possiamo combinare le due condizioni mediante un and logico per ottenere la maschera complessiva: ( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' ) A quel punto, estraiamo i campioni in cui la maschera \u00e8 vera: df [( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' )] Le funzioni loc ed iloc \u00b6 Possiamo anche selezionare dei sottoinsiemi di dati in maniera non dissimile da come faremmo con gli array NumPy. Per farlo, abbiamo a disposizione due funzioni, ovvero loc ed iloc . Entrambe permettono di selezionare un sottoinsieme di campioni mediante slicing. Ad esempio: >>> df . loc [: 5 : 2 ] Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.250 NaN S 3 1 3 Heikkinen , Miss . Laina female ... STON / O2 . 3101282 7.925 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.050 NaN S >>> df . iloc [: 5 : 2 ] Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.250 NaN S 3 1 3 Heikkinen , Miss . Laina female ... STON / O2 . 3101282 7.925 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.050 NaN S La differenza tra le due funzioni sta principalmente nell'indicizzazione delle colonne. Infatti, la funzione loc si attende il nome della colonna: >>> df . loc [: 5 , 'Survived' ] PassengerId 1 0 2 1 3 1 4 1 5 0 D'altro canto, iloc (composizione di integer location ) si attende l'indice numerico, su cui si pu\u00f2 ovviamente anche applicare lo slicing: >>> df . iloc [: 5 , 0 ] PassengerId 1 0 2 1 3 1 4 1 5 0 Visualizzazione dei dati in Pandas \u00b6 Pandas offre un supporto nativo ad un backend Matplotlib per la visualizzazione dei dati; per farlo, basta usare la funzione plot() su una Series o su un intero DataFrame . Ad esempio, se volessimo plottare le et\u00e0 dei passeggeri: >>> df [ 'Age' ] . plot () >>> plt . show () Il risultato sar\u00e0 mostrato in figura. Possiamo anche fare il plot dell'intero DataFrame : >>> df . plot () >>> plt . show () Il risultato \u00e8 mostrato in figura. Istogrammi ed altro \u00b6 Ovviamente, \u00e8 possibile usare Pandas anche per fare il plot di altri tipi di grafico, come ad esempio gli istogrammi. Per farlo, si usano le apposite sotto-funzioni di plot : >>> df [ 'Age' ] . plot . hist () >>> plt . show () Il risultato \u00e8 mostrato in figura. Statistiche su un DataFrame \u00b6 Pandas ci mette a disposizione delle funzioni, simili a quelle offerte da NumPy, per calcolare delle statistiche per ciascuna delle colonne presenti in un DataFrame. Ad esempio: >>> df . mean () PassengerId 446.000000 Survived 0.383838 Pclass 2.308642 Age 29.699118 SibSp 0.523008 Parch 0.381594 Fare 32.204208 dtype : float64 Ovviamente, esistono funzioni anche per calcolare varianza ( df.var() ), mediana ( df.median() ), deviazione standard ( df.std() ), e via discorrendo. Particolarmente interessante \u00e8 la funzione describe() , che ci mosta tutte le statistiche pi\u00f9 significative per ognuna delle feature considerate. >>> df . describe () PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 714.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 29.699118 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 14.526497 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25 % 223.500000 0.000000 2.000000 20.125000 0.000000 0.000000 7.910400 50 % 446.000000 0.000000 3.000000 28.000000 0.000000 0.000000 14.454200 75 % 668.500000 1.000000 3.000000 38.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 La funzione groupby \u00b6 Possiamo sfruttare la funzione groupby per raggruppare insiemi di dati (normalmente pertinenti a categorie ). Ad esempio, potremmo raggruppare i passeggeri per genere: >>> df . groupby ([ 'Sex' ]) Possiamo ovviamente estrarre delle statistiche a partire da questi raggruppamenti. Vediamo, ad esempio, l'et\u00e0 media dei passeggeri di sesso femminile e maschile: >>> df . groupby ([ 'Sex' ])[ 'Age' ] . mean () Sex female 27.915709 male 30.726645 Name : Age , dtype : float64","title":"10 - Introduzione a Pandas"},{"location":"material/02_libs/10_pandas/lecture/#introduzione-a-pandas","text":"Pandas \u00e8 l'ultima delle librerie dell'ecosistema SciPy che tratteremo, ma ci\u00f2 non toglie che \u00e8 un pezzo fondamentale dell'intero framework, in quanto viene usata per la lettura ed elaborazione dei dati provenienti da sorgenti di vario tipo.","title":"Introduzione a Pandas"},{"location":"material/02_libs/10_pandas/lecture/#installazione-e-configurazione-di-pandas","text":"Al solito, provvediamo per prima cosa ad installare Pandas nel nostro ambiente di lavoro. ===\"Pip\" pip install pandas ===\"Pipenv\" pipenv install pandas Cos\u00ec come per le altre librerie (eccetto Jupyter), nel prosieguo presupporemo che Pandas sia importato nel nostro script (o, ancora meglio, nel nostro notebook): import pandas as pd","title":"Installazione e configurazione di Pandas"},{"location":"material/02_libs/10_pandas/lecture/#i-dati-gestiti-da-pandas","text":"Pandas gestisce dati tabulari , ossia dello stesso tipo di quelli comunemente contenuti nei fogli di calcolo o nei database. Questi dati sono sicuramente tra i pi\u00f9 diffusi ed utilizzati nell'ambito dell'analisi dati, se si escludono le immagini; per modellarli, Pandas ci mette a disposizione un'apposita struttura denominata DataFrame . Un DataFrame altro non \u00e8 se non una struttura dati di tipo bidimensionale, adatta a memorizzare dati di ogni tipo, inclusi stringhe, interi, float, ed altro. I dati sono organizzati in righe ( rows ) e colonne ( columns ), in maniera concettualmente analoga ad un foglio di calcolo o database; tuttavia, \u00e8 importante sottolinare come, per convenzione, le singole righe rappresentino i campioni del dataset, mentre le singole colonne siano associate ai valori assunti dalle feature per ciascun campione.","title":"I dati gestiti da Pandas"},{"location":"material/02_libs/10_pandas/lecture/#il-primo-dataframe","text":"Facciamo un esempio. Scarichiamo il Titanic Dataset , e scompattiamo l'archivio. Al suo interno, troveremo tre file, ovvero gender_submission.csv , test.csv e train.csv . Per gli scopi di questa lezione, ci concentreremo soltanto sull'ultimo. Spostiamolo per prima cosa all'interno della nostra cartella di lavoro. A quel punto, usiamo questo codice per caricarlo all'interno di un DataFrame : df = pd . read_csv ( 'train.csv' ) Usiamo il metodo head() per mostrare a schermo le prime cinque righe del DataFrame. >>> df . head () PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund , Mr . Owen Harris male 22.0 1 0 A / 5 21171 7.2500 NaN S 1 2 1 1 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen , Miss . Laina female 26.0 0 0 STON / O2 . 3101282 7.9250 NaN S 3 4 1 1 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen , Mr . William Henry male 35.0 0 0 373450 8.0500 NaN S Vediamo poi i tipi di ciascuna delle colonne. >>> df . dtypes PassengerId int64 Survived int64 Pclass int64 Name object Sex object Age float64 SibSp int64 Parch int64 Ticket object Fare float64 Cabin object Embarked object dtype : object Notiamo subito la presenza di tre tipi di colonna, ovvero int64 , float64 ed object . Laddove i primi due sono autoesplicativi, merita una particolare menzione il tipo object , che viene associato automaticamente a tutte le stringhe. Suggerimento Normalmente, usare il tipo object comporta diversi problemi nella successiva fase di analisi dei dati. Potrebbe quindi essere una buona idea parametrizzare la funzione read_csv mediante il parametro dtype , che accetta un dizionario che specifica il tipo di una o pi\u00f9 colonne. Ad esempio, se volessimo specificare che i nomi sono delle stringhe, potremmo usare il tipo string : >>> types = { 'Name' : 'string' } >>> df = pd . read_csv ( 'train.csv' , dtype = types ) >>> df . dtypes # ... Name string # ...","title":"Il primo DataFrame"},{"location":"material/02_libs/10_pandas/lecture/#le-series","text":"Abbiamo visto come ogni DataFrame sia composto da un insieme di colonne, ciascuna rappresentativa di una feature specifica. In realt\u00e0, Pandas offre una rappresentazione apposita per ciascuna di queste colonne, chiamata Series . Ad esempio, se volessimo isolare la colonna relativa agli identificativi numerici dei passeggeri, potremmo usare le seguenti istruzioni: >>> df [ 'PassengerId' ] . head () 0 1 1 2 2 3 3 4 4 5 Name : PassengerId , dtype : int64 >>> type ( df [ 'PassengerId' ]) < class ' pandas . core . series . Series '> Nota Possiamo creare sia una Series sia un DataFrame da zero usando gli appositi costruttori. Tuttavia, nella maggior parte dei casi, ci limiteremo a manipolare dati gi\u00e0 esistenti.","title":"Le Series"},{"location":"material/02_libs/10_pandas/lecture/#lindice-del-dataframe","text":"Molto importante \u00e8 l' indice associato al DataFrame od alla Series . Notiamo infatti che, in entrambi i casi precedenti, \u00e8 stato associato ad ogni riga un indice numerico crescente, che possiamo utilizzare per recuperare uno specifico campione. Potremmo per\u00f2 decidere di usare una colonna del DataFrame come indice (nel nostro caso, ad esempio, PassengerId ); per farlo, possiamo passare l'apposito parametro index_col all'interno del metodo read_csv : df = pd . read_csv ( 'train.csv' , index_col = 'PassengerId' ) Verifichiamo che il nuovo DataFrame abbia come indice la colonna PassengerId : >>> df . head () Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund , Mr . Owen Harris male 22.0 1 0 A / 5 21171 7.2500 NaN S 2 1 1 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen , Miss . Laina female 26.0 0 0 STON / O2 . 3101282 7.9250 NaN S 4 1 1 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen , Mr . William Henry male 35.0 0 0 373450 8.0500 NaN S >>> df . index Int64Index ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , ... 882 , 883 , 884 , 885 , 886 , 887 , 888 , 889 , 890 , 891 ], dtype = 'int64' , name = 'PassengerId' , length = 891 )","title":"L'indice del DataFrame"},{"location":"material/02_libs/10_pandas/lecture/#formati-di-dato-in-ingresso-ed-in-uscita","text":"Finora abbiamo usato la funzione read_csv per creare un DataFrame a partire dai dati memorizzati in un file in formato CSV. Tuttavia, Pandas, supporta molti altri formati: ad esempio, potremmo leggere un file XLSX (Excel): df = pd . read_excel ( 'dati.xlsx' ) Attenzione Per leggere (e scrivere) da (su) Excel \u00e8 necessario installare la libreria openpyxl ( pip install openpyxl ). oppure un file in formato JSON: df = pd . read_json ( 'dati.json' ) o ancora direttamente da un database: df = pd . read_sql ( SQL_QUERY ) Per un elenco completo delle funzioni disponibili, il rimando \u00e8 alla reference ; la sintassi \u00e8 comunque quasi sempre read_*(data_source) , con * da sostituire con il tipo di sorgente dati ( csv , excel , etc.). Esiste anche la funzione duale, che usa il suffisso to_ al posto di read_ , e permette di scrivere un DataFrame su file. Ad esempio, se volessimo scrivere su un file XLSX: df . to_excel ( 'train.xlsx' )","title":"Formati di dato (in ingresso ed in uscita)"},{"location":"material/02_libs/10_pandas/lecture/#aggiungere-feature-e-dati","text":"","title":"Aggiungere feature e dati"},{"location":"material/02_libs/10_pandas/lecture/#aggiunta-di-una-nuova-feature","text":"Immaginiamo di voler aggiungere una nuova feature ad un DataFrame esistente. Per farlo, iniziamo creando un DataFrame di esempio: >>> df = pd . DataFrame ([ 1 , 2 , 3 , 4 , 5 ], columns = [ 'one' ]) >>> df one 0 1 1 2 2 3 3 4 4 5 Possiamo aggiungere una nuova colonna semplicemente usando l'operatore di assegnazione e specificandone il nome: >>> df [ 'two' ] = df [ 'one' ] * 2 >>> df one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10","title":"Aggiunta di una nuova feature"},{"location":"material/02_libs/10_pandas/lecture/#aggiunta-di-nuovi-campioni","text":"Possiamo poi aggiungere nuovi campioni in coda al DataFrame . Per farlo, possiamo creare un nuovo DataFrame , le cui colonne devono essere coerenti con quello gi\u00e0 esistente, e poi usare la funzione insert : >>> df_add = pd . DataFrame ([[ 6 , 7 ]], columns = [ 'one' , 'two' ]) >>> df . append ( df_add ) one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10 0 6 7","title":"Aggiunta di nuovi campioni"},{"location":"material/02_libs/10_pandas/lecture/#concatenazione-di-dataframe","text":"Possiamo usare la funzione concat per concatenare due (o pi\u00f9) DataFrame . Ad esempio, possiamo concatenare due DataFrame per colonne usando il parametro axis=1 : >>> df_con_col = pd . DataFrame ([ 3 , 6 , 9 , 12 , 15 ], columns = [ 'three' ]) >>> pd . concat ([ df , df_con_col ], axis = 1 ) one two three 0 1 2 3 1 2 4 6 2 3 6 9 3 4 8 12 4 5 10 15 Usando il parametro axis=0 , si effettua una concatenazione per righe (campioni): >>> df_con_row = pd . DataFrame ([[ 6 , 7 ]], columns = [ 'one' , 'two' ]) >>> pd . concat ([ df , df_con_row ]) one two 0 1 2 1 2 4 2 3 6 3 4 8 4 5 10 0 6 7 Nota Notiamo che concat accetta una lista di DataFrame .","title":"Concatenazione di DataFrame"},{"location":"material/02_libs/10_pandas/lecture/#scegliere-i-dati","text":"","title":"Scegliere i dati"},{"location":"material/02_libs/10_pandas/lecture/#dimensioni-del-dataframe","text":"Per conoscere le dimensioni del DataFrame sotto analisi, possiamo usare l'attributo shape . Ovviamente, l'attributo \u00e8 analogo a quello usato in NumPy, e restituisce il numero di campioni e feature contenuti nel DataFrame . Ad esempio: >>> df . shape ( 891 , 11 )","title":"Dimensioni del DataFrame"},{"location":"material/02_libs/10_pandas/lecture/#selezionare-un-insieme-di-colonne","text":"Immaginiamo di voler selezionare soltanto le colonne relative alle caratteristiche anagrafiche dei passeggeri, ad esempio nome, genere ed et\u00e0. In modo simile a come si opera su un array NumPy, possiamo usare la seguente notazione: >>> passengers_anagraphical = df [[ 'Name' , 'Sex' , 'Age' ]] >>> passengers_anagraphical . head () Name Sex Age PassengerId 1 Braund , Mr . Owen Harris male 22.0 2 Cumings , Mrs . John Bradley ( Florence Briggs Th ... female 38.0 3 Heikkinen , Miss . Laina female 26.0 4 Futrelle , Mrs . Jacques Heath ( Lily May Peel ) female 35.0 5 Allen , Mr . William Henry male 35.0 In pratica, stiamo semplicemente selezionando alcune colonne del DataFrame . Attenzione I nomi delle colonne devono essere validi e presenti nel DataFrame .","title":"Selezionare un insieme di colonne"},{"location":"material/02_libs/10_pandas/lecture/#selezionare-un-insieme-di-campioni-in-base-ad-una-o-piu-condizioni","text":"Supponiamo di voler selezionare soltanto gli uomini maggiorenni presenti nel DataFrame . Per farlo, usiamo la seguente istruzione: >>> men = df [( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' )] >>> men . head () Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.2500 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.0500 NaN S 7 0 1 McCarthy , Mr . Timothy J male ... 17463 51.8625 E46 S 13 0 3 Saundercock , Mr . William Henry male ... A / 5. 2151 8.0500 NaN S 14 0 3 Andersson , Mr . Anders Johan male ... 347082 31.2750 NaN S In pratica, stiamo filtrando il DataFrame in base a due condizioni: df['Age'] > 18 : questa condizione genera una maschera booleana che \u00e8 True soltanto se l'et\u00e0 per quel passeggero \u00e8 maggiore di 18 anni; df['Sex'] == 'male' : questa condizione genera una maschera booleana che \u00e8 vera soltanto se il genere del passeggero \u00e8 maschile. Possiamo combinare le due condizioni mediante un and logico per ottenere la maschera complessiva: ( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' ) A quel punto, estraiamo i campioni in cui la maschera \u00e8 vera: df [( df [ 'Age' ] > 18 ) & ( df [ 'Sex' ] == 'male' )]","title":"Selezionare un insieme di campioni in base ad una o pi\u00f9 condizioni"},{"location":"material/02_libs/10_pandas/lecture/#le-funzioni-loc-ed-iloc","text":"Possiamo anche selezionare dei sottoinsiemi di dati in maniera non dissimile da come faremmo con gli array NumPy. Per farlo, abbiamo a disposizione due funzioni, ovvero loc ed iloc . Entrambe permettono di selezionare un sottoinsieme di campioni mediante slicing. Ad esempio: >>> df . loc [: 5 : 2 ] Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.250 NaN S 3 1 3 Heikkinen , Miss . Laina female ... STON / O2 . 3101282 7.925 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.050 NaN S >>> df . iloc [: 5 : 2 ] Survived Pclass Name Sex ... Ticket Fare Cabin Embarked PassengerId ... 1 0 3 Braund , Mr . Owen Harris male ... A / 5 21171 7.250 NaN S 3 1 3 Heikkinen , Miss . Laina female ... STON / O2 . 3101282 7.925 NaN S 5 0 3 Allen , Mr . William Henry male ... 373450 8.050 NaN S La differenza tra le due funzioni sta principalmente nell'indicizzazione delle colonne. Infatti, la funzione loc si attende il nome della colonna: >>> df . loc [: 5 , 'Survived' ] PassengerId 1 0 2 1 3 1 4 1 5 0 D'altro canto, iloc (composizione di integer location ) si attende l'indice numerico, su cui si pu\u00f2 ovviamente anche applicare lo slicing: >>> df . iloc [: 5 , 0 ] PassengerId 1 0 2 1 3 1 4 1 5 0","title":"Le funzioni loc ed iloc"},{"location":"material/02_libs/10_pandas/lecture/#visualizzazione-dei-dati-in-pandas","text":"Pandas offre un supporto nativo ad un backend Matplotlib per la visualizzazione dei dati; per farlo, basta usare la funzione plot() su una Series o su un intero DataFrame . Ad esempio, se volessimo plottare le et\u00e0 dei passeggeri: >>> df [ 'Age' ] . plot () >>> plt . show () Il risultato sar\u00e0 mostrato in figura. Possiamo anche fare il plot dell'intero DataFrame : >>> df . plot () >>> plt . show () Il risultato \u00e8 mostrato in figura.","title":"Visualizzazione dei dati in Pandas"},{"location":"material/02_libs/10_pandas/lecture/#istogrammi-ed-altro","text":"Ovviamente, \u00e8 possibile usare Pandas anche per fare il plot di altri tipi di grafico, come ad esempio gli istogrammi. Per farlo, si usano le apposite sotto-funzioni di plot : >>> df [ 'Age' ] . plot . hist () >>> plt . show () Il risultato \u00e8 mostrato in figura.","title":"Istogrammi ed altro"},{"location":"material/02_libs/10_pandas/lecture/#statistiche-su-un-dataframe","text":"Pandas ci mette a disposizione delle funzioni, simili a quelle offerte da NumPy, per calcolare delle statistiche per ciascuna delle colonne presenti in un DataFrame. Ad esempio: >>> df . mean () PassengerId 446.000000 Survived 0.383838 Pclass 2.308642 Age 29.699118 SibSp 0.523008 Parch 0.381594 Fare 32.204208 dtype : float64 Ovviamente, esistono funzioni anche per calcolare varianza ( df.var() ), mediana ( df.median() ), deviazione standard ( df.std() ), e via discorrendo. Particolarmente interessante \u00e8 la funzione describe() , che ci mosta tutte le statistiche pi\u00f9 significative per ognuna delle feature considerate. >>> df . describe () PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 714.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 29.699118 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 14.526497 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25 % 223.500000 0.000000 2.000000 20.125000 0.000000 0.000000 7.910400 50 % 446.000000 0.000000 3.000000 28.000000 0.000000 0.000000 14.454200 75 % 668.500000 1.000000 3.000000 38.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200","title":"Statistiche su un DataFrame"},{"location":"material/02_libs/10_pandas/lecture/#la-funzione-groupby","text":"Possiamo sfruttare la funzione groupby per raggruppare insiemi di dati (normalmente pertinenti a categorie ). Ad esempio, potremmo raggruppare i passeggeri per genere: >>> df . groupby ([ 'Sex' ]) Possiamo ovviamente estrarre delle statistiche a partire da questi raggruppamenti. Vediamo, ad esempio, l'et\u00e0 media dei passeggeri di sesso femminile e maschile: >>> df . groupby ([ 'Sex' ])[ 'Age' ] . mean () Sex female 27.915709 male 30.726645 Name : Age , dtype : float64","title":"La funzione groupby"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/","text":"17 - Concetti introduttivi al machine learning \u00b6 17.1 - Il dataset \u00b6 Un dataset, in senso lato, serve a modellare un dato fenomeno sotto osservazione; nel caso del dataset Titanic , infatti, stiamo modellando, o per meglio dire caratterizzando , i passeggeri presenti sul Titanic durante l'unico, sfortunato, viaggio della nave. Sui dataset Al giorno d'oggi, esistono dataset su praticamente ogni cosa, dalle saldature, alla videosorveglianza, passando per la qualit\u00e0 dell'aria, e chi pi\u00f9 ne ha, pi\u00f9 ne metta. TODO: inserire link a repository online Un dataset \u00e8 concettualmente assimilabile ad una tabella, nella quale le righe sono i campioni , mentre le colonne sono le feature . Vediamo nel dettaglio di cosa si tratta. 17.1.1 - I campioni \u00b6 I campioni sono le singole osservazioni del fenomeno sotto esame. Ad esempio, tornando al solito dataset Titanic, ogni campione \u00e8 associato ad un passeggero; in analoga maniera, il singolo campione pu\u00f2 essere associato ad un frame acquisito dalle videocamere di sorveglianza, o alla lettura di un dato da un sensore. Ovviamente, \u00e8 anche possibile che, a valle di un qualche errore hardware o software, ci siano dati ripetuti; in questo caso, \u00e8 bene effettuare un preprocessing del dataset, andando ad isolare ed eliminare eventuali ridondanze. 17.1.1.1 - Sbilanciamento del dataset \u00b6 Esistono delle particolari situazioni nelle quali vi \u00e8 una \"abbondanza\" di dati di un certo tipo, contrapposta alla \"scarsit\u00e0\" di dati di un altro tipo. Ad esempio, in un dataset per la videosorveglianza, potrebbero essere stati ripresi molti pi\u00f9 uomini che donne, oppure ancora in un dataset simile a quello del Titanic potrebbero esserci molti pi\u00f9 bambini che adulti. In questi casi non \u00e8 detto che il nostro algoritmo di machine learning si comporti sempre in maniera ottimale: infatti, se gli uomini fossero prevalenti rispetto alle donne, l'algoritmo potrebbe iniziare a riconoscere soltanto i primi, proprio perch\u00e9 non conosce a sufficienza le seconde; si parla quindi di sbilanciamento del dataset . Nota Per fortuna, esistono degli approcci volti a ridurre l'impatto negativo di un possibile sbilanciamento, \"ribilanciando\" i dati. Ne parleremo in una delle sezioni successive. 17.1.2 - Le feature \u00b6 Per quello che riguarda le feature, queste sono le caratteristiche che definiscono ciascun campione del nostro dataset. Nel caso dei passeggeri del Titanic, avremo, tra gli altri, il loro nome, la cabina in cui allogiavano, la modalit\u00e0 d'imbarco, l'et\u00e0 ed il sesso, mentre nel caso di un dataset relativo a dati acquisiti da sensori per il controllo della qualit\u00e0 dell'aria potremmo avere le letture di temperatura ed umidit\u00e0 per ogni campione temporale. Nota In caso di dati non strutturati , ovvero che non possono essere caratterizzati direttamente con una tabella, come ad esempio le immagini, le feature devono essere di solito estratte mediante opportuni algoritmi. Ad esempio, nel caso delle immagini, potremmo utilizzare feature estratte a partire dal colore o dalle forme presenti nelle stesse, mentre per un file audio potrebbe essere necessario utilizzare trasformate nel dominio frequenziale o caratterizzazioni pi\u00f9 a basso livello come gli MFCC . 17.1.2.1 - Feature selection \u00b6 Cos\u00ec come per i campioni, \u00e8 possibile che esistano delle feature ridondanti. In questo caso, tuttavia, la ridondanza va valutata tenendo conto dell'intero insieme di valori assunto dalle feature sotto esame. Facciamo un breve esempio. Supponiamo innanzitutto di avere un sistema che legga temperatura ed umidit\u00e0 dell'ambiente in cui viene collocato. Nel sistema ci sono tre sensori: uno di umidit\u00e0, uno di misurazione di temperatura in gradi centigradi, ed uno di misurazione di temperatura in gradi Kelvin. Supponiamo inoltre che, per un qualche errore di calibrazione, la lettura di umidit\u00e0 del sensore riporti sempre un valore pari al \\(50\\%\\) . Allora: potremo scartare in toto la lettura di umidit\u00e0, in quanto non ci permetter\u00e0 in alcun modo di discriminare tra letture differenti; dato che le letture dei due sensori di temperatura sono linearmente dipendenti (ovvero, la lettura del sensore che misura in gradi centigradi \u00e8 pari a quella del sensore che misura in Kelvin a meno di un offset di 273 gradi), potremo tranquillamente considerarle ridondanti, e scartarne una. Con questi accorgimenti, abbiamo effettuato una (rudimentale, ma efficace) procedura di feature selection . Sulle feature a bassa varianza Non vi \u00e8 una relazione tra la rottura di un sensore ed una lettura a bassa varianza; quest'ultima, infatti, potrebbe essere meramente determinata dal fenomeno fisico sotto osservazione. Di conseguenza, \u00e8 sempre necessario osservare e valutare i numeri . 17.1.2.1.1 - La curse of dimensionality \u00b6 L'importanza della feature selection \u00e8 particolarmente rilevante nella mitigazione della curse of dimensionality , ovvero quel fenomeno che insorge quando il numero di feature \u00e8 paragonabile a quello dei campioni. Dobbiamo ricordare che gli algoritmi di machine learning non fanno altro che provare ad \"estrarre\" una relazione tra i campioni e le feature che li rappresentano: in altre parole, gli algoritmi tentano di capire se, ad esempio, esiste una correlazione tra tutti i passeggeri maschi di et\u00e0 inferiore ai 18 anni, oppure se le donne con et\u00e0 superiore ai 60 anni hanno aderito ad un certo piano tariffario, e via dicendo. Per far questo, \u00e8 necessario che ci siano abbastanza campioni per descrivere ogni possibile comportamento del fenomeno sotto osservazione: ad esempio, se vi \u00e8 soltanto una donna che ha pagato il biglietto pi\u00f9 di 10 dollari, \u00e8 plausibile che questa informazione sia inutile , ancorch\u00e9 fuorviante , mentre se un gran numero di ragazzi \u00e8 stipato nelle cabine del secondo piano, allora, l'informazione avr\u00e0 un valore del tutto differente. La conseguenza immediata di ci\u00f2, e che \u00e8 alla base della curse of dimensionality, risiede quindi nel fatto che quando il numero di feature \u00e8 circa uguale a quello dei campioni \u00e8 molto probabile che l'algoritmo non sar\u00e0 in grado di caratterizzare in maniera adeguata il fenomeno sottostante. Le soluzioni a quel punto saranno due: da un lato, potremo provare ad aumentare il numero dei campioni, mentre dall'altro potremo provare a rimuovere le feature poco significative, o anche quelle tra loro correlate, aiutando a mitigare la curse of dimensionality. 17.2 - Tipi di problema \u00b6 Un altro aspetto fondamentale nell'analisi dei dati \u00e8 la valutazione del tipo di problema cui siamo di fronte, il che determina, di conseguenza, la scelta dell'algoritmo da utilizzare. In tal senso, esistono due tipi di problema: da un lato, ci sono quelli che riguardano i dati indipendenti ed identicamente distribuiti ( IID ), mentre dall'alto vi sono le serie temporali . 17.2.1 - Problemi con dati IID \u00b6 I problemi con dati IID prevedono l'analisi di dati che, come suggerisce il nome stesso, sono indipendenti l'uno dall'altro. In altre parole, il meccanismo di generazione dei dati fa in modo che ogni istanza del processo non sia generata a partire da un'altra, ma soltanto secondo le regole del meccanismo stesso. Per chiarire l'esempio, immaginiamo di avere un dataset che raccolga tutti gli studenti all'interno di un corso di laurea. In tal senso, le caratteristiche di ogni studente saranno indipendenti da quelle degli altri, in quanto non determinate a partire da questi ultimi. Per capirci, l'et\u00e0 e la media voto dello studente A non dipender\u00e0 dall'et\u00e0 o dalla media voto dello studente B, cos\u00ec come i nomi e cognomi dei due, l'andamento dei loro esami, e cos\u00ec via. Gli studenti sono veramente indipendenti tra loro? I pi\u00f9 attenti tra i lettori noteranno come nel caso degli studenti siano state fatte delle ipotesi semplificative . Infatti, l'et\u00e0, il nome ed il cognome degli studenti potrebbero influenzarsi in caso di familiari, mentre la media voto potrebbe essere simile per studenti abituati a studiare in gruppo. Tuttavia, molto spesso dovremo effettuare ipotesi di questo tipo, supponendo trascurabili situazioni nei fatti marginali come quelle descritte in precedenza. Definizione sintetica di IID Diamo una definizione sintetica di dati IID: i dati IID sottendono alla stessa distribuzione , ed il valore di un campione dipende solo da quest'ultima. Tipicamente, esistono tre tipi di problemi che possono essere utilizzati per caratterizzare dati IID, ovvero classificazione , regressione e clustering . La classificazione di dati IID prevede che ad ogni dato sia assegnata una determinata classe , intesa come \"raggruppamento\" di cui il singolo campione fa parte. Ad esempio, nel caso degli studenti, potremmo utilizzare le classi \"Matricola\", \"In corso\" e \"Fuori corso\" per determinare la possibilit\u00e0 di uno studente di accedere ad uno specifico appello, mentre nel caso dei passeggeri del Titanic potremmo classificare tra \"Sopravvissuti\" e \"Non sopravvissuti\". La regressione di dati IID cerca invece una relazione tra le feature di ciascun campione ed un dato valore numerico (continuo). Rimanendo ai passeggeri del Titanic, potremmo voler valutare il rapporto esistente tra l'et\u00e0 del passeggero ed il prezzo che questi ha pagato per il biglietto. In ultimo, il clustering prova ad inferire dei \"raggruppamenti\", chiamati appunto cluster , di dati omogenei, separando contestualmente dati eterogenei. Tecniche supervisionate e non supervisionate Di solito, le tecniche di classificazione sono spesso supervisionate , ovvero prevedono la presenza di un insieme di dati precedente etichettato da un esperto di dominio mediante una procedura di labeling . Di contro, le tecniche di clustering sono non superivisionate , ed inferiscono eventuali omogeneit\u00e0 a partire dai dati stessi. 17.2.2 - Problemi con serie temporali \u00b6 A differenza dei dati IID, le serie temporali sono composte da dati tra loro interdipendenti, e \"correlati\" da appositi vincoli temporali. Facciamo un paio di esempi di dati di questo tipo. Il primo esempio \u00e8 quello di un video , il quale \u00e8 composto da una sequenza , o serie , di immagini disposte in un ben preciso ordine temporale. Ad esempio, osserviamo i frame riportati nelle figure 1 e 2: \u00e8 facile ntoare come il secondo, successivo al primo, comporti dei movimenti del calciatore con la palla causati dalle azioni che questi ha compiuto nel frame precedente. In tal senso, le informazioni contenute nel secondo frame sono quindi legate a quelle contenute nel primo da un rapporto di causalit\u00e0 , per cui si parla di serie temporale. Figura 1: frame 1 Figura 2: frame 2 Il secondo esempio \u00e8 quello di una serie di letture di un sensore di temperatura, prese ad una frequenza di un minuto, come mostrato nella figura successiva. In questo caso, \u00e8 facile evidenziare come la lettura al tempo \\(t\\) sia influenzata (almeno) dalla lettura al tempo \\(t-1\\) . Figura 3: serie temporale Sulle influenze di una serie temporale Si noti come abbiamo usato la parola almeno in merito alle influenze temporali. Questo \u00e8 legato al fatto che, per semplicit\u00e0, abbiamo rappresentato la serie temporale delle letture di temperatura come un fenomeno univariato , ossia dipendente soltanto dal valore dello stesso in istanti precedenti. Nella realt\u00e0, invece, molto spesso i fenomeni osservati sono multivariati , e dipendono da un numero pi\u00f9 o meno alto di variabili in gioco.","title":"11.1 - Introduzione al Machine Learning"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#17-concetti-introduttivi-al-machine-learning","text":"","title":"17 - Concetti introduttivi al machine learning"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#171-il-dataset","text":"Un dataset, in senso lato, serve a modellare un dato fenomeno sotto osservazione; nel caso del dataset Titanic , infatti, stiamo modellando, o per meglio dire caratterizzando , i passeggeri presenti sul Titanic durante l'unico, sfortunato, viaggio della nave. Sui dataset Al giorno d'oggi, esistono dataset su praticamente ogni cosa, dalle saldature, alla videosorveglianza, passando per la qualit\u00e0 dell'aria, e chi pi\u00f9 ne ha, pi\u00f9 ne metta. TODO: inserire link a repository online Un dataset \u00e8 concettualmente assimilabile ad una tabella, nella quale le righe sono i campioni , mentre le colonne sono le feature . Vediamo nel dettaglio di cosa si tratta.","title":"17.1 - Il dataset"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#1711-i-campioni","text":"I campioni sono le singole osservazioni del fenomeno sotto esame. Ad esempio, tornando al solito dataset Titanic, ogni campione \u00e8 associato ad un passeggero; in analoga maniera, il singolo campione pu\u00f2 essere associato ad un frame acquisito dalle videocamere di sorveglianza, o alla lettura di un dato da un sensore. Ovviamente, \u00e8 anche possibile che, a valle di un qualche errore hardware o software, ci siano dati ripetuti; in questo caso, \u00e8 bene effettuare un preprocessing del dataset, andando ad isolare ed eliminare eventuali ridondanze.","title":"17.1.1 - I campioni"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#17111-sbilanciamento-del-dataset","text":"Esistono delle particolari situazioni nelle quali vi \u00e8 una \"abbondanza\" di dati di un certo tipo, contrapposta alla \"scarsit\u00e0\" di dati di un altro tipo. Ad esempio, in un dataset per la videosorveglianza, potrebbero essere stati ripresi molti pi\u00f9 uomini che donne, oppure ancora in un dataset simile a quello del Titanic potrebbero esserci molti pi\u00f9 bambini che adulti. In questi casi non \u00e8 detto che il nostro algoritmo di machine learning si comporti sempre in maniera ottimale: infatti, se gli uomini fossero prevalenti rispetto alle donne, l'algoritmo potrebbe iniziare a riconoscere soltanto i primi, proprio perch\u00e9 non conosce a sufficienza le seconde; si parla quindi di sbilanciamento del dataset . Nota Per fortuna, esistono degli approcci volti a ridurre l'impatto negativo di un possibile sbilanciamento, \"ribilanciando\" i dati. Ne parleremo in una delle sezioni successive.","title":"17.1.1.1 - Sbilanciamento del dataset"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#1712-le-feature","text":"Per quello che riguarda le feature, queste sono le caratteristiche che definiscono ciascun campione del nostro dataset. Nel caso dei passeggeri del Titanic, avremo, tra gli altri, il loro nome, la cabina in cui allogiavano, la modalit\u00e0 d'imbarco, l'et\u00e0 ed il sesso, mentre nel caso di un dataset relativo a dati acquisiti da sensori per il controllo della qualit\u00e0 dell'aria potremmo avere le letture di temperatura ed umidit\u00e0 per ogni campione temporale. Nota In caso di dati non strutturati , ovvero che non possono essere caratterizzati direttamente con una tabella, come ad esempio le immagini, le feature devono essere di solito estratte mediante opportuni algoritmi. Ad esempio, nel caso delle immagini, potremmo utilizzare feature estratte a partire dal colore o dalle forme presenti nelle stesse, mentre per un file audio potrebbe essere necessario utilizzare trasformate nel dominio frequenziale o caratterizzazioni pi\u00f9 a basso livello come gli MFCC .","title":"17.1.2 - Le feature"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#17121-feature-selection","text":"Cos\u00ec come per i campioni, \u00e8 possibile che esistano delle feature ridondanti. In questo caso, tuttavia, la ridondanza va valutata tenendo conto dell'intero insieme di valori assunto dalle feature sotto esame. Facciamo un breve esempio. Supponiamo innanzitutto di avere un sistema che legga temperatura ed umidit\u00e0 dell'ambiente in cui viene collocato. Nel sistema ci sono tre sensori: uno di umidit\u00e0, uno di misurazione di temperatura in gradi centigradi, ed uno di misurazione di temperatura in gradi Kelvin. Supponiamo inoltre che, per un qualche errore di calibrazione, la lettura di umidit\u00e0 del sensore riporti sempre un valore pari al \\(50\\%\\) . Allora: potremo scartare in toto la lettura di umidit\u00e0, in quanto non ci permetter\u00e0 in alcun modo di discriminare tra letture differenti; dato che le letture dei due sensori di temperatura sono linearmente dipendenti (ovvero, la lettura del sensore che misura in gradi centigradi \u00e8 pari a quella del sensore che misura in Kelvin a meno di un offset di 273 gradi), potremo tranquillamente considerarle ridondanti, e scartarne una. Con questi accorgimenti, abbiamo effettuato una (rudimentale, ma efficace) procedura di feature selection . Sulle feature a bassa varianza Non vi \u00e8 una relazione tra la rottura di un sensore ed una lettura a bassa varianza; quest'ultima, infatti, potrebbe essere meramente determinata dal fenomeno fisico sotto osservazione. Di conseguenza, \u00e8 sempre necessario osservare e valutare i numeri .","title":"17.1.2.1 - Feature selection"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#171211-la-curse-of-dimensionality","text":"L'importanza della feature selection \u00e8 particolarmente rilevante nella mitigazione della curse of dimensionality , ovvero quel fenomeno che insorge quando il numero di feature \u00e8 paragonabile a quello dei campioni. Dobbiamo ricordare che gli algoritmi di machine learning non fanno altro che provare ad \"estrarre\" una relazione tra i campioni e le feature che li rappresentano: in altre parole, gli algoritmi tentano di capire se, ad esempio, esiste una correlazione tra tutti i passeggeri maschi di et\u00e0 inferiore ai 18 anni, oppure se le donne con et\u00e0 superiore ai 60 anni hanno aderito ad un certo piano tariffario, e via dicendo. Per far questo, \u00e8 necessario che ci siano abbastanza campioni per descrivere ogni possibile comportamento del fenomeno sotto osservazione: ad esempio, se vi \u00e8 soltanto una donna che ha pagato il biglietto pi\u00f9 di 10 dollari, \u00e8 plausibile che questa informazione sia inutile , ancorch\u00e9 fuorviante , mentre se un gran numero di ragazzi \u00e8 stipato nelle cabine del secondo piano, allora, l'informazione avr\u00e0 un valore del tutto differente. La conseguenza immediata di ci\u00f2, e che \u00e8 alla base della curse of dimensionality, risiede quindi nel fatto che quando il numero di feature \u00e8 circa uguale a quello dei campioni \u00e8 molto probabile che l'algoritmo non sar\u00e0 in grado di caratterizzare in maniera adeguata il fenomeno sottostante. Le soluzioni a quel punto saranno due: da un lato, potremo provare ad aumentare il numero dei campioni, mentre dall'altro potremo provare a rimuovere le feature poco significative, o anche quelle tra loro correlate, aiutando a mitigare la curse of dimensionality.","title":"17.1.2.1.1 - La curse of dimensionality"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#172-tipi-di-problema","text":"Un altro aspetto fondamentale nell'analisi dei dati \u00e8 la valutazione del tipo di problema cui siamo di fronte, il che determina, di conseguenza, la scelta dell'algoritmo da utilizzare. In tal senso, esistono due tipi di problema: da un lato, ci sono quelli che riguardano i dati indipendenti ed identicamente distribuiti ( IID ), mentre dall'alto vi sono le serie temporali .","title":"17.2 - Tipi di problema"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#1721-problemi-con-dati-iid","text":"I problemi con dati IID prevedono l'analisi di dati che, come suggerisce il nome stesso, sono indipendenti l'uno dall'altro. In altre parole, il meccanismo di generazione dei dati fa in modo che ogni istanza del processo non sia generata a partire da un'altra, ma soltanto secondo le regole del meccanismo stesso. Per chiarire l'esempio, immaginiamo di avere un dataset che raccolga tutti gli studenti all'interno di un corso di laurea. In tal senso, le caratteristiche di ogni studente saranno indipendenti da quelle degli altri, in quanto non determinate a partire da questi ultimi. Per capirci, l'et\u00e0 e la media voto dello studente A non dipender\u00e0 dall'et\u00e0 o dalla media voto dello studente B, cos\u00ec come i nomi e cognomi dei due, l'andamento dei loro esami, e cos\u00ec via. Gli studenti sono veramente indipendenti tra loro? I pi\u00f9 attenti tra i lettori noteranno come nel caso degli studenti siano state fatte delle ipotesi semplificative . Infatti, l'et\u00e0, il nome ed il cognome degli studenti potrebbero influenzarsi in caso di familiari, mentre la media voto potrebbe essere simile per studenti abituati a studiare in gruppo. Tuttavia, molto spesso dovremo effettuare ipotesi di questo tipo, supponendo trascurabili situazioni nei fatti marginali come quelle descritte in precedenza. Definizione sintetica di IID Diamo una definizione sintetica di dati IID: i dati IID sottendono alla stessa distribuzione , ed il valore di un campione dipende solo da quest'ultima. Tipicamente, esistono tre tipi di problemi che possono essere utilizzati per caratterizzare dati IID, ovvero classificazione , regressione e clustering . La classificazione di dati IID prevede che ad ogni dato sia assegnata una determinata classe , intesa come \"raggruppamento\" di cui il singolo campione fa parte. Ad esempio, nel caso degli studenti, potremmo utilizzare le classi \"Matricola\", \"In corso\" e \"Fuori corso\" per determinare la possibilit\u00e0 di uno studente di accedere ad uno specifico appello, mentre nel caso dei passeggeri del Titanic potremmo classificare tra \"Sopravvissuti\" e \"Non sopravvissuti\". La regressione di dati IID cerca invece una relazione tra le feature di ciascun campione ed un dato valore numerico (continuo). Rimanendo ai passeggeri del Titanic, potremmo voler valutare il rapporto esistente tra l'et\u00e0 del passeggero ed il prezzo che questi ha pagato per il biglietto. In ultimo, il clustering prova ad inferire dei \"raggruppamenti\", chiamati appunto cluster , di dati omogenei, separando contestualmente dati eterogenei. Tecniche supervisionate e non supervisionate Di solito, le tecniche di classificazione sono spesso supervisionate , ovvero prevedono la presenza di un insieme di dati precedente etichettato da un esperto di dominio mediante una procedura di labeling . Di contro, le tecniche di clustering sono non superivisionate , ed inferiscono eventuali omogeneit\u00e0 a partire dai dati stessi.","title":"17.2.1 - Problemi con dati IID"},{"location":"material/02_libs/11_sklearn/01_intro_ml/lecture/#1722-problemi-con-serie-temporali","text":"A differenza dei dati IID, le serie temporali sono composte da dati tra loro interdipendenti, e \"correlati\" da appositi vincoli temporali. Facciamo un paio di esempi di dati di questo tipo. Il primo esempio \u00e8 quello di un video , il quale \u00e8 composto da una sequenza , o serie , di immagini disposte in un ben preciso ordine temporale. Ad esempio, osserviamo i frame riportati nelle figure 1 e 2: \u00e8 facile ntoare come il secondo, successivo al primo, comporti dei movimenti del calciatore con la palla causati dalle azioni che questi ha compiuto nel frame precedente. In tal senso, le informazioni contenute nel secondo frame sono quindi legate a quelle contenute nel primo da un rapporto di causalit\u00e0 , per cui si parla di serie temporale. Figura 1: frame 1 Figura 2: frame 2 Il secondo esempio \u00e8 quello di una serie di letture di un sensore di temperatura, prese ad una frequenza di un minuto, come mostrato nella figura successiva. In questo caso, \u00e8 facile evidenziare come la lettura al tempo \\(t\\) sia influenzata (almeno) dalla lettura al tempo \\(t-1\\) . Figura 3: serie temporale Sulle influenze di una serie temporale Si noti come abbiamo usato la parola almeno in merito alle influenze temporali. Questo \u00e8 legato al fatto che, per semplicit\u00e0, abbiamo rappresentato la serie temporale delle letture di temperatura come un fenomeno univariato , ossia dipendente soltanto dal valore dello stesso in istanti precedenti. Nella realt\u00e0, invece, molto spesso i fenomeni osservati sono multivariati , e dipendono da un numero pi\u00f9 o meno alto di variabili in gioco.","title":"17.2.2 - Problemi con serie temporali"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/","text":"17 - Cosa \u00e8 Scikit-Learn? \u00b6 Scikit-Learn \u00e8 una delle principali librerie per il machine learning disponibili per Python. Il suo ampio utilizzo \u00e8 legato soprattutto a tre fattori: l'ampio supporto ad un gran numero di algoritmi; la facilit\u00e0 di utilizzo; la perfetta integrazione con NumPy e Pandas. Vediamo quindi una panoramica ad ampio spettro delle potenzialit\u00e0 di Scikit-Learn. 17.1 - Installazione di Scikit-Learn \u00b6 Come di consueto, la prima cosa da fare \u00e8 installare la libreria. Per farlo, spostiamoci (eventualmente) nell'ambiente virtuale usato per il corso, ed usiamo il seguente comando: pip install scikit-learn 17.2 - Un po' di terminologia \u00b6 Dati e feature \u00b6 Quando abbiamo parlato di Pandas, abbiamo visto che possiamo immaginare un dataset come una sorta di matrice , nella quale le righe sono chiamate campioni , mentre le colonne sono chiamate feature . Un dataset serve a modellare un fenomeno sotto osservazione. Nel caso che abbiamo affrontato in precedenza, il dataset Titanic modella il \"fenomeno\" relativo ai passeggeri della nave; altri dataset possono essere relativi a dati acquisiti da dei sensori, oppure ancora alle immagini in un impianto di videosorveglianza. I fenomeni sono quindi eterogenei , e dipendono ovviamente dallo scenario sotto analisi. Nota Normalmente, nella modellazione di un qualsiasi tipo di fenomeno, \u00e8 bene sfruttare la conoscenza di un esperto di dominio . Campioni e sbilanciamento del dataset \u00b6 I campioni sono le osservazioni del fenomeno: nel caso del dataset Titanic, ogni campione \u00e8 associato ad un passeggero, mentre per dati provenienti da immagini di videosorveglianza, il singolo campione \u00e8 associato ad ogni immagine acquisita dalle videocamere. Ovviamente, \u00e8 anche possibile che pi\u00f9 campioni provengano da meccanismi di generazione dei dati molto simili: ad esempio, potremmo avere due righe che descrivono lo stesso passeggero, o due immagini che riprendono la stessa persona dalla stessa angolazione: in questo caso, occorre valutare se vi \u00e8 della ridondanza tra i dati, ed eventualmente effettuarne un filtraggio. L'estremizzazione di questo principio porta alla problematica degli imbalanced data , ovvero dei dataset sbilanciati verso un'unica classe. Feature e feature selection \u00b6 D'altro canto, le colonne sono le feature del nostro dataset. Nel caso del dataset del Titanic, abbiamo a che fare con il nome del passeggero, la cabina, o ad esempio la modalit\u00e0 di imbarco; nel caso di un dataset relativo a dati acquisiti da sensori, potremmo avere le letture di temperatura e di umidit\u00e0, ad esempio. Per un dataset di immagini, invece, le feature sono, in senso lato, tutte le forme, a differenti livelli di astrazione, che possono essere individuate all'interno dell'immagine. Cos\u00ec come per i dati, anche le feature possono essere ridondanti . Se, ad esempio, notassimo che le letture derivanti dal sensore di ossigeno sono linearmente proporzionali rispetto a quelle derivanti dal sensore di temperatura, potremmo decidere di eliminare una delle due letture; lo stesso potremmo fare nel caso individuassimo delle feature a bassa varianza, e che quindi assumono lo stesso valore (o quasi) per tutti i dati. Questo processo di eliminazione, chiamato feature selection , \u00e8 estremamente importante, soprattutto perch\u00e9 avere troppe feature significa rischiare di incorrere nel fenomeno della curse of dimensionality . Curse of dimensionality \u00b6 Nell'ambito del machine learning, la curse of dimensionality indica quel fenomeno che insorge quando il numero di feature \u00e8 paragonabile a quello dei campioni. Dobbiamo ricordare che il machine learning non fa altro che provare ad \"estrarre\" una relazione tra i campioni e le feature che li rappresentano: in altre parole, gli algoritmi tentano di capire se, ad esempio, esiste una correlazione tra tutti i passeggeri maschi di et\u00e0 inferiore ai 18 anni, oppure se le donne con et\u00e0 superiore ai 60 anni hanno aderito ad un certo piano tariffario, e via dicendo. Per far questo, \u00e8 necessario che ci siano abbastanza campioni per descrivere ogni possibile comportamento del fenomeno sotto osservazione: ad esempio, se vi \u00e8 soltanto una donna che ha pagato il biglietto pi\u00f9 di 10 dollari, \u00e8 plausibile che questa informazione sia inutile , ancorch\u00e9 fuorviante , mentre se un gran numero di ragazzi \u00e8 stipato nelle cabine del secondo piano, allora, l'informazione avr\u00e0 un valore del tutto differente. La conseguenza immediata di ci\u00f2, e che \u00e8 alla base della curse of dimensionality, risiede quindi nel fatto che quando il numero di feature \u00e8 circa uguale a quello dei campioni \u00e8 molto probabile che l'algoritmo non sar\u00e0 in grado di caratterizzare in maniera adeguata il fenomeno sottostante. Le soluzioni a quel punto saranno due: da un lato, potremo provare ad aumentare il numero dei campioni, mentre dall'altro potremo provare a rimuovere le feature poco significative, o anche quelle tra loro correlate, aiutando a mitigare la curse of dimensionality. Tipi di dati \u00b6 Abbiamo finora parlato di campioni e feature. Tuttavia, non abbiamo ancora affrontato un aspetto fondamentale nell'analisi dei dati, ovvero la valutazione del tipo di dato , la quale determina, di conseguenza, la scelta dell'algoritmo da utilizzare. Sostanzialmente, esistono due tipi di dati, ovvero i dati indipendenti ed identicamente distribuiti ( IID ) e le serie temporali . Dati indipendenti ed identicamente distribuiti \u00b6 I dati IID sono, come dice il nome stesso, indipendenti l'uno dall'altro; inoltre, tutti i dati fanno parte dello stesso meccanismo di generazione dei dati, e quindi si suppone sottendano alla stessa distribuzione . In altri termini, ci\u00f2 significa che il valore di un campione non dipende dal valore di un altro. Un esempio sono le immagini di diversi oggetti, che possono essere usate per creare un algoritmo di identificazione degli oggetti, oppure gli stessi passeggeri del Titanic. Tipicamente, su questo tipo di dati sono usate tre tipi di algoritmi, ovvero regressione , classificazione e clustering . Classificazione \u00b6 Le tecniche di classificazione prevedono che ad ogni dato sia assegnata una classe , comportando di conseguenza un \"raggruppamento\" degli stessi in base alle indicazioni sulle classi. Un esempio sono le classificazioni delle immagini rispetto al tipo di oggetto raffigurato: le immagini relative ad un'auto apparterranno alla classe omonima, mentre le immagini di un cane apparteranno ad un'altra classe, e via dicendo. Altro esempio sono \u00e8 una possibile classificazione dei passeggeri del Titanic sulla base del fatto che siano sopravvissuti o meno. Regressione \u00b6 Le tecniche di regressione cercano invece di trovare una relazione tra le feature di ciascun dato ed un valore numerico (TODO: verificare se continuo o discreto). Rimanendo ai passeggeri del Titanic, potremmo voler valutare il rapporto esistente tra l'et\u00e0 del passeggero ed il prezzo che questi ha pagato per il biglietto. Clustering \u00b6 In ultimo, le tecniche di clustering provano ad inferire dei \"raggruppamenti\", chiamati formalmente cluster , di dati. Ovviamente, i dati appartenenti ad un cluster sono da considerarsi affini , mentre i dati appartenenti a cluster differenti sono da considerarsi differenti . Il clustering non prevede la presenza di alcuna classe. Di conseguenza, queste tecniche di apprendimento sono dette non supervisionate , in quanto non \u00e8 necessario l'intervento di un esperto di dominio per definire le classi cui appartengono i dati su cui viene addestrato l'algoritmo. Serie temporali \u00b6 A d\u00ecfferenza dei dati IID, le serie temporali sono composte da dati tra loro interdipendenti, e \"correlati\" da vincoli temporali. Esempi di questo tipo di dati sono i video, composti da sequenze di immagini disposte in un ben preciso ordine temporale, oppure ancora le acquisizioni derivate da un sensore. Nota Parleremo pi\u00f9 estensivamente delle serie temporali nella lezione su StatsModels. Concetti base di Scikit-Learn \u00b6 Stimatori \u00b6 Scikit-Learn definisce gli algoritmi di machine learning come stimatori : in tal senso, sia gli algoritmi di clustering, sia quelli di regressione, sia quelli di classificazione sono trattati, per l'appunto, come stimatori. Nota Come vedremo, questa caratterizzazione permette a Scikit-Learn di offrire un'interfaccia comune per la maggior parte degli algoritmi. Parametri dello stimatore \u00b6 Molto importanti sono i parametri con cui regolare il funzionamento dello stimatore. Ad esempio, per l'algoritmo KMeans , un possibile parametro \u00e8 il numero di cluster in cui i dati sono suddivisi. Vedremo come modificare questi parametri pu\u00f2 cambiare enormemente le performance di un algoritmo. Performance che, ovviamente, sono valutate secondo apposite metriche . Metriche \u00b6 Ogni algoritmo viene valutato secondo una metrica, che di solito permette di definire, in termini percentuali o assoluti, l'accuratezza dell'algoritmo. Preprocessing \u00b6 Molto spesso, \u00e8 necessario effettuare delle operazioni di preprocessing ( mai usare preprocessamento ) sui dati. Questo perch\u00e9 questi possono essere viziati dall'assenza di valori in determinati ambiti, oppure \u00e8 necessario scalarli. Scikit-Learn offre un intero package dedicato a questo. Le funzioni che utilizzeremo maggiormente saranno: train_test_split , per suddividere il dataset in un insieme di training ed uno di test; gli Imputer , per assegnare eventuali valori mancanti all'interno del dataset; i Transformer , che ci permettono di modificare il tipo dei dati. Pipeline \u00b6 Accenniamo in ultimo al fatto che, normalmente, \u00e8 necessario concatenare diversi stimatori. Per farlo, Scikit-Learn ci mette a disposizione un'apposita struttura chiamata Pipeline , che approfondiremo nelle prossime lezioni. Train, test e cross-validazione \u00b6 Apprendere i parametri di uno stimatore e testarlo sugli stessi dati \u00e8 un errore metodologico: un modello che infatti si limitasse a ripetere le label dei campioni che ha appena visto avrebbe un punteggio perfetto, ma non sarebbe in grado di predire qualcosa di utile su dati non ancora visti. Questa situazione \u00e8 comunemente chiamata overfitting . Per evitare l'overfitting, nei metodi supervisionati, si usa \"lasciar fuori\" parte dei dati disponibili e chiamarla set di test . La funzione principe per questo in scikit learn \u00e8 train test split. Tuttavia, pu\u00f2 essere anche possibile che si debbano valutare diversi iperparametri per un singolo stimatore. Il concetto di iperparametro \u00e8 analogo a quello di configurazione, e non sono chiamati parametri per evitare di generare confusione con i parametri che vengono configurati internamente da uno stimatore durante l'apprendimento. Quando valutiamo diverse combinazioni di iperparametri, \u00e8 possibile che vi sia un overfitting verso il test set, perch\u00e9 potremmo voler ritarare i parametri in modo da ottenere delle performance di validazione quanto migliori possibile. In questo modo, \u00e8 possibile che il meccanismo di generazione dei dati caratteristico del test set possa \"fuoriuscire\" all'interno del modello, causando conseguentemente un peggioramento delle capacit\u00e0 di generalizzazione. Per risolvere questo problema, ogni parte del dataset pu\u00f2 essere messa fuori in quello che viene chiamato set di validazione : il training avviene sul set di raining, la cui valutazione avviene sul set di valudazione,e quando l'esperimento sembra aver successo, la valutazione finale pu\u00f2 essere fatta sul set di test. Ad ogni modo, il partizionamento in questo modo riduce drasticametne il numero di campioni che pu\u00f2 essere usato per apprendere il modello, ed i risultati possono dipende da una scelta casuale dalla coppia degli insieme (train, validazione). Una soluzione di questo problema \u00e8 una procedura chiamato cross-validazione. Un set test deve essere sempre tenuto da parte per una valutazione finale, ma non \u00e8 necessario il test di validazione. In questo approccio base, chiamato k-fold CV, il set di training \u00e8 suddiviso in k set pi\u00f9 piccoli. La procedura \u00e8 la seguente: un modello viene addestrato usando \\(k - 1\\) dei fold come training data; il modello risultante \u00e8 validato sulla parte rimanente dei dati (ovvero \u00e8 usato come test set per calcolare una misura di performacnce come l'accuracy.) La misura di performance restituita dai k-fold \u00e8 quindi la media dei valori calcolati nel ciclo.","title":"11.2 - Introduzione a Scikit-Learn"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#17-cosa-e-scikit-learn","text":"Scikit-Learn \u00e8 una delle principali librerie per il machine learning disponibili per Python. Il suo ampio utilizzo \u00e8 legato soprattutto a tre fattori: l'ampio supporto ad un gran numero di algoritmi; la facilit\u00e0 di utilizzo; la perfetta integrazione con NumPy e Pandas. Vediamo quindi una panoramica ad ampio spettro delle potenzialit\u00e0 di Scikit-Learn.","title":"17 - Cosa \u00e8 Scikit-Learn?"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#171-installazione-di-scikit-learn","text":"Come di consueto, la prima cosa da fare \u00e8 installare la libreria. Per farlo, spostiamoci (eventualmente) nell'ambiente virtuale usato per il corso, ed usiamo il seguente comando: pip install scikit-learn","title":"17.1 - Installazione di Scikit-Learn"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#172-un-po-di-terminologia","text":"","title":"17.2 - Un po' di terminologia"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#dati-e-feature","text":"Quando abbiamo parlato di Pandas, abbiamo visto che possiamo immaginare un dataset come una sorta di matrice , nella quale le righe sono chiamate campioni , mentre le colonne sono chiamate feature . Un dataset serve a modellare un fenomeno sotto osservazione. Nel caso che abbiamo affrontato in precedenza, il dataset Titanic modella il \"fenomeno\" relativo ai passeggeri della nave; altri dataset possono essere relativi a dati acquisiti da dei sensori, oppure ancora alle immagini in un impianto di videosorveglianza. I fenomeni sono quindi eterogenei , e dipendono ovviamente dallo scenario sotto analisi. Nota Normalmente, nella modellazione di un qualsiasi tipo di fenomeno, \u00e8 bene sfruttare la conoscenza di un esperto di dominio .","title":"Dati e feature"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#campioni-e-sbilanciamento-del-dataset","text":"I campioni sono le osservazioni del fenomeno: nel caso del dataset Titanic, ogni campione \u00e8 associato ad un passeggero, mentre per dati provenienti da immagini di videosorveglianza, il singolo campione \u00e8 associato ad ogni immagine acquisita dalle videocamere. Ovviamente, \u00e8 anche possibile che pi\u00f9 campioni provengano da meccanismi di generazione dei dati molto simili: ad esempio, potremmo avere due righe che descrivono lo stesso passeggero, o due immagini che riprendono la stessa persona dalla stessa angolazione: in questo caso, occorre valutare se vi \u00e8 della ridondanza tra i dati, ed eventualmente effettuarne un filtraggio. L'estremizzazione di questo principio porta alla problematica degli imbalanced data , ovvero dei dataset sbilanciati verso un'unica classe.","title":"Campioni e sbilanciamento del dataset"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#feature-e-feature-selection","text":"D'altro canto, le colonne sono le feature del nostro dataset. Nel caso del dataset del Titanic, abbiamo a che fare con il nome del passeggero, la cabina, o ad esempio la modalit\u00e0 di imbarco; nel caso di un dataset relativo a dati acquisiti da sensori, potremmo avere le letture di temperatura e di umidit\u00e0, ad esempio. Per un dataset di immagini, invece, le feature sono, in senso lato, tutte le forme, a differenti livelli di astrazione, che possono essere individuate all'interno dell'immagine. Cos\u00ec come per i dati, anche le feature possono essere ridondanti . Se, ad esempio, notassimo che le letture derivanti dal sensore di ossigeno sono linearmente proporzionali rispetto a quelle derivanti dal sensore di temperatura, potremmo decidere di eliminare una delle due letture; lo stesso potremmo fare nel caso individuassimo delle feature a bassa varianza, e che quindi assumono lo stesso valore (o quasi) per tutti i dati. Questo processo di eliminazione, chiamato feature selection , \u00e8 estremamente importante, soprattutto perch\u00e9 avere troppe feature significa rischiare di incorrere nel fenomeno della curse of dimensionality .","title":"Feature e feature selection"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#curse-of-dimensionality","text":"Nell'ambito del machine learning, la curse of dimensionality indica quel fenomeno che insorge quando il numero di feature \u00e8 paragonabile a quello dei campioni. Dobbiamo ricordare che il machine learning non fa altro che provare ad \"estrarre\" una relazione tra i campioni e le feature che li rappresentano: in altre parole, gli algoritmi tentano di capire se, ad esempio, esiste una correlazione tra tutti i passeggeri maschi di et\u00e0 inferiore ai 18 anni, oppure se le donne con et\u00e0 superiore ai 60 anni hanno aderito ad un certo piano tariffario, e via dicendo. Per far questo, \u00e8 necessario che ci siano abbastanza campioni per descrivere ogni possibile comportamento del fenomeno sotto osservazione: ad esempio, se vi \u00e8 soltanto una donna che ha pagato il biglietto pi\u00f9 di 10 dollari, \u00e8 plausibile che questa informazione sia inutile , ancorch\u00e9 fuorviante , mentre se un gran numero di ragazzi \u00e8 stipato nelle cabine del secondo piano, allora, l'informazione avr\u00e0 un valore del tutto differente. La conseguenza immediata di ci\u00f2, e che \u00e8 alla base della curse of dimensionality, risiede quindi nel fatto che quando il numero di feature \u00e8 circa uguale a quello dei campioni \u00e8 molto probabile che l'algoritmo non sar\u00e0 in grado di caratterizzare in maniera adeguata il fenomeno sottostante. Le soluzioni a quel punto saranno due: da un lato, potremo provare ad aumentare il numero dei campioni, mentre dall'altro potremo provare a rimuovere le feature poco significative, o anche quelle tra loro correlate, aiutando a mitigare la curse of dimensionality.","title":"Curse of dimensionality"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#tipi-di-dati","text":"Abbiamo finora parlato di campioni e feature. Tuttavia, non abbiamo ancora affrontato un aspetto fondamentale nell'analisi dei dati, ovvero la valutazione del tipo di dato , la quale determina, di conseguenza, la scelta dell'algoritmo da utilizzare. Sostanzialmente, esistono due tipi di dati, ovvero i dati indipendenti ed identicamente distribuiti ( IID ) e le serie temporali .","title":"Tipi di dati"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#dati-indipendenti-ed-identicamente-distribuiti","text":"I dati IID sono, come dice il nome stesso, indipendenti l'uno dall'altro; inoltre, tutti i dati fanno parte dello stesso meccanismo di generazione dei dati, e quindi si suppone sottendano alla stessa distribuzione . In altri termini, ci\u00f2 significa che il valore di un campione non dipende dal valore di un altro. Un esempio sono le immagini di diversi oggetti, che possono essere usate per creare un algoritmo di identificazione degli oggetti, oppure gli stessi passeggeri del Titanic. Tipicamente, su questo tipo di dati sono usate tre tipi di algoritmi, ovvero regressione , classificazione e clustering .","title":"Dati indipendenti ed identicamente distribuiti"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#classificazione","text":"Le tecniche di classificazione prevedono che ad ogni dato sia assegnata una classe , comportando di conseguenza un \"raggruppamento\" degli stessi in base alle indicazioni sulle classi. Un esempio sono le classificazioni delle immagini rispetto al tipo di oggetto raffigurato: le immagini relative ad un'auto apparterranno alla classe omonima, mentre le immagini di un cane apparteranno ad un'altra classe, e via dicendo. Altro esempio sono \u00e8 una possibile classificazione dei passeggeri del Titanic sulla base del fatto che siano sopravvissuti o meno.","title":"Classificazione"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#regressione","text":"Le tecniche di regressione cercano invece di trovare una relazione tra le feature di ciascun dato ed un valore numerico (TODO: verificare se continuo o discreto). Rimanendo ai passeggeri del Titanic, potremmo voler valutare il rapporto esistente tra l'et\u00e0 del passeggero ed il prezzo che questi ha pagato per il biglietto.","title":"Regressione"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#clustering","text":"In ultimo, le tecniche di clustering provano ad inferire dei \"raggruppamenti\", chiamati formalmente cluster , di dati. Ovviamente, i dati appartenenti ad un cluster sono da considerarsi affini , mentre i dati appartenenti a cluster differenti sono da considerarsi differenti . Il clustering non prevede la presenza di alcuna classe. Di conseguenza, queste tecniche di apprendimento sono dette non supervisionate , in quanto non \u00e8 necessario l'intervento di un esperto di dominio per definire le classi cui appartengono i dati su cui viene addestrato l'algoritmo.","title":"Clustering"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#serie-temporali","text":"A d\u00ecfferenza dei dati IID, le serie temporali sono composte da dati tra loro interdipendenti, e \"correlati\" da vincoli temporali. Esempi di questo tipo di dati sono i video, composti da sequenze di immagini disposte in un ben preciso ordine temporale, oppure ancora le acquisizioni derivate da un sensore. Nota Parleremo pi\u00f9 estensivamente delle serie temporali nella lezione su StatsModels.","title":"Serie temporali"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#concetti-base-di-scikit-learn","text":"","title":"Concetti base di Scikit-Learn"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#stimatori","text":"Scikit-Learn definisce gli algoritmi di machine learning come stimatori : in tal senso, sia gli algoritmi di clustering, sia quelli di regressione, sia quelli di classificazione sono trattati, per l'appunto, come stimatori. Nota Come vedremo, questa caratterizzazione permette a Scikit-Learn di offrire un'interfaccia comune per la maggior parte degli algoritmi.","title":"Stimatori"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#parametri-dello-stimatore","text":"Molto importanti sono i parametri con cui regolare il funzionamento dello stimatore. Ad esempio, per l'algoritmo KMeans , un possibile parametro \u00e8 il numero di cluster in cui i dati sono suddivisi. Vedremo come modificare questi parametri pu\u00f2 cambiare enormemente le performance di un algoritmo. Performance che, ovviamente, sono valutate secondo apposite metriche .","title":"Parametri dello stimatore"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#metriche","text":"Ogni algoritmo viene valutato secondo una metrica, che di solito permette di definire, in termini percentuali o assoluti, l'accuratezza dell'algoritmo.","title":"Metriche"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#preprocessing","text":"Molto spesso, \u00e8 necessario effettuare delle operazioni di preprocessing ( mai usare preprocessamento ) sui dati. Questo perch\u00e9 questi possono essere viziati dall'assenza di valori in determinati ambiti, oppure \u00e8 necessario scalarli. Scikit-Learn offre un intero package dedicato a questo. Le funzioni che utilizzeremo maggiormente saranno: train_test_split , per suddividere il dataset in un insieme di training ed uno di test; gli Imputer , per assegnare eventuali valori mancanti all'interno del dataset; i Transformer , che ci permettono di modificare il tipo dei dati.","title":"Preprocessing"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#pipeline","text":"Accenniamo in ultimo al fatto che, normalmente, \u00e8 necessario concatenare diversi stimatori. Per farlo, Scikit-Learn ci mette a disposizione un'apposita struttura chiamata Pipeline , che approfondiremo nelle prossime lezioni.","title":"Pipeline"},{"location":"material/02_libs/11_sklearn/02_intro_sk/lecture/#train-test-e-cross-validazione","text":"Apprendere i parametri di uno stimatore e testarlo sugli stessi dati \u00e8 un errore metodologico: un modello che infatti si limitasse a ripetere le label dei campioni che ha appena visto avrebbe un punteggio perfetto, ma non sarebbe in grado di predire qualcosa di utile su dati non ancora visti. Questa situazione \u00e8 comunemente chiamata overfitting . Per evitare l'overfitting, nei metodi supervisionati, si usa \"lasciar fuori\" parte dei dati disponibili e chiamarla set di test . La funzione principe per questo in scikit learn \u00e8 train test split. Tuttavia, pu\u00f2 essere anche possibile che si debbano valutare diversi iperparametri per un singolo stimatore. Il concetto di iperparametro \u00e8 analogo a quello di configurazione, e non sono chiamati parametri per evitare di generare confusione con i parametri che vengono configurati internamente da uno stimatore durante l'apprendimento. Quando valutiamo diverse combinazioni di iperparametri, \u00e8 possibile che vi sia un overfitting verso il test set, perch\u00e9 potremmo voler ritarare i parametri in modo da ottenere delle performance di validazione quanto migliori possibile. In questo modo, \u00e8 possibile che il meccanismo di generazione dei dati caratteristico del test set possa \"fuoriuscire\" all'interno del modello, causando conseguentemente un peggioramento delle capacit\u00e0 di generalizzazione. Per risolvere questo problema, ogni parte del dataset pu\u00f2 essere messa fuori in quello che viene chiamato set di validazione : il training avviene sul set di raining, la cui valutazione avviene sul set di valudazione,e quando l'esperimento sembra aver successo, la valutazione finale pu\u00f2 essere fatta sul set di test. Ad ogni modo, il partizionamento in questo modo riduce drasticametne il numero di campioni che pu\u00f2 essere usato per apprendere il modello, ed i risultati possono dipende da una scelta casuale dalla coppia degli insieme (train, validazione). Una soluzione di questo problema \u00e8 una procedura chiamato cross-validazione. Un set test deve essere sempre tenuto da parte per una valutazione finale, ma non \u00e8 necessario il test di validazione. In questo approccio base, chiamato k-fold CV, il set di training \u00e8 suddiviso in k set pi\u00f9 piccoli. La procedura \u00e8 la seguente: un modello viene addestrato usando \\(k - 1\\) dei fold come training data; il modello risultante \u00e8 validato sulla parte rimanente dei dati (ovvero \u00e8 usato come test set per calcolare una misura di performacnce come l'accuracy.) La misura di performance restituita dai k-fold \u00e8 quindi la media dei valori calcolati nel ciclo.","title":"Train, test e cross-validazione"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/","text":"Il problema della classificazione \u00b6 Nella lezione precedente abbiamo brevemente introdotto il problema della classificazione che, come il nome stesso suggerisce, prevede che ad ogni dato sia assegnata una classe , da intendersi come insieme di propriet\u00e0 ed attributi che permettono di distinguere oggetti con caratteristiche differenti. Facciamo un breve esempio. Due immagini, infatti, appartengono alla stessa classe nel caso ritraggono due campioni dello stesso tipo: due gatti, ad esempio, o due auto sportive. Se avessimo a che fare con l'immagine di un cane e quella di un gatto, invece, potremmo ragionevolmente desumere che appartengono a due classi differenti. Nel caso del Titanic, invece, potremmo classificare i passeggeri come sopravvissuti e non sopravvissuti , andando quindi a caratterizzare i due gruppi in base alle loro caratteristiche. Note Il concetto di classe \u00e8 tuttavia correlato al dominio che ci troviamo a trattare. Per capirci, qualora stessimo classificando tutti i \"quadrupedi\", cane e gatto apparterrebbero alla stessa classe. Classificazione supervisionata e non supervisioata \u00b6 La classificazione \u00e8 spesso approcciata in maniera supervisionata . Questo prevede che un esperto di dominio \"contrassegni\", o per meglio dire etichetti , una serie di dati mediante la procedura di labeling . Tornando all'esempio delle immagini, l'esperto di dominio dovrebbe assegnare l'etichetta cane alle immagini raffiguranti un cane, mentre l'etichetta gatto andrebbe assegnata alle immagini contenente un gatto. Per quello che riguarda il dataset del Titanic, l'etichetta sar\u00e0 assegnata per ogni passeggero in base al fatto che questo sia sopravvissuto o meno. Nota Ovviamente, questi sono casi \"semplici\" di labeling. Esistono, nella realt\u00e0, casi molto pi\u00f9 complessi, nei quali l'esperto di dominio deve essere altamente qualificato. Esiste anche la possibilit\u00e0 di usare un approccio non supervisionato , che non prevede la presenza di un esperto di dominio, e che conseguentemente inferisce la struttura dei dati da essi stessi. In questo corso, tratteremo il clustering, che \u00e8 un approccio totalmente non supervisionato. Tipi di classificazione \u00b6 Oltre alla distinzione tra approcci supervisionati e non, ne esistono delle altre legate al numero di classi e label assegnate ai vari campioni. Classificazione binaria \u00b6 I problemi di classificazione binaria prevedono che gli output siano soltanto due, di solito vero e falso , in ovvia analogia con la logica booleana. Un tipico esempio di un problema binario \u00e8 quello del riconoscimento del volto di una persona, nel quale il sistema di machine learning deve restituire vero se il volto viene riconosciuto correttamente, e falso altrimenti. Altro esempio \u00e8 quello cui abbiamo accennato in precedenza a riguardo della sopravvivenza dei passeggeri del Titanic. Classificazione multi-classe \u00b6 I problemi che prevedono pi\u00f9 di due classi sono detto multi-classe . Tornando all'elaborazione delle immagini, il riconoscimento del tipo di oggetto raffigurato nella foto \u00e8 un problema tipicamente multi-classe, dato che questo pu\u00f2 appartenere ad un elevato numero di classi (ad esempio, auto, smartphone, animali, etc.). Tornando al dataset Titanic, un esempio di problema multi-classe potrebbe prevedere l'esigenza di classificare i passeggeri in base al compartimento nel quale era situata la loro cabina. Classificazione multi-task \u00b6 Parliamo di classificazione multi-task quando abbiamo diversi problemi che devono essere risolti contemporaneamente. Pensiamo, ad esempio, ad un problema che richieda di distinguere un gatto da una tigre, e, contestualmente, di descrivere l'ambiente in cui si trova l'animale. Ovviamente, il problema consta di due aspetti, che per\u00f2 sono tra loro correlati: infatti, \u00e8 molto probabile che una tigre si trovi in un ambiente di tipo \"selvaggio\", mentre che la foto del gatto sia all'interno di una casa o comunque di un ambiente pi\u00f9 \"urbano\". In questo caso, si potrebbero addestrare pi\u00f9 classificatori, o combinarne diversi in un unico stimatore, per raggiungere il risultato finale. Classificazione multi-label \u00b6 La classificazione multi-label \u00e8 un caso particolare di classificazione multi-task. Per rimanere nello stesso ambito del caso precedente, potremmo voler considerare un'immagine che abbia al suo interno diversi animali, come ad esempio un gatto, un cane ed una gallina. Il problema multi-label pu\u00f2 prevedere, abbastanza banalmente, la descrizione della presenza (o meno) dei diversi animali all'interno della foto; per far questo, il classificatore si pone di suddividere l'immagine in diversi problemi di classificazione binaria, in particolare rispondendo alle domande: Vi \u00e8 un cane nell'immagine? Vi \u00e8 un gatto nell'immagine? Vi \u00e8 una gallina nell'immagine? Valutare un algoritmo di classificazione: le metriche \u00b6 Gli algoritmi di classificazione (e, pi\u00f9 in generale, tutti gli algoritmi di machine learning) sono valutati sulla base di una o pi\u00f9 metriche che, nel caso specifico, mettono in evidenza in che percentuale l'algoritmo \u00e8 in grado di determinare correttamente l'appartenenza o meno di un campione ad una classe. Vediamo in tal senso alcune delle metriche maggiormente usate. Accuracy \u00b6 L'accuracy \u00e8 definita come una misura dell'errore introdotto dal sistema di classificazione nella corretta identificazione della classe di un campione, valutata sull'intero set di test. Ad esempio, se il nostro classificatore ha un output di questo tipo: \\[ \\hat{y} = [1, 1, 2, 1, 2] \\] mentre le classi \"vere\" sono definite dal seguente vettore delle label: \\[ y = [1, 1, 1, 2, 2] \\] allora l'accuracy \u00e8 data da: \\[ acc(y, \\hat{y}) = \\frac{i}{n} \\sum_{i=0}^{n-1} 1(\\hat{y_i} = y_i) \\] In altri termini, l'accuracy \u00e8 data dal rapporto tra la somma del numero di campioni per i quali il predittore \u00e8 in grado di riconoscere correttamente la classe ed il numero totale dei campioni stessi. Nell'esempio precedente, appare chiaro come: \\[ acc(y, \\hat{y}) = \\frac{1}{5} * 3 = \\frac{3}{5} = 0.6 \\] Per calcolare l'accuracy dei risultati ottenuti dal nostro predittore, Scikit-Learn ci mette a disposizione un'apposita funzione chiamata accuracy_score . Recall \u00b6 Il recall \u00e8 una stima del rapporto tra veri positivi , ovvero il numero di campioni che il classificatore \u00e8 in grado di associare correttamente ad una classe, e falsi negativi , ovvero il numero di campioni che il classificatore non associa ad una determinata classe, sbagliando. Analiticamente: \\[ R = \\frac{TP}{(TP + FN)} \\] In altri termini, il recall pu\u00f2 essere considerato come una stima dei campioni che il classificatore riesce ad associare correttamente ad una classe rispetto al numero totale di quelli effettivamente appartenenti alla stessa. Ovviamente, il valore del recall sar\u00e0 tanto pi\u00f9 vicino ad uno quanto il valore di \\(FN\\) tender\u00e0 a zero, mentre sar\u00e0 tanto pi\u00f9 vicino a \\(0\\) quanto pi\u00f9 \\(TP\\) sar\u00e0 piccolo. Ad esempio: \\[ TP = 10; \\\\ FN = 5; \\\\ R = \\frac{TP}{(TP + FN)} = \\frac{10}{15} ~= 0,67 \\] Anche in questo caso, Scikit-Learn ci mette a disposizione una funzione chiamata recall_score mediante la quale calcolare questa metrica. Il parametro average La funzione recall_score accetta un parametro che, di primo acchitto, potrebbe passare inosservato, ovvero average . Questo \u00e8 in realt\u00e0 molto importante, in quanto deve essere impsotato in base alle specifiche del problema sotto osservazione. Cos\u00ec, in caso di classificazione binaria, dovremo usare average='binary' , specificando anche la classe sulla quale ci interessa calcolare il recall; nel caso di classi non bilanciate, invece, potremmo preferire la modalit\u00e0 'macro' alla modalit\u00e0 'micro' . Precision \u00b6 Simile al recall \u00e8 la precision , calcolata questa volta usando la seguente formula: \\[ R = \\frac{TP}{(TP + FP)} \\] dove \\(FP\\) \u00e8 il numero di falsi positivi , ovvero dei campioni che il classificatore reputa erroneamente appartenenti ad una certa classe. La precision pu\u00f2 quindi essere descritta come la capacit\u00e0 del classificatore di non assegnare una certa classe a campioni appartenenti ad un'altra. Per la precision valgono esattamente le stesse considerazioni fatte per il recall; l'unica differenza sostanziale, oltre quella \"semantica\", sta nel fatto che viene calcolata usando la funzione precision_score . Matrice di confusione \u00b6 Un altro modo di rappresentare i risultati ottenuti da un classificatore \u00e8 quello di usare una matrice di confusione . La definizione di una matrice di confusione \\(C\\) \u00e8 tale che \\(C_{i,j}\\) sia uguale al numero di osservazioni che sono nel gruppo \\(i\\) , ma che vengono predette dal classificatore nel gruppo \\(j\\) . Algoritmi di classificazione \u00b6 Scikit-Learn offre un gran numero di metodi di classificazione. In questo corso, ci limiteremo a descrivere brevemente un paio di algoritmi, ovvero le SVM e gli alberi decisionali. Al solito, per\u00f2, \u00e8 importante sottolineare come Scikit-Learn offra un'interfaccia in tutto e per tutto omogenea tra i diversi algoritmi, il che ci permette quindi di modificare il nostro approccio riscrivendo solo piccole parti del nostro codice. Un primo esempio: gli alberi decisionali \u00b6 Gli alberi decisionali sono tra gli algoritmi pi\u00f9 semplici che possiamo utilizzare per classificare dei dati. Un albero decisionale agisce sulle singole feature, impostando delle \"regole\" sulla base delle quali si stabilisce un outcome certo outcome. Partiamo da un esempio illustrato nella figura successiva. Un classificatore basato su albero decisionale prevede una struttura di questo tipo. Comprendere il funzionamento di un albero decisionale \u00e8 abbastanza semplice. L'obiettivo di un albero decisionale \u00e8 quello di creare un modello che predica il valore di una variabile obiettivo imparando delle semplici regole decisionali apprese a partire dalle feature dei dati. In pratica, possiamo pensare ad un albero come ad un percorso \"a step\", nel quale ad ogni step vi \u00e8 un'approssimazione successiva verso il risultato finale. Questo esempio mostra le possibilit\u00e0 di sopravvivenza individuate tra i passeggeri del Titanic, assieme alle percentuali di questi sul totale. La suddivisione che viene subito all'occhio \u00e8 la seguente: il 36% dei passaggeri era donna; il 60% uomo di et\u00e0 superiore ai 9 anni e 6 mesi; il 4% uomo di et\u00e0 inferiore ai 9 anni e 6 mesi. L'albero invece ci dice che sono sopravvissuti: il 73% delle donne; il 17% degli uomini con pi\u00f9 di 9 anni e 6 mesi; il 2% degli uomini con meno di 9 anni e 6 mesi, con pi\u00f9 di tre fratelli; l'89% degli uomini con meno di 9 anni e 6 mesi, con meno di tre fratelli. Le Support Vector Machine \u00b6 Le Support Vector Machine ( SVM ) operano sulla disposizione dei dati nell'iperspazio delle feature, cercando di individuare un iperpiano ottimale che ne consenta la migliore separazione possibile. Questo tipo di algoritmo prende il nome dai dati pi\u00f9 vicini all'iperpiano, che sono chiamati Support Vector . Nella figura successiva, presa da WikiMedia e creata da Zack Weinberg , vediamo un esempio in un piano a due dimensioni. Le SVM calcolano la distanza tra i campioni mediante un'apposita funzione, chiamata kernel . Ve ne sono di diversi tipi, ognuno dei quali permette di ottenere risultati pi\u00f9 o meno validi a seconda delle diverse situazioni. Nota Le SVM, per loro natura, sono utili principalmente in caso di classificazione binaria. In realt\u00e0, per\u00f2, gli algoritmi offerti da Scikit Learn permettono di implementare in maniera automatica anche la classificazione multi-classe, sfruttando un approccio chiamato one-to-one , che scompone il problema in una serie di problemi binari, sulla stregua della classificazione multi-label.","title":"11.3 - Classificazione in Scikit-Learn"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#il-problema-della-classificazione","text":"Nella lezione precedente abbiamo brevemente introdotto il problema della classificazione che, come il nome stesso suggerisce, prevede che ad ogni dato sia assegnata una classe , da intendersi come insieme di propriet\u00e0 ed attributi che permettono di distinguere oggetti con caratteristiche differenti. Facciamo un breve esempio. Due immagini, infatti, appartengono alla stessa classe nel caso ritraggono due campioni dello stesso tipo: due gatti, ad esempio, o due auto sportive. Se avessimo a che fare con l'immagine di un cane e quella di un gatto, invece, potremmo ragionevolmente desumere che appartengono a due classi differenti. Nel caso del Titanic, invece, potremmo classificare i passeggeri come sopravvissuti e non sopravvissuti , andando quindi a caratterizzare i due gruppi in base alle loro caratteristiche. Note Il concetto di classe \u00e8 tuttavia correlato al dominio che ci troviamo a trattare. Per capirci, qualora stessimo classificando tutti i \"quadrupedi\", cane e gatto apparterrebbero alla stessa classe.","title":"Il problema della classificazione"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#classificazione-supervisionata-e-non-supervisioata","text":"La classificazione \u00e8 spesso approcciata in maniera supervisionata . Questo prevede che un esperto di dominio \"contrassegni\", o per meglio dire etichetti , una serie di dati mediante la procedura di labeling . Tornando all'esempio delle immagini, l'esperto di dominio dovrebbe assegnare l'etichetta cane alle immagini raffiguranti un cane, mentre l'etichetta gatto andrebbe assegnata alle immagini contenente un gatto. Per quello che riguarda il dataset del Titanic, l'etichetta sar\u00e0 assegnata per ogni passeggero in base al fatto che questo sia sopravvissuto o meno. Nota Ovviamente, questi sono casi \"semplici\" di labeling. Esistono, nella realt\u00e0, casi molto pi\u00f9 complessi, nei quali l'esperto di dominio deve essere altamente qualificato. Esiste anche la possibilit\u00e0 di usare un approccio non supervisionato , che non prevede la presenza di un esperto di dominio, e che conseguentemente inferisce la struttura dei dati da essi stessi. In questo corso, tratteremo il clustering, che \u00e8 un approccio totalmente non supervisionato.","title":"Classificazione supervisionata e non supervisioata"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#tipi-di-classificazione","text":"Oltre alla distinzione tra approcci supervisionati e non, ne esistono delle altre legate al numero di classi e label assegnate ai vari campioni.","title":"Tipi di classificazione"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#classificazione-binaria","text":"I problemi di classificazione binaria prevedono che gli output siano soltanto due, di solito vero e falso , in ovvia analogia con la logica booleana. Un tipico esempio di un problema binario \u00e8 quello del riconoscimento del volto di una persona, nel quale il sistema di machine learning deve restituire vero se il volto viene riconosciuto correttamente, e falso altrimenti. Altro esempio \u00e8 quello cui abbiamo accennato in precedenza a riguardo della sopravvivenza dei passeggeri del Titanic.","title":"Classificazione binaria"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#classificazione-multi-classe","text":"I problemi che prevedono pi\u00f9 di due classi sono detto multi-classe . Tornando all'elaborazione delle immagini, il riconoscimento del tipo di oggetto raffigurato nella foto \u00e8 un problema tipicamente multi-classe, dato che questo pu\u00f2 appartenere ad un elevato numero di classi (ad esempio, auto, smartphone, animali, etc.). Tornando al dataset Titanic, un esempio di problema multi-classe potrebbe prevedere l'esigenza di classificare i passeggeri in base al compartimento nel quale era situata la loro cabina.","title":"Classificazione multi-classe"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#classificazione-multi-task","text":"Parliamo di classificazione multi-task quando abbiamo diversi problemi che devono essere risolti contemporaneamente. Pensiamo, ad esempio, ad un problema che richieda di distinguere un gatto da una tigre, e, contestualmente, di descrivere l'ambiente in cui si trova l'animale. Ovviamente, il problema consta di due aspetti, che per\u00f2 sono tra loro correlati: infatti, \u00e8 molto probabile che una tigre si trovi in un ambiente di tipo \"selvaggio\", mentre che la foto del gatto sia all'interno di una casa o comunque di un ambiente pi\u00f9 \"urbano\". In questo caso, si potrebbero addestrare pi\u00f9 classificatori, o combinarne diversi in un unico stimatore, per raggiungere il risultato finale.","title":"Classificazione multi-task"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#classificazione-multi-label","text":"La classificazione multi-label \u00e8 un caso particolare di classificazione multi-task. Per rimanere nello stesso ambito del caso precedente, potremmo voler considerare un'immagine che abbia al suo interno diversi animali, come ad esempio un gatto, un cane ed una gallina. Il problema multi-label pu\u00f2 prevedere, abbastanza banalmente, la descrizione della presenza (o meno) dei diversi animali all'interno della foto; per far questo, il classificatore si pone di suddividere l'immagine in diversi problemi di classificazione binaria, in particolare rispondendo alle domande: Vi \u00e8 un cane nell'immagine? Vi \u00e8 un gatto nell'immagine? Vi \u00e8 una gallina nell'immagine?","title":"Classificazione multi-label"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#valutare-un-algoritmo-di-classificazione-le-metriche","text":"Gli algoritmi di classificazione (e, pi\u00f9 in generale, tutti gli algoritmi di machine learning) sono valutati sulla base di una o pi\u00f9 metriche che, nel caso specifico, mettono in evidenza in che percentuale l'algoritmo \u00e8 in grado di determinare correttamente l'appartenenza o meno di un campione ad una classe. Vediamo in tal senso alcune delle metriche maggiormente usate.","title":"Valutare un algoritmo di classificazione: le metriche"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#accuracy","text":"L'accuracy \u00e8 definita come una misura dell'errore introdotto dal sistema di classificazione nella corretta identificazione della classe di un campione, valutata sull'intero set di test. Ad esempio, se il nostro classificatore ha un output di questo tipo: \\[ \\hat{y} = [1, 1, 2, 1, 2] \\] mentre le classi \"vere\" sono definite dal seguente vettore delle label: \\[ y = [1, 1, 1, 2, 2] \\] allora l'accuracy \u00e8 data da: \\[ acc(y, \\hat{y}) = \\frac{i}{n} \\sum_{i=0}^{n-1} 1(\\hat{y_i} = y_i) \\] In altri termini, l'accuracy \u00e8 data dal rapporto tra la somma del numero di campioni per i quali il predittore \u00e8 in grado di riconoscere correttamente la classe ed il numero totale dei campioni stessi. Nell'esempio precedente, appare chiaro come: \\[ acc(y, \\hat{y}) = \\frac{1}{5} * 3 = \\frac{3}{5} = 0.6 \\] Per calcolare l'accuracy dei risultati ottenuti dal nostro predittore, Scikit-Learn ci mette a disposizione un'apposita funzione chiamata accuracy_score .","title":"Accuracy"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#recall","text":"Il recall \u00e8 una stima del rapporto tra veri positivi , ovvero il numero di campioni che il classificatore \u00e8 in grado di associare correttamente ad una classe, e falsi negativi , ovvero il numero di campioni che il classificatore non associa ad una determinata classe, sbagliando. Analiticamente: \\[ R = \\frac{TP}{(TP + FN)} \\] In altri termini, il recall pu\u00f2 essere considerato come una stima dei campioni che il classificatore riesce ad associare correttamente ad una classe rispetto al numero totale di quelli effettivamente appartenenti alla stessa. Ovviamente, il valore del recall sar\u00e0 tanto pi\u00f9 vicino ad uno quanto il valore di \\(FN\\) tender\u00e0 a zero, mentre sar\u00e0 tanto pi\u00f9 vicino a \\(0\\) quanto pi\u00f9 \\(TP\\) sar\u00e0 piccolo. Ad esempio: \\[ TP = 10; \\\\ FN = 5; \\\\ R = \\frac{TP}{(TP + FN)} = \\frac{10}{15} ~= 0,67 \\] Anche in questo caso, Scikit-Learn ci mette a disposizione una funzione chiamata recall_score mediante la quale calcolare questa metrica. Il parametro average La funzione recall_score accetta un parametro che, di primo acchitto, potrebbe passare inosservato, ovvero average . Questo \u00e8 in realt\u00e0 molto importante, in quanto deve essere impsotato in base alle specifiche del problema sotto osservazione. Cos\u00ec, in caso di classificazione binaria, dovremo usare average='binary' , specificando anche la classe sulla quale ci interessa calcolare il recall; nel caso di classi non bilanciate, invece, potremmo preferire la modalit\u00e0 'macro' alla modalit\u00e0 'micro' .","title":"Recall"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#precision","text":"Simile al recall \u00e8 la precision , calcolata questa volta usando la seguente formula: \\[ R = \\frac{TP}{(TP + FP)} \\] dove \\(FP\\) \u00e8 il numero di falsi positivi , ovvero dei campioni che il classificatore reputa erroneamente appartenenti ad una certa classe. La precision pu\u00f2 quindi essere descritta come la capacit\u00e0 del classificatore di non assegnare una certa classe a campioni appartenenti ad un'altra. Per la precision valgono esattamente le stesse considerazioni fatte per il recall; l'unica differenza sostanziale, oltre quella \"semantica\", sta nel fatto che viene calcolata usando la funzione precision_score .","title":"Precision"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#matrice-di-confusione","text":"Un altro modo di rappresentare i risultati ottenuti da un classificatore \u00e8 quello di usare una matrice di confusione . La definizione di una matrice di confusione \\(C\\) \u00e8 tale che \\(C_{i,j}\\) sia uguale al numero di osservazioni che sono nel gruppo \\(i\\) , ma che vengono predette dal classificatore nel gruppo \\(j\\) .","title":"Matrice di confusione"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#algoritmi-di-classificazione","text":"Scikit-Learn offre un gran numero di metodi di classificazione. In questo corso, ci limiteremo a descrivere brevemente un paio di algoritmi, ovvero le SVM e gli alberi decisionali. Al solito, per\u00f2, \u00e8 importante sottolineare come Scikit-Learn offra un'interfaccia in tutto e per tutto omogenea tra i diversi algoritmi, il che ci permette quindi di modificare il nostro approccio riscrivendo solo piccole parti del nostro codice.","title":"Algoritmi di classificazione"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#un-primo-esempio-gli-alberi-decisionali","text":"Gli alberi decisionali sono tra gli algoritmi pi\u00f9 semplici che possiamo utilizzare per classificare dei dati. Un albero decisionale agisce sulle singole feature, impostando delle \"regole\" sulla base delle quali si stabilisce un outcome certo outcome. Partiamo da un esempio illustrato nella figura successiva. Un classificatore basato su albero decisionale prevede una struttura di questo tipo. Comprendere il funzionamento di un albero decisionale \u00e8 abbastanza semplice. L'obiettivo di un albero decisionale \u00e8 quello di creare un modello che predica il valore di una variabile obiettivo imparando delle semplici regole decisionali apprese a partire dalle feature dei dati. In pratica, possiamo pensare ad un albero come ad un percorso \"a step\", nel quale ad ogni step vi \u00e8 un'approssimazione successiva verso il risultato finale. Questo esempio mostra le possibilit\u00e0 di sopravvivenza individuate tra i passeggeri del Titanic, assieme alle percentuali di questi sul totale. La suddivisione che viene subito all'occhio \u00e8 la seguente: il 36% dei passaggeri era donna; il 60% uomo di et\u00e0 superiore ai 9 anni e 6 mesi; il 4% uomo di et\u00e0 inferiore ai 9 anni e 6 mesi. L'albero invece ci dice che sono sopravvissuti: il 73% delle donne; il 17% degli uomini con pi\u00f9 di 9 anni e 6 mesi; il 2% degli uomini con meno di 9 anni e 6 mesi, con pi\u00f9 di tre fratelli; l'89% degli uomini con meno di 9 anni e 6 mesi, con meno di tre fratelli.","title":"Un primo esempio: gli alberi decisionali"},{"location":"material/02_libs/11_sklearn/03_classification/lecture/#le-support-vector-machine","text":"Le Support Vector Machine ( SVM ) operano sulla disposizione dei dati nell'iperspazio delle feature, cercando di individuare un iperpiano ottimale che ne consenta la migliore separazione possibile. Questo tipo di algoritmo prende il nome dai dati pi\u00f9 vicini all'iperpiano, che sono chiamati Support Vector . Nella figura successiva, presa da WikiMedia e creata da Zack Weinberg , vediamo un esempio in un piano a due dimensioni. Le SVM calcolano la distanza tra i campioni mediante un'apposita funzione, chiamata kernel . Ve ne sono di diversi tipi, ognuno dei quali permette di ottenere risultati pi\u00f9 o meno validi a seconda delle diverse situazioni. Nota Le SVM, per loro natura, sono utili principalmente in caso di classificazione binaria. In realt\u00e0, per\u00f2, gli algoritmi offerti da Scikit Learn permettono di implementare in maniera automatica anche la classificazione multi-classe, sfruttando un approccio chiamato one-to-one , che scompone il problema in una serie di problemi binari, sulla stregua della classificazione multi-label.","title":"Le Support Vector Machine"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/","text":"Il problema della regressione \u00b6 Quello della regressione \u00e8 un problema che si distingue dalla classificazione sotto diversi aspetti, pur conservando alcuni punti in comune con quest'ultima. La differenza che salta subito all'occhio \u00e8 infatti che, laddove nella classificazione cerchiamo di caratterizzare la relazione tra una serie di feature in ingresso ed una classe, nella regressione la relazione \u00e8 tra una serie di variabili indipendenti ed una o pi\u00f9 variabili dipendenti . Nota Per essere precisi, occorre tenere conto anche di un termine di errore, che pu\u00f2 essere pi\u00f9 o meno rilevante. Un esempio banale di regressione \u00e8 quello che ci vede cercare la retta interpolate di una serie di punti in un piano cartesiano Metriche \u00b6 Algoritmi di regressione \u00b6 Cos\u00ec come per la classificazione, Scikit Learn offre una gran numero di algoritmi che possiamo utilizzare per la regressione. Anche stavolta, non descriveremo i singoli algoritmi, sottolineando comunque come l'interfaccia offerta da questi sia in tutto e per tutto omogenea, il che ci permette quindi di modificare facilmente l'algoritmo utilizzato. Regressione lineare \u00b6 Alberi decisionali \u00b6 Metodi ensemble \u00b6","title":"11.4 - Regressione in Scikit-Learn"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#il-problema-della-regressione","text":"Quello della regressione \u00e8 un problema che si distingue dalla classificazione sotto diversi aspetti, pur conservando alcuni punti in comune con quest'ultima. La differenza che salta subito all'occhio \u00e8 infatti che, laddove nella classificazione cerchiamo di caratterizzare la relazione tra una serie di feature in ingresso ed una classe, nella regressione la relazione \u00e8 tra una serie di variabili indipendenti ed una o pi\u00f9 variabili dipendenti . Nota Per essere precisi, occorre tenere conto anche di un termine di errore, che pu\u00f2 essere pi\u00f9 o meno rilevante. Un esempio banale di regressione \u00e8 quello che ci vede cercare la retta interpolate di una serie di punti in un piano cartesiano","title":"Il problema della regressione"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#metriche","text":"","title":"Metriche"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#algoritmi-di-regressione","text":"Cos\u00ec come per la classificazione, Scikit Learn offre una gran numero di algoritmi che possiamo utilizzare per la regressione. Anche stavolta, non descriveremo i singoli algoritmi, sottolineando comunque come l'interfaccia offerta da questi sia in tutto e per tutto omogenea, il che ci permette quindi di modificare facilmente l'algoritmo utilizzato.","title":"Algoritmi di regressione"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#regressione-lineare","text":"","title":"Regressione lineare"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#alberi-decisionali","text":"","title":"Alberi decisionali"},{"location":"material/02_libs/11_sklearn/04_regression/lecture/#metodi-ensemble","text":"","title":"Metodi ensemble"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/","text":"Il clustering \u00b6 Algoritmi di clustering \u00b6 K-Means \u00b6 Clustering gerarchico \u00b6 DBSCAN \u00b6 Metriche \u00b6 Silhouette score \u00b6 Adjusted Rand Index \u00b6","title":"11.5 - Clustering in Scikit-Learn"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#il-clustering","text":"","title":"Il clustering"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#algoritmi-di-clustering","text":"","title":"Algoritmi di clustering"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#k-means","text":"","title":"K-Means"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#clustering-gerarchico","text":"","title":"Clustering gerarchico"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#dbscan","text":"","title":"DBSCAN"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#metriche","text":"","title":"Metriche"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#silhouette-score","text":"","title":"Silhouette score"},{"location":"material/02_libs/11_sklearn/05_clustering/lecture/#adjusted-rand-index","text":"","title":"Adjusted Rand Index"},{"location":"material/02_libs/12_time/01_statsmodels/lecture/","text":"Le serie temporali \u00b6 Algoritmi \u00b6 Decomposizione STL \u00b6 ARIMA, SARIMA e SARIMAX \u00b6","title":"12.1 - Statsmodels"},{"location":"material/02_libs/12_time/01_statsmodels/lecture/#le-serie-temporali","text":"","title":"Le serie temporali"},{"location":"material/02_libs/12_time/01_statsmodels/lecture/#algoritmi","text":"","title":"Algoritmi"},{"location":"material/02_libs/12_time/01_statsmodels/lecture/#decomposizione-stl","text":"","title":"Decomposizione STL"},{"location":"material/02_libs/12_time/01_statsmodels/lecture/#arima-sarima-e-sarimax","text":"","title":"ARIMA, SARIMA e SARIMAX"},{"location":"material/02_libs/12_time/02_sktime/lecture/","text":"","title":"12.2 - Scikit-Time"},{"location":"material/02_libs/13_dl/01_intro_dl/lecture/","text":"","title":"13.1 - Introduzione al deep learning"},{"location":"material/02_libs/13_dl/02_keras/lecture/","text":"","title":"13.2 - Introduzione a Keras"},{"location":"material/appendix/01_python_vs_code/guide/","text":"Appendice A - Configurazione dell'ambiente di sviluppo Python \u00b6 Installazione di Python \u00b6 Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Iniziare la procedura di installazione (ad esempio, in Windows, cliccando sull'eseguibile appena scaricato). E' fortemente consigliato aggiungere Python al proprio PATH spuntando l'opportuna casella durante l'installazione , come mostrato in figura. Una volta completata la procedura di installazione, aprire uno shell (ad esempio, il prompt dei comandi), e digitare python . Se tutto \u00e8 andato per il verso giusto, apparir\u00e0 una schermata simile alla successiva. Installazione di Visual Studio Code \u00b6 Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Seguire la procedura di installazione mostrata a schermo. E' anche in questo caso consigliata l'aggiunta di Visual Studio Code al path, come mostrato in figura.","title":"A - Installazione di Python e Visual Studio Code"},{"location":"material/appendix/01_python_vs_code/guide/#appendice-a-configurazione-dellambiente-di-sviluppo-python","text":"","title":"Appendice A - Configurazione dell'ambiente di sviluppo Python"},{"location":"material/appendix/01_python_vs_code/guide/#installazione-di-python","text":"Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Iniziare la procedura di installazione (ad esempio, in Windows, cliccando sull'eseguibile appena scaricato). E' fortemente consigliato aggiungere Python al proprio PATH spuntando l'opportuna casella durante l'installazione , come mostrato in figura. Una volta completata la procedura di installazione, aprire uno shell (ad esempio, il prompt dei comandi), e digitare python . Se tutto \u00e8 andato per il verso giusto, apparir\u00e0 una schermata simile alla successiva.","title":"Installazione di Python"},{"location":"material/appendix/01_python_vs_code/guide/#installazione-di-visual-studio-code","text":"Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Seguire la procedura di installazione mostrata a schermo. E' anche in questo caso consigliata l'aggiunta di Visual Studio Code al path, come mostrato in figura.","title":"Installazione di Visual Studio Code"},{"location":"material/appendix/02_libraries/lecture/","text":"Appendice B: Installazione di una libreria Python \u00b6 Per installare una libreria Python abbiamo a disposizione diverse opzioni. Vediamole nel dettaglio, immaginando di voler installare la libreria NumPy. Opzione A: utilizzare pip \u00b6 La prima opzione, e probabilmente quella maggiormente utilizzata, \u00e8 utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Per farlo, apriamo un terminale assicurandoci di avere i diritti di amministratore; in Linux, dovremo usare l'istruzione sudo , a meno che non siamo utenti rott, mentre in Windows ci baster\u00e0 aprire la shell come amministratori. Una volta aperto il terminale, dovremo scrivere: pip install numpy Installare una libreria in questo modo \u00e8 sicuramente molto semplice, ma porta con s\u00e8 uno svantaggio: infatti, l'installazione della stessa avviene globalmente , ovvero risulta essere valida per l'intera macchina. Ci\u00f2 potrebbe non sembrare rilevante; tuttavia, in ben determinate situazioni, si pu\u00f2 rendere necessario installare particolari combinazioni di versioni di librerie, per usufruire di funzionalit\u00e0 successivamente deprecate o, al contrario, non presenti in versioni antecedenti. In tal senso, se installiamo una certa libreria globalmente, tutti i nostri programmi dovranno necessariamente utilizzare quella libreria in quella specifica versione, il che ci pu\u00f2 vincolare fortemente a lungo andare. Opzione B: utilizzare pip ed un ambiente virtuale \u00b6 Un'altra opzione \u00e8 quella di utilizzare pip in un opportuno ambiente virtuale . Quest'ultimo altro non \u00e8 se non un ambiente \"separato\" all'interno del nostro calcolatore, nel quale andremo ad inserire tutte le librerie che utilizzeremo per i progetti da inserire all'interno dell'ambiente (con le versioni specifiche). Per utilizzare questa opzione, dovremo innanzitutto creare un ambiente virtuale. Per farlo, dobbiamo usare un'opportuna libreria Python, che dovremo installare globalmente mediante pip . Nota L'installazione globale delle librerie per la gestione dell'ambiente virtuale \u00e8 strettamente necessaria, e non contraddice il principio descritto nelle righe precedenti: infatti, l'idea \u00e8 che si possa creare un ambiente virtuale in qualsiasi momento . Installiamo quindi la libreria virtualenvwrapper , o l'equivalente porting per Windows virtualenvwrapper-win : ===\"Linux\" pip install virtualenvwrapper ===\"Windows\" pip install virtualenvwrapper-win Una volta completata l'installazione, utilizzeremo il comando mkvirtualenv , seguito da un nome a nostra scelta, per creare l'ambiente virtuale. Ad esempio: mkvirtualenv pcs Noteremo che, a sinistra del terminale, sar\u00e0 apparsa la scritta (pcs) : ( pcs ) current_working_directory/ Questo ci indica che siamo all'interno del nostro ambiente virtuale. Procediamo adesso all'installazione della libreria NumPy mediante pip : ( pcs ) current_working_directory/ pip install numpy In questo modo, avremo installato NumPy esclusivamente all'interno del nostro ambiente virtuale. Per verificarlo, basta eseguire l'istruzione pip freeze , che restituisce tutte le librerie presenti nell'ambiente in cui siamo attualmente, assieme alle loro versioni. Il file requirements.txt Pratica comune \u00e8 quella di memorizzare tutte le librerie presenti in un ambiente virtuale in un file chiamato requirements.txt . Cos\u00ec facendo, un altro programmatore sar\u00e0 in grado di \"clonare\" il nostro ambiente virtuale. Per salvare il file requirements.txt , dovremo usare i seguenti comandi: pip freeze > requirements.txt Per creare un ambiente virtuale come descritto dal file dei requisiti, invece, dovremo eseguire: pip install -r requirements.txt dove il flag -r sta per recursively , ed indica a pip di installare in maniera ricorsiva le librerie indicate nel file requirements.txt . Opzione C: utilizzare una distribuzione di Python per il calcolo scientifico \u00b6 La terza opzione \u00e8 quella di utilizzare una distribuzione di Python specificamente pensata per il calcolo scientifico, come Anaconda . In questo caso, baster\u00e0 scaricare l'installer dal sito ufficiale e seguire la normale procedura di installazione. Il vantaggio di utilizzare una distribuzione di questo tipo sta nel fatto che avremo a disposizione di default la maggior parte delle librerie utilizzate nel calcolo scientifico. Tuttavia, occorre tenere in considerazione il fatto che la libreria \u00e8 specificamente pensata soltanto per scopi scientifici, per cui dovremo considerarlo qualora intendessimo utilizzare Python per progetti di altro tipo. Il package manager di Anaconda Nel caso si decida di optare per l'uso di Anaconda, \u00e8 importante ricordare che questa distribuzione ha un suo package manager, chiamato conda . Questo andr\u00e0 a sostituire pip nell'installazione delle librerie non presenti nella distribuzione. Opzione D: utilizzare un package manager come pipenv \u00b6 L'ultima opzione, che \u00e8 anche quella suggerita in caso di utilizzo professionale ed eterogeneo di Python, \u00e8 quella di affidarsi ad un package manager evoluto, come pipenv . Questo package manager, infatti, automatizza e semplifica la creazione di un ambiente virtuale, combinando la stessa con l'utilizzo di pip in pochi, semplici comandi; in generale, quindi, il tool ci fornisce un'interfaccia utente molto pi\u00f9 snella, ed inoltre si occupa autonomamente di selezionare le ultime versioni disponibili per i package che utilizziamo. Per utillizzare pipenv , dovremo per prima cosa installarlo globalmente sulla nostra macchina mediante pip : pip install pipenv Una volta installato, andiamo nella cartella dove vogliamo creare il nostro progetto, che ricordiamo includer\u00e0 soltanto la libreria NumPy, e scriviamo: pipenv install numpy Vedremo che, al termine della procedura, saranno stati generati due file: il primo, chiamato Pipfile , avr\u00e0 al suo interno tutte le dipendenze che abbiamo aggiunto al nostro progetto, mentre il secondo, Pipfile.lock , conterr\u00e0 delle informazioni dettagliate sulle librerie usate, incluse versioni, repository, e via discorrendo. Tuttavia, pipenv non si limita a creare questi due file, ma provvede anche a definire, in maniera automatica, un nuovo ambiente virtuale, all'interno del quale saranno (ovviamente) memorizzate tutte le librerie installate per il nostro progetto. Per accedere all'ambiente virtuale, dovremo usare il comando pipenv shell , mentre per eseguire un comando senza accedere all'ambiente virtuale dovremo usare il comando pipenv run seguito dal comando che vogliamo eseguire. Ad esempio, se volessimo lanciare un ipotetico script run.py accedendo all'ambiente virtuale, dovremmo scrivere: pipenv shell python run.py Se non volessimo accedere all'ambiente virtuale, invece, dovremmo scrivere: pipenv run python run.py","title":"B - Le librerie in Python"},{"location":"material/appendix/02_libraries/lecture/#appendice-b-installazione-di-una-libreria-python","text":"Per installare una libreria Python abbiamo a disposizione diverse opzioni. Vediamole nel dettaglio, immaginando di voler installare la libreria NumPy.","title":"Appendice B: Installazione di una libreria Python"},{"location":"material/appendix/02_libraries/lecture/#opzione-a-utilizzare-pip","text":"La prima opzione, e probabilmente quella maggiormente utilizzata, \u00e8 utilizzare il package manager (ovvero, il gestore di pacchetti) integrato in Python, chiamato pip . Per farlo, apriamo un terminale assicurandoci di avere i diritti di amministratore; in Linux, dovremo usare l'istruzione sudo , a meno che non siamo utenti rott, mentre in Windows ci baster\u00e0 aprire la shell come amministratori. Una volta aperto il terminale, dovremo scrivere: pip install numpy Installare una libreria in questo modo \u00e8 sicuramente molto semplice, ma porta con s\u00e8 uno svantaggio: infatti, l'installazione della stessa avviene globalmente , ovvero risulta essere valida per l'intera macchina. Ci\u00f2 potrebbe non sembrare rilevante; tuttavia, in ben determinate situazioni, si pu\u00f2 rendere necessario installare particolari combinazioni di versioni di librerie, per usufruire di funzionalit\u00e0 successivamente deprecate o, al contrario, non presenti in versioni antecedenti. In tal senso, se installiamo una certa libreria globalmente, tutti i nostri programmi dovranno necessariamente utilizzare quella libreria in quella specifica versione, il che ci pu\u00f2 vincolare fortemente a lungo andare.","title":"Opzione A: utilizzare pip"},{"location":"material/appendix/02_libraries/lecture/#opzione-b-utilizzare-pip-ed-un-ambiente-virtuale","text":"Un'altra opzione \u00e8 quella di utilizzare pip in un opportuno ambiente virtuale . Quest'ultimo altro non \u00e8 se non un ambiente \"separato\" all'interno del nostro calcolatore, nel quale andremo ad inserire tutte le librerie che utilizzeremo per i progetti da inserire all'interno dell'ambiente (con le versioni specifiche). Per utilizzare questa opzione, dovremo innanzitutto creare un ambiente virtuale. Per farlo, dobbiamo usare un'opportuna libreria Python, che dovremo installare globalmente mediante pip . Nota L'installazione globale delle librerie per la gestione dell'ambiente virtuale \u00e8 strettamente necessaria, e non contraddice il principio descritto nelle righe precedenti: infatti, l'idea \u00e8 che si possa creare un ambiente virtuale in qualsiasi momento . Installiamo quindi la libreria virtualenvwrapper , o l'equivalente porting per Windows virtualenvwrapper-win : ===\"Linux\" pip install virtualenvwrapper ===\"Windows\" pip install virtualenvwrapper-win Una volta completata l'installazione, utilizzeremo il comando mkvirtualenv , seguito da un nome a nostra scelta, per creare l'ambiente virtuale. Ad esempio: mkvirtualenv pcs Noteremo che, a sinistra del terminale, sar\u00e0 apparsa la scritta (pcs) : ( pcs ) current_working_directory/ Questo ci indica che siamo all'interno del nostro ambiente virtuale. Procediamo adesso all'installazione della libreria NumPy mediante pip : ( pcs ) current_working_directory/ pip install numpy In questo modo, avremo installato NumPy esclusivamente all'interno del nostro ambiente virtuale. Per verificarlo, basta eseguire l'istruzione pip freeze , che restituisce tutte le librerie presenti nell'ambiente in cui siamo attualmente, assieme alle loro versioni. Il file requirements.txt Pratica comune \u00e8 quella di memorizzare tutte le librerie presenti in un ambiente virtuale in un file chiamato requirements.txt . Cos\u00ec facendo, un altro programmatore sar\u00e0 in grado di \"clonare\" il nostro ambiente virtuale. Per salvare il file requirements.txt , dovremo usare i seguenti comandi: pip freeze > requirements.txt Per creare un ambiente virtuale come descritto dal file dei requisiti, invece, dovremo eseguire: pip install -r requirements.txt dove il flag -r sta per recursively , ed indica a pip di installare in maniera ricorsiva le librerie indicate nel file requirements.txt .","title":"Opzione B: utilizzare pip ed un ambiente virtuale"},{"location":"material/appendix/02_libraries/lecture/#opzione-c-utilizzare-una-distribuzione-di-python-per-il-calcolo-scientifico","text":"La terza opzione \u00e8 quella di utilizzare una distribuzione di Python specificamente pensata per il calcolo scientifico, come Anaconda . In questo caso, baster\u00e0 scaricare l'installer dal sito ufficiale e seguire la normale procedura di installazione. Il vantaggio di utilizzare una distribuzione di questo tipo sta nel fatto che avremo a disposizione di default la maggior parte delle librerie utilizzate nel calcolo scientifico. Tuttavia, occorre tenere in considerazione il fatto che la libreria \u00e8 specificamente pensata soltanto per scopi scientifici, per cui dovremo considerarlo qualora intendessimo utilizzare Python per progetti di altro tipo. Il package manager di Anaconda Nel caso si decida di optare per l'uso di Anaconda, \u00e8 importante ricordare che questa distribuzione ha un suo package manager, chiamato conda . Questo andr\u00e0 a sostituire pip nell'installazione delle librerie non presenti nella distribuzione.","title":"Opzione C: utilizzare una distribuzione di Python per il calcolo scientifico"},{"location":"material/appendix/02_libraries/lecture/#opzione-d-utilizzare-un-package-manager-come-pipenv","text":"L'ultima opzione, che \u00e8 anche quella suggerita in caso di utilizzo professionale ed eterogeneo di Python, \u00e8 quella di affidarsi ad un package manager evoluto, come pipenv . Questo package manager, infatti, automatizza e semplifica la creazione di un ambiente virtuale, combinando la stessa con l'utilizzo di pip in pochi, semplici comandi; in generale, quindi, il tool ci fornisce un'interfaccia utente molto pi\u00f9 snella, ed inoltre si occupa autonomamente di selezionare le ultime versioni disponibili per i package che utilizziamo. Per utillizzare pipenv , dovremo per prima cosa installarlo globalmente sulla nostra macchina mediante pip : pip install pipenv Una volta installato, andiamo nella cartella dove vogliamo creare il nostro progetto, che ricordiamo includer\u00e0 soltanto la libreria NumPy, e scriviamo: pipenv install numpy Vedremo che, al termine della procedura, saranno stati generati due file: il primo, chiamato Pipfile , avr\u00e0 al suo interno tutte le dipendenze che abbiamo aggiunto al nostro progetto, mentre il secondo, Pipfile.lock , conterr\u00e0 delle informazioni dettagliate sulle librerie usate, incluse versioni, repository, e via discorrendo. Tuttavia, pipenv non si limita a creare questi due file, ma provvede anche a definire, in maniera automatica, un nuovo ambiente virtuale, all'interno del quale saranno (ovviamente) memorizzate tutte le librerie installate per il nostro progetto. Per accedere all'ambiente virtuale, dovremo usare il comando pipenv shell , mentre per eseguire un comando senza accedere all'ambiente virtuale dovremo usare il comando pipenv run seguito dal comando che vogliamo eseguire. Ad esempio, se volessimo lanciare un ipotetico script run.py accedendo all'ambiente virtuale, dovremmo scrivere: pipenv shell python run.py Se non volessimo accedere all'ambiente virtuale, invece, dovremmo scrivere: pipenv run python run.py","title":"Opzione D: utilizzare un package manager come pipenv"},{"location":"material/appendix/03_scope/lecture/","text":"Appendice C - Ambito di una variabile \u00b6 All'interno di un programma ogni variabile ha una sorta di \"ciclo di vita\", che ne prevede la creazione, utilizzo e, infine, distruzione. L'intero script ha un ambito definito come globale : ci\u00f2 significa che tutte le variabili specificate nel corpo \"principale\" dello script hanno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito locale , creato alla chiamata della funzione, e distrutto al termine della stessa. Facciamo un esempio. Definiamo una funzione calcolo_voto_accesso_laurea che accetta in ingresso un argomento, ovvero la lista con i voti degli esami. def calcolo_voto_accesso_laurea ( voti_esami ): somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso Proviamo a chiamarla. lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) A schermo vedremo: Il voto di accesso \u00e8 : 86.16666666666666 C1 - Prima modifica \u00b6 Facciamo una prima modifica: lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] def calcolo_voto_accesso_laurea ( voti_esami ): print ( f 'La lista dei voti \u00e8: { lista_voti } ' ) somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) Adesso vedremo a schermo due valori: La lista dei voti \u00e8 : [ 18 , 20 , 19 , 30 , 24 , 30 ] Il voto di accesso \u00e8 : 86.16666666666666 C2 - Seconda modifica \u00b6 Proviamo a modificare ancora il codice: lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] def calcolo_voto_accesso_laurea ( voti_esami ): somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso print ( 'Il voto medio \u00e8: ' , voto_medio ) print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) Adesso vedremo a schermo il seguente risultato: Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'voto_medio' is not defined Il voto di accesso \u00e8 : 86.16666666666666 Cosa \u00e8 successo? Andiamo un attimo a ritroso, e partiamo dalla prima modifica. In questo caso, infatti, abbiamo provato ad accedere alla variabile globale lista_voti , definita nel corpo \"principale\" dello script, dall'interno della funzione calcola_voto_accesso_laurea . Ci\u00f2 \u00e8 evidentemente possibile, in quanto possiamo accedere ad una variabile globale da un ambito locale. Il contrario, tuttavia, non \u00e8 possibile: infatti, nella seconda modifica, proviamo ad accedere ad una variabile locale alla funzione calcola_voto_accesso_laurea dall'esterno della funzione stessa. Questo non pu\u00f2 avvenire, perch\u00e9 le variabili locali \"scompaiono\" al termine della funzione in cui sono definite, per cui l'interprete ci dar\u00e0 un errore.","title":"C - Ambito di una variabile"},{"location":"material/appendix/03_scope/lecture/#appendice-c-ambito-di-una-variabile","text":"All'interno di un programma ogni variabile ha una sorta di \"ciclo di vita\", che ne prevede la creazione, utilizzo e, infine, distruzione. L'intero script ha un ambito definito come globale : ci\u00f2 significa che tutte le variabili specificate nel corpo \"principale\" dello script hanno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito locale , creato alla chiamata della funzione, e distrutto al termine della stessa. Facciamo un esempio. Definiamo una funzione calcolo_voto_accesso_laurea che accetta in ingresso un argomento, ovvero la lista con i voti degli esami. def calcolo_voto_accesso_laurea ( voti_esami ): somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso Proviamo a chiamarla. lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) A schermo vedremo: Il voto di accesso \u00e8 : 86.16666666666666","title":"Appendice C - Ambito di una variabile"},{"location":"material/appendix/03_scope/lecture/#c1-prima-modifica","text":"Facciamo una prima modifica: lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] def calcolo_voto_accesso_laurea ( voti_esami ): print ( f 'La lista dei voti \u00e8: { lista_voti } ' ) somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) Adesso vedremo a schermo due valori: La lista dei voti \u00e8 : [ 18 , 20 , 19 , 30 , 24 , 30 ] Il voto di accesso \u00e8 : 86.16666666666666","title":"C1 - Prima modifica"},{"location":"material/appendix/03_scope/lecture/#c2-seconda-modifica","text":"Proviamo a modificare ancora il codice: lista_voti = [ 18 , 20 , 19 , 30 , 24 , 30 ] def calcolo_voto_accesso_laurea ( voti_esami ): somma_voti = 0 for voto in voti_esami : somma_voti += voto voto_medio = somma_voti / len ( voti_esami ) voto_accesso = voto_medio / 3 * 11 return voto_accesso print ( 'Il voto medio \u00e8: ' , voto_medio ) print ( 'Il voto di accesso \u00e8: ' , calcolo_voto_accesso_laurea ( lista_voti )) Adesso vedremo a schermo il seguente risultato: Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'voto_medio' is not defined Il voto di accesso \u00e8 : 86.16666666666666 Cosa \u00e8 successo? Andiamo un attimo a ritroso, e partiamo dalla prima modifica. In questo caso, infatti, abbiamo provato ad accedere alla variabile globale lista_voti , definita nel corpo \"principale\" dello script, dall'interno della funzione calcola_voto_accesso_laurea . Ci\u00f2 \u00e8 evidentemente possibile, in quanto possiamo accedere ad una variabile globale da un ambito locale. Il contrario, tuttavia, non \u00e8 possibile: infatti, nella seconda modifica, proviamo ad accedere ad una variabile locale alla funzione calcola_voto_accesso_laurea dall'esterno della funzione stessa. Questo non pu\u00f2 avvenire, perch\u00e9 le variabili locali \"scompaiono\" al termine della funzione in cui sono definite, per cui l'interprete ci dar\u00e0 un errore.","title":"C2 - Seconda modifica"},{"location":"material/appendix/04_oop/lecture/","text":"Appendice D - Principi di Programmazione Orientata agli Oggetti \u00b6","title":"D - Programmazione orientata agli oggetti"},{"location":"material/appendix/04_oop/lecture/#appendice-d-principi-di-programmazione-orientata-agli-oggetti","text":"","title":"Appendice D - Principi di Programmazione Orientata agli Oggetti"},{"location":"material/appendix/05_tips/lecture/","text":"Appendice A - Python \u00b6 Tabella degli operatori booleani \u00b6 Operatore Operazione logica Esempio Risultato and AND 1 and 2 True or OR True or False True not NOT True is not False True Gestione delle Eccezioni \u00b6 I decorator \u00b6 Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione. Funzioni come oggetti \u00b6 Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester Funzioni come argomenti di altre funzioni \u00b6 Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series . Definizione ed uso di decorator \u00b6 La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it !","title":"E - Tips"},{"location":"material/appendix/05_tips/lecture/#appendice-a-python","text":"","title":"Appendice A - Python"},{"location":"material/appendix/05_tips/lecture/#tabella-degli-operatori-booleani","text":"Operatore Operazione logica Esempio Risultato and AND 1 and 2 True or OR True or False True not NOT True is not False True","title":"Tabella degli operatori booleani"},{"location":"material/appendix/05_tips/lecture/#gestione-delle-eccezioni","text":"","title":"Gestione delle Eccezioni"},{"location":"material/appendix/05_tips/lecture/#i-decorator","text":"Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione.","title":"I decorator"},{"location":"material/appendix/05_tips/lecture/#funzioni-come-oggetti","text":"Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester","title":"Funzioni come oggetti"},{"location":"material/appendix/05_tips/lecture/#funzioni-come-argomenti-di-altre-funzioni","text":"Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series .","title":"Funzioni come argomenti di altre funzioni"},{"location":"material/appendix/05_tips/lecture/#definizione-ed-uso-di-decorator","text":"La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it !","title":"Definizione ed uso di decorator"},{"location":"material/slides/","text":"Slide proiettate a lezione \u00b6 Argomento Slides 00 - Programma del corso 01 - Introduzione a Python","title":"Slides proiettate a lezione"},{"location":"material/slides/#slide-proiettate-a-lezione","text":"Argomento Slides 00 - Programma del corso 01 - Introduzione a Python","title":"Slide proiettate a lezione"},{"location":"notebooks/","text":"Indice dei notebook \u00b6 Lezioni \u00b6 Notebook Link Lezione 10 Lezione 11 Lezione 12 Lezione 13 Lezione 14 Lezione 15 Lezione 19 Lezione 20 Esercizi \u00b6 Notebook Link Esercizi lezione 09 Esercizi lezione 10 Esercizi lezione 12 Esercizi lezione 14 - a Esercizi lezione 14 - b Esercizi lezione 14 - c Esercizi lezione 16 Esercizi lezione 18 - a Esercizi lezione 18 - b Esercizi lezione 21","title":"Notebook"},{"location":"notebooks/#indice-dei-notebook","text":"","title":"Indice dei notebook"},{"location":"notebooks/#lezioni","text":"Notebook Link Lezione 10 Lezione 11 Lezione 12 Lezione 13 Lezione 14 Lezione 15 Lezione 19 Lezione 20","title":"Lezioni"},{"location":"notebooks/#esercizi","text":"Notebook Link Esercizi lezione 09 Esercizi lezione 10 Esercizi lezione 12 Esercizi lezione 14 - a Esercizi lezione 14 - b Esercizi lezione 14 - c Esercizi lezione 16 Esercizi lezione 18 - a Esercizi lezione 18 - b Esercizi lezione 21","title":"Esercizi"}]}