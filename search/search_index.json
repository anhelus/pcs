{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python per il Calcolo Scientifico \u00b6 Angelo Cardellicchio","title":"Home"},{"location":"#python-per-il-calcolo-scientifico","text":"Angelo Cardellicchio","title":"Python per il Calcolo Scientifico"},{"location":"01_numpy/01_intro/","text":"Introduzione a NumPy \u00b6 La libreria NumPy (abbreviazione che sta per Num*erical *Py*thon) \u00e8 quella maggiormente usata nel campo del calcolo scientifico in Python, e ne rappresenta uno standard *de facto , in quanto le API messe a disposizione da NumPy sono estensivamente utilizzate dalla quasi totalit\u00e0 degli altri package dedicati alle scienze ed all'ingegneria. Gli ndarray \u00b6 La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy offre una struttura chiamata ndarray , rappresentante un array ad \\(n\\) dimensioni contenente dati di tipo omogeneo . E' interessante notare come anche ndarray sia un'abbreviazione, stante per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 molto simile a quella di una classica lista Python: >>> a = numpy . array ([ 1 , 2 , 3 ]) Questa sintassi, per\u00f2, non deve trarci in inganno. Esistono, infatti, varie differenze che intercorrono tra un ndarray ed una classica sequenza Python, ovvero: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array creer\u00e0 quindi un nuovo array, cancellando quello originario; gli elementi di un ndarray devono essere dello stesso tipo; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni. Efficienza di NumPy \u00b6 Il terzo punto \u00e8 particolarmente importante, sopratutto nell'ambito del calcolo scientifico. Come semplice esempio, consideriamo una moltiplicazione elemento per elemento tra due vettori della stessa dimensione. Con due liste, potremmo usare un ciclo for : c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) oppure una list comprehension : c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] In entrambi i casi, l'operazione verr\u00e0 effettuata in maniera corretta; tuttavia, se i vettori sono di dimensioni importanti, avremo un costo da pagare legato all'inefficienza di Python nella gestione dei cicli. Ovviamente, dato che le inefficienze sono legate al Python (e, quindi, all' overhead introdotto principalmente dall'interprete), la soluzione pi\u00f9 semplice sarebbe quella di utilizzare un altro linguaggio, come ad esempio il C. In questo caso, l'operazione precedente sarebbe associata a questo codice: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Per un caso cos\u00ec semplice, s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, l'operazione precedente pu\u00f2 essere riassunta in NumPy come segue: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, sia rispetto al C, sia rispetto al caso in cui si usino delle liste in Python. Inoltre, \u00e8 la stessa sintassi che viene solitamente usata nelle formule reali! Oltre a questo, NumPy sfrutta codice precompilato in C: questo significa che la precedente operazione sar\u00e0 svolta quasi alla stessa velocit\u00e0 del codice scritto in linguaggio C. Si tratta, quindi, di unire il \"meglio\" dei due mondi: da un lato, l'eleganza e semplicit\u00e0 sintattica del Python e, dall'altro, l'efficienza del C. Vettorizzazione e broadcasting \u00b6 Due importanti concetti sfruttati da NumPy sono quelli di vettorizzazione e broadcasting . La vettorizzazione ci permette di scrivere codice senza cicli o indici espliciti; ovviamente, i cicli ci sono , ma avvengono sotto al cofano , grazie al codice C precompilato. Il codice vettorizzato, inoltre, presenta diversi vantaggi, soprattutto in termini di leggibilit\u00e0 e manutenibilit\u00e0. Il concetto di broadcasting riguarda invece il comportamento implicito delle operazioni, e permette di usare la stessa sintassi indipendentemente dalle dimensioni degli ndarray coinvolti (e dall'operazione effettuata, sia essa algebrica, logica, etc.).","title":"Introduzione"},{"location":"01_numpy/01_intro/#introduzione-a-numpy","text":"La libreria NumPy (abbreviazione che sta per Num*erical *Py*thon) \u00e8 quella maggiormente usata nel campo del calcolo scientifico in Python, e ne rappresenta uno standard *de facto , in quanto le API messe a disposizione da NumPy sono estensivamente utilizzate dalla quasi totalit\u00e0 degli altri package dedicati alle scienze ed all'ingegneria.","title":"Introduzione a NumPy"},{"location":"01_numpy/01_intro/#gli-ndarray","text":"La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy offre una struttura chiamata ndarray , rappresentante un array ad \\(n\\) dimensioni contenente dati di tipo omogeneo . E' interessante notare come anche ndarray sia un'abbreviazione, stante per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 molto simile a quella di una classica lista Python: >>> a = numpy . array ([ 1 , 2 , 3 ]) Questa sintassi, per\u00f2, non deve trarci in inganno. Esistono, infatti, varie differenze che intercorrono tra un ndarray ed una classica sequenza Python, ovvero: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array creer\u00e0 quindi un nuovo array, cancellando quello originario; gli elementi di un ndarray devono essere dello stesso tipo; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni.","title":"Gli ndarray"},{"location":"01_numpy/01_intro/#efficienza-di-numpy","text":"Il terzo punto \u00e8 particolarmente importante, sopratutto nell'ambito del calcolo scientifico. Come semplice esempio, consideriamo una moltiplicazione elemento per elemento tra due vettori della stessa dimensione. Con due liste, potremmo usare un ciclo for : c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) oppure una list comprehension : c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] In entrambi i casi, l'operazione verr\u00e0 effettuata in maniera corretta; tuttavia, se i vettori sono di dimensioni importanti, avremo un costo da pagare legato all'inefficienza di Python nella gestione dei cicli. Ovviamente, dato che le inefficienze sono legate al Python (e, quindi, all' overhead introdotto principalmente dall'interprete), la soluzione pi\u00f9 semplice sarebbe quella di utilizzare un altro linguaggio, come ad esempio il C. In questo caso, l'operazione precedente sarebbe associata a questo codice: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Per un caso cos\u00ec semplice, s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, l'operazione precedente pu\u00f2 essere riassunta in NumPy come segue: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, sia rispetto al C, sia rispetto al caso in cui si usino delle liste in Python. Inoltre, \u00e8 la stessa sintassi che viene solitamente usata nelle formule reali! Oltre a questo, NumPy sfrutta codice precompilato in C: questo significa che la precedente operazione sar\u00e0 svolta quasi alla stessa velocit\u00e0 del codice scritto in linguaggio C. Si tratta, quindi, di unire il \"meglio\" dei due mondi: da un lato, l'eleganza e semplicit\u00e0 sintattica del Python e, dall'altro, l'efficienza del C.","title":"Efficienza di NumPy"},{"location":"01_numpy/01_intro/#vettorizzazione-e-broadcasting","text":"Due importanti concetti sfruttati da NumPy sono quelli di vettorizzazione e broadcasting . La vettorizzazione ci permette di scrivere codice senza cicli o indici espliciti; ovviamente, i cicli ci sono , ma avvengono sotto al cofano , grazie al codice C precompilato. Il codice vettorizzato, inoltre, presenta diversi vantaggi, soprattutto in termini di leggibilit\u00e0 e manutenibilit\u00e0. Il concetto di broadcasting riguarda invece il comportamento implicito delle operazioni, e permette di usare la stessa sintassi indipendentemente dalle dimensioni degli ndarray coinvolti (e dall'operazione effettuata, sia essa algebrica, logica, etc.).","title":"Vettorizzazione e broadcasting"},{"location":"01_numpy/02_installazione/","text":"Installazione di NumPy \u00b6 Per installare NumPy, possiamo usare una specifica distribuzione scientifica di Python (come, ad esempio, Anaconda). In realt\u00e0, per\u00f2, useremo un'installazione standard. Installiamo Python mediante il seguente comando: pip install numpy Importare NumPy \u00b6 Ogni volta che vogliamo usare un package o una libreria nel nostor codice, dobbiamo per prima cosa renderla accessibile. Per iniziare ad usare NumPy e tutte le funzioni disponibili in NumPy, dovremo importarle. Questo pu\u00f2 essere fatto facilmente con questa istruzione di import: import numpy as np Nota Questa soluzione \u00e8 di solito preferita perch\u00e9 ci permette di risparmiare tempo e mantenere anche il codice standardizzato.","title":"Installazione di NumPy"},{"location":"01_numpy/02_installazione/#installazione-di-numpy","text":"Per installare NumPy, possiamo usare una specifica distribuzione scientifica di Python (come, ad esempio, Anaconda). In realt\u00e0, per\u00f2, useremo un'installazione standard. Installiamo Python mediante il seguente comando: pip install numpy","title":"Installazione di NumPy"},{"location":"01_numpy/02_installazione/#importare-numpy","text":"Ogni volta che vogliamo usare un package o una libreria nel nostor codice, dobbiamo per prima cosa renderla accessibile. Per iniziare ad usare NumPy e tutte le funzioni disponibili in NumPy, dovremo importarle. Questo pu\u00f2 essere fatto facilmente con questa istruzione di import: import numpy as np Nota Questa soluzione \u00e8 di solito preferita perch\u00e9 ci permette di risparmiare tempo e mantenere anche il codice standardizzato.","title":"Importare NumPy"},{"location":"01_numpy/03_array/01_intro/","text":"Introduzione agli array \u00b6 Qual \u00e8 la differenza tra una lista Python ed un array NumPy? \u00b6 NumPy ci d\u00e0 un enorme range di modi veloci ed efficienti per creare degli array e manipolare dei dati numerici al lroo interno. Mentre una lista python pu\u00f2 contenere diversi tipi di dati al suo interno, tutti gli elementi in un array NumPy devono essere omogenei. Le operazioni matematiche che devono essere effettuate sugli array sarebbero state infatti estremamente inefficaci se gli array non fossero stati omogenei. Perch\u00e9* usare NumPy? \u00b6 Gli array numpy sono pi\u00f9 veloci e compatti rispetto alle liste Python. Un array consuma meno memoria, ed \u00e8 pi\u00f9 conveniente da utilizzare. NumPy uisa molta meno memoria per memorizzare i dati e fornisce un meccanismo per specificare i tipi d dati. Qusto permette una ulteriore ottimizzzazione del codice. Cosa \u00e8 un array? \u00b6 Un array \u00e8 la struttura dati centrale della libreria NumPy. E' considerato come una griglia di valori, e contiene informazioni circa gli elementi grezzi (raw), su come localizzare ciascun elemento, e come interpretarlo. Ha inotlre una griglia di elementi che pu\u00f2 essere indicizzata in diversi modi. Gli elementi son tutto dello stesso tipo, indicato con dtype . Un array pu\u00f2 essere idnicizzato da una tupla di interi non negativi, booleani, o da un altro array, o da interi. Il rank dell'array \u00e8 il numeor di dimensioni. La forma dell'array \u00e8 una tupla di interi che da la dimensione dell'arry su ogni dimensione. Un modo in cui si possono inziializzare gli array NumPy \u00e8 dalle liste Python, usanod liste annidate per dati con due o pi\u00f9 dimensioni. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) o >>> a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]]) Possiamo accedere agli elementi nell'array usando le parentesi quadre. Quando si accede agli elementi, dobbiamo ricordarci che l'indicizzazione in NumPy inizia a 0. QUesto significa che se vogliamo accedere il primo elemento nell'array, staremo accedendo all'elemento 0. >>> print ( a [ 0 ]) [ 1 2 3 4 ] Pi\u00f9 informaizoni sugli array \u00b6 Possiamo occasionalmente sentire un riferimento ad un array come ad un ndarray , che \u00e8 una abbreviazione per N-dimensional array (array ad n dimensioni). Un array ad n dimensioni \u00e8 semplicemente un array con un numero generico di dimensioni. Possiaom sentire infatti 1-D, o array monodimensionaloi, o 2-D, array multidimenzionali, e via dicendo. La classe NumPy ndarray viene suata per rappresentare sia matrici sia vettori. Un vettore \u00e8 un array con una singola dimensione (non vi \u00e8 differenza tra i vettori riga ed i vettori colonna), mentre una matrice si riferisce ad un array con due dimensioni. Per array tridimensionali o con un maggior numero di dimensioni, si usa comunemente il termine tensore. QUali sono gli attributi di un array? \u00b6 Una rray \u00e8 normalmente un contenitore a dimensione fissata di oggetti dello stesso tipo e dimensione. Il numero di dimensioni ed oggetti in un array \u00e8 definito dalla sua forma. La forma di un array \u00e8 una tupla di interi non negativi che specifica le dimensioni lungo ogni asse. In numpy, gli assi sono indicati con axes. Questo indica che se abbiamo un array bidimensionale del tipo: [[0.,0.,0.], [1.,1., 1.]] il nsotro array avr\u00e0 due assi. Il primo asse ha una lunghezza di 2, mentre il secondo una lunghezza di 3. https://numpy.org/doc/stable/user/absolute_beginners.html","title":"Introduzione agli array"},{"location":"01_numpy/03_array/01_intro/#introduzione-agli-array","text":"","title":"Introduzione agli array"},{"location":"01_numpy/03_array/01_intro/#qual-e-la-differenza-tra-una-lista-python-ed-un-array-numpy","text":"NumPy ci d\u00e0 un enorme range di modi veloci ed efficienti per creare degli array e manipolare dei dati numerici al lroo interno. Mentre una lista python pu\u00f2 contenere diversi tipi di dati al suo interno, tutti gli elementi in un array NumPy devono essere omogenei. Le operazioni matematiche che devono essere effettuate sugli array sarebbero state infatti estremamente inefficaci se gli array non fossero stati omogenei.","title":"Qual \u00e8 la differenza tra una lista Python ed un array NumPy?"},{"location":"01_numpy/03_array/01_intro/#perche-usare-numpy","text":"Gli array numpy sono pi\u00f9 veloci e compatti rispetto alle liste Python. Un array consuma meno memoria, ed \u00e8 pi\u00f9 conveniente da utilizzare. NumPy uisa molta meno memoria per memorizzare i dati e fornisce un meccanismo per specificare i tipi d dati. Qusto permette una ulteriore ottimizzzazione del codice.","title":"Perch\u00e9* usare NumPy?"},{"location":"01_numpy/03_array/01_intro/#cosa-e-un-array","text":"Un array \u00e8 la struttura dati centrale della libreria NumPy. E' considerato come una griglia di valori, e contiene informazioni circa gli elementi grezzi (raw), su come localizzare ciascun elemento, e come interpretarlo. Ha inotlre una griglia di elementi che pu\u00f2 essere indicizzata in diversi modi. Gli elementi son tutto dello stesso tipo, indicato con dtype . Un array pu\u00f2 essere idnicizzato da una tupla di interi non negativi, booleani, o da un altro array, o da interi. Il rank dell'array \u00e8 il numeor di dimensioni. La forma dell'array \u00e8 una tupla di interi che da la dimensione dell'arry su ogni dimensione. Un modo in cui si possono inziializzare gli array NumPy \u00e8 dalle liste Python, usanod liste annidate per dati con due o pi\u00f9 dimensioni. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) o >>> a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]]) Possiamo accedere agli elementi nell'array usando le parentesi quadre. Quando si accede agli elementi, dobbiamo ricordarci che l'indicizzazione in NumPy inizia a 0. QUesto significa che se vogliamo accedere il primo elemento nell'array, staremo accedendo all'elemento 0. >>> print ( a [ 0 ]) [ 1 2 3 4 ]","title":"Cosa \u00e8 un array?"},{"location":"01_numpy/03_array/01_intro/#piu-informaizoni-sugli-array","text":"Possiamo occasionalmente sentire un riferimento ad un array come ad un ndarray , che \u00e8 una abbreviazione per N-dimensional array (array ad n dimensioni). Un array ad n dimensioni \u00e8 semplicemente un array con un numero generico di dimensioni. Possiaom sentire infatti 1-D, o array monodimensionaloi, o 2-D, array multidimenzionali, e via dicendo. La classe NumPy ndarray viene suata per rappresentare sia matrici sia vettori. Un vettore \u00e8 un array con una singola dimensione (non vi \u00e8 differenza tra i vettori riga ed i vettori colonna), mentre una matrice si riferisce ad un array con due dimensioni. Per array tridimensionali o con un maggior numero di dimensioni, si usa comunemente il termine tensore.","title":"Pi\u00f9 informaizoni sugli array"},{"location":"01_numpy/03_array/01_intro/#quali-sono-gli-attributi-di-un-array","text":"Una rray \u00e8 normalmente un contenitore a dimensione fissata di oggetti dello stesso tipo e dimensione. Il numero di dimensioni ed oggetti in un array \u00e8 definito dalla sua forma. La forma di un array \u00e8 una tupla di interi non negativi che specifica le dimensioni lungo ogni asse. In numpy, gli assi sono indicati con axes. Questo indica che se abbiamo un array bidimensionale del tipo: [[0.,0.,0.], [1.,1., 1.]] il nsotro array avr\u00e0 due assi. Il primo asse ha una lunghezza di 2, mentre il secondo una lunghezza di 3. https://numpy.org/doc/stable/user/absolute_beginners.html","title":"QUali sono gli attributi di un array?"}]}