{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python per il Calcolo Scientifico \u00b6 Angelo Cardellicchio","title":"Home"},{"location":"#python-per-il-calcolo-scientifico","text":"Angelo Cardellicchio","title":"Python per il Calcolo Scientifico"},{"location":"01_python/01_intro/","text":"Introduzione a Python \u00b6 Premessa: Python e tipizzazione \u00b6 Tipizzazione dinamica \u00b6 Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing . Duck Typing \u00b6 Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta. L'interprete Python \u00b6 Python offre un interprete accessibile al programmatore direttamente dalla riga di comando. Dopo averlo installato (\u00e8 possibile farlo seguendo le istruzioni presenti sul sito ufficiale ) ed essersi assicurati che il launcher sia stato aggiunto al path di sistema, possiamo lanciarlo tramite riga di comando. Per prima cosa, comunque, assicuriamoci che sia tutto a posto controllando la versione installata di Python: $ python --version python3.9.1 A questo punto, lanciamo l'interprete: python Possiamo quindi iniziare ad usare Python. Calcoli e numeri \u00b6 Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2 Divisioni \u00b6 Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi. Elevazione a potenza \u00b6 Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria. Stringhe \u00b6 In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella Stringhe su righe multiple \u00b6 Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2. Concatenazione di stringhe \u00b6 Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore. Indicizzazione di stringhe \u00b6 Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n' Slicing su stringhe \u00b6 L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j ] dove i \u00e8 l'indice iniziale, e j quello finale. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python' Lunghezza di una stringa \u00b6 La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6 Immutabilit\u00e0 di una stringa \u00b6 Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile. Liste \u00b6 Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] Concatenazione, indicizzazione e slicing su liste \u00b6 Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] Mutabilit\u00e0 di una lista \u00b6 A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ] Operazioni sulle liste \u00b6 Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Conclusioni \u00b6 Abbiamo dato una rapida introduzione al linguaggio Python, soffermandoci su alcune dei tipi di dati pi\u00f9 usati, come numeri, stringhe e liste. Nelle prossime sezioni, torneremo sulle liste, ed approfondiremo altri tipi di iterabili, come tuple e dizionari.","title":"01 - Introduzione"},{"location":"01_python/01_intro/#introduzione-a-python","text":"","title":"Introduzione a Python"},{"location":"01_python/01_intro/#premessa-python-e-tipizzazione","text":"","title":"Premessa: Python e tipizzazione"},{"location":"01_python/01_intro/#tipizzazione-dinamica","text":"Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing .","title":"Tipizzazione dinamica"},{"location":"01_python/01_intro/#duck-typing","text":"Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta.","title":"Duck Typing"},{"location":"01_python/01_intro/#linterprete-python","text":"Python offre un interprete accessibile al programmatore direttamente dalla riga di comando. Dopo averlo installato (\u00e8 possibile farlo seguendo le istruzioni presenti sul sito ufficiale ) ed essersi assicurati che il launcher sia stato aggiunto al path di sistema, possiamo lanciarlo tramite riga di comando. Per prima cosa, comunque, assicuriamoci che sia tutto a posto controllando la versione installata di Python: $ python --version python3.9.1 A questo punto, lanciamo l'interprete: python Possiamo quindi iniziare ad usare Python.","title":"L'interprete Python"},{"location":"01_python/01_intro/#calcoli-e-numeri","text":"Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2","title":"Calcoli e numeri"},{"location":"01_python/01_intro/#divisioni","text":"Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi.","title":"Divisioni"},{"location":"01_python/01_intro/#elevazione-a-potenza","text":"Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria.","title":"Elevazione a potenza"},{"location":"01_python/01_intro/#stringhe","text":"In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella","title":"Stringhe"},{"location":"01_python/01_intro/#stringhe-su-righe-multiple","text":"Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2.","title":"Stringhe su righe multiple"},{"location":"01_python/01_intro/#concatenazione-di-stringhe","text":"Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore.","title":"Concatenazione di stringhe"},{"location":"01_python/01_intro/#indicizzazione-di-stringhe","text":"Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n'","title":"Indicizzazione di stringhe"},{"location":"01_python/01_intro/#slicing-su-stringhe","text":"L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j ] dove i \u00e8 l'indice iniziale, e j quello finale. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python'","title":"Slicing su stringhe"},{"location":"01_python/01_intro/#lunghezza-di-una-stringa","text":"La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6","title":"Lunghezza di una stringa"},{"location":"01_python/01_intro/#immutabilita-di-una-stringa","text":"Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile.","title":"Immutabilit\u00e0 di una stringa"},{"location":"01_python/01_intro/#liste","text":"Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ]","title":"Liste"},{"location":"01_python/01_intro/#concatenazione-indicizzazione-e-slicing-su-liste","text":"Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ]","title":"Concatenazione, indicizzazione e slicing su liste"},{"location":"01_python/01_intro/#mutabilita-di-una-lista","text":"A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ]","title":"Mutabilit\u00e0 di una lista"},{"location":"01_python/01_intro/#operazioni-sulle-liste","text":"Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"Operazioni sulle liste"},{"location":"01_python/01_intro/#conclusioni","text":"Abbiamo dato una rapida introduzione al linguaggio Python, soffermandoci su alcune dei tipi di dati pi\u00f9 usati, come numeri, stringhe e liste. Nelle prossime sezioni, torneremo sulle liste, ed approfondiremo altri tipi di iterabili, come tuple e dizionari.","title":"Conclusioni"},{"location":"01_python/02_programmare/","text":"Programmare in Python \u00b6 Note fondamentali sulla sintassi \u00b6 Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente. Le parentesi : tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse; quadre sono usate per la creazione e l'accesso agli elementi di una lista; graffe sono usate per la creazione di un dizionario. Il termine di un'istruzione viene indicato andando a capo . L'ambito del codice \u00e8 definito mediante il numero di tabulazioni . Come regola generale, il codice indentato ad un certo livello di tabulazione appartiene al medesimo ambito. Programmazione strutturata \u00b6 Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like. Istruzioni condizionali ( if ) \u00b6 Partiamo dall'istruzione condizionale if , mostrando la differenza tra l'implementazione in C/C++ e quella Python. Python a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) C/C++ #include <iostream> using namespace std ; int main () { int a = 5 ; if ( a < 5 ) { std :: cout << \"a \u00e8 minore di 5\" << std :: endl ; } else if ( a == 5 ) { std :: cout << \"a \u00e8 uguale a 5\" << std :: endl ; } else { std :: cout << \"a \u00e8 maggiore a 5\" << std :: endl ; } } In entrambi i casi l'output a schermo sar\u00e0: a \u00e8 uguale a 5 La sintassi \u00e8, in realt\u00e0, abbastanza simile, anche se si tiene conto delle regole sintattiche indicate in precedenza. Pattern matching \u00b6 Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"case 1\" : case_1 () case \"case 2\" : case () case unknown_command : print ( \"Comando sconosciuto\" ) Attenzione La versione 3.10 di Python \u00e8, al momento, ancora sperimentale. Non sar\u00e0 quindi possibile nell'arco del corso ricorrere al pattern matching! Cicli \u00b6 Ciclo for \u00b6 Un ciclo for in Python differisce leggermente da quelli classici presenti in C/C++; infatti, laddove questi ultimi sono delle una vera e propria progressioni aritmetiche, contraddistinte da un valore iniziale, un incremento ed un valore terminale, in Python un ciclo for itera su una sequenza, come una lista o una stringa. Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: Python >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) C/C++ #include <iostream> using namespace std ; int main () { for ( int i = 0 ; i < 5 ; i ++ ) { cout << i << endl ; } return 0 ; } In entrambi i casi, il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, occorre modificare tutti i \"range di iterazione\" in liste o, pi\u00f9 genericamente, iterabili . Questo sforzo per\u00f2 \u00e8 ampiamente ripagato dalla maggiore semplicit\u00e0 del codice; per fare un esempio, mostriamo come sia pi\u00f9 semplice iterare su una stringa: Python >>> string = \"Python\" >>> for char in string : ... print ( char ) C/C++ #include <iostream> #include <string> using namespace std ; int main () { string str ( \"C/C++\" ); for ( int i = 0 ; i < str . size (); i ++ ) { cout << str [ i ] << endl ; } return 0 ; } A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n Attenzione La maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti. Tuttavia, il compromesso costi/benefici propende, per i nostri scopi, nettamente a favore di Python. Ciclo while \u00b6 A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello della controparte C/C++. Anche in questo caso, ci\u00f2 che cambia \u00e8 la sintassi: Python >>> i = True >>> while ( i ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... else : ... print ( \"Esco!\" ) ... i = False C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { bool i = true ; while ( i ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; } else { cout << \"Esco!\" << endl ; i = false ; } } } A schermo vedremo: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola. La funzione range() \u00b6 Torniamo adesso al precedente ciclo for per Python, che riportiamo di seguito. >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: >>> r = range ( 0 , 5 , 1 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Iterare su tutti gli elementi di una lista \u00b6 Usando la funzione range() assieme alla funzione len() \u00e8 possibile iterare sui singoli elementi di una lista: >>> l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] >>> for i in range ( len ( l )): ... print ( l [ i ]) Pippo Pluto 5 Paperino Istruzioni break e continue \u00b6 Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: >>> while ( True ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... continue ... else : ... print ( \"Esco!\" ) ... break Definire una funzione \u00b6 In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri di default. Esempio di funzioni \u00b6 La seguente funzione concatena ad una lista il doppio dei singoli valori nella lista stessa: >>> def raddoppia_lista ( lista ): ... for i in range ( len ( lista )): ... lista . append ( l [ i ] * 2 ) ... >>> l = [ 1 , 2 ] >>> raddoppia_lista ( l ) >>> l [ 1 , 2 , 2 , 4 ] In questa funzione, invece, usiamo un parametro opzionale per specificare la lunghezza della lista generata in output: >>> def genera_lista_casuale ( lunghezza = 5 ): ... l = [] ... for i in range ( lunghezza ): ... l . append ( randint ( 0 , 10 )) ... return l ... >>> genera_lista_casuale () [ 3 , 1 , 2 , 0 , 6 ] >>> genera_lista_casuale ( 10 ) [ 7 , 9 , 1 , 10 , 2 , 4 , 9 , 1 , 4 , 8 ] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore. Passaggio di parametri a funzione \u00b6 Python prevede che i parametri siano passati ad una funzione esclusivamente per valore . Ad esempio: >>> def raddoppia ( valore ): ... valore = valore * 2 ... >>> val = 1 >>> raddoppia ( val ) >>> val 1 Come evidente, la funzione raddoppia() non ha avuto alcun effetto sulla variabile val ; ci\u00f2 avviene proprio perch\u00e9 il passaggio \u00e8 stato effettuato proprio per valore. Questo \u00e8 il motivo per cui, qualora non si voglia avere un valore di ritorno in una ben determinata funzione, \u00e8 necessario usare dei tipi mutabili (come nel caso della funzione raddoppia_lista , che accetta una lista, ovvero un tipo mutabile), oppure utilizzare le funzioni nell'ambito di una classe (torneremo su questo in avanti). L'istruzione pass \u00b6 Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, l'istruzione pass \u00e8 estremamente utile. Conclusioni \u00b6 In questa lezione, abbiamo visto alcune delle tecniche fondamentali da padroneggiare per quello che riguarda la programmazione strutturata in Python. Nella prossima lezione, ci focalizzeremo su alcune possibili applicazioni delle liste.","title":"02 - Concetti base"},{"location":"01_python/02_programmare/#programmare-in-python","text":"","title":"Programmare in Python"},{"location":"01_python/02_programmare/#note-fondamentali-sulla-sintassi","text":"Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente. Le parentesi : tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse; quadre sono usate per la creazione e l'accesso agli elementi di una lista; graffe sono usate per la creazione di un dizionario. Il termine di un'istruzione viene indicato andando a capo . L'ambito del codice \u00e8 definito mediante il numero di tabulazioni . Come regola generale, il codice indentato ad un certo livello di tabulazione appartiene al medesimo ambito.","title":"Note fondamentali sulla sintassi"},{"location":"01_python/02_programmare/#programmazione-strutturata","text":"Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like.","title":"Programmazione strutturata"},{"location":"01_python/02_programmare/#istruzioni-condizionali-if","text":"Partiamo dall'istruzione condizionale if , mostrando la differenza tra l'implementazione in C/C++ e quella Python. Python a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) C/C++ #include <iostream> using namespace std ; int main () { int a = 5 ; if ( a < 5 ) { std :: cout << \"a \u00e8 minore di 5\" << std :: endl ; } else if ( a == 5 ) { std :: cout << \"a \u00e8 uguale a 5\" << std :: endl ; } else { std :: cout << \"a \u00e8 maggiore a 5\" << std :: endl ; } } In entrambi i casi l'output a schermo sar\u00e0: a \u00e8 uguale a 5 La sintassi \u00e8, in realt\u00e0, abbastanza simile, anche se si tiene conto delle regole sintattiche indicate in precedenza.","title":"Istruzioni condizionali (if)"},{"location":"01_python/02_programmare/#pattern-matching","text":"Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"case 1\" : case_1 () case \"case 2\" : case () case unknown_command : print ( \"Comando sconosciuto\" ) Attenzione La versione 3.10 di Python \u00e8, al momento, ancora sperimentale. Non sar\u00e0 quindi possibile nell'arco del corso ricorrere al pattern matching!","title":"Pattern matching"},{"location":"01_python/02_programmare/#cicli","text":"","title":"Cicli"},{"location":"01_python/02_programmare/#ciclo-for","text":"Un ciclo for in Python differisce leggermente da quelli classici presenti in C/C++; infatti, laddove questi ultimi sono delle una vera e propria progressioni aritmetiche, contraddistinte da un valore iniziale, un incremento ed un valore terminale, in Python un ciclo for itera su una sequenza, come una lista o una stringa. Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: Python >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) C/C++ #include <iostream> using namespace std ; int main () { for ( int i = 0 ; i < 5 ; i ++ ) { cout << i << endl ; } return 0 ; } In entrambi i casi, il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, occorre modificare tutti i \"range di iterazione\" in liste o, pi\u00f9 genericamente, iterabili . Questo sforzo per\u00f2 \u00e8 ampiamente ripagato dalla maggiore semplicit\u00e0 del codice; per fare un esempio, mostriamo come sia pi\u00f9 semplice iterare su una stringa: Python >>> string = \"Python\" >>> for char in string : ... print ( char ) C/C++ #include <iostream> #include <string> using namespace std ; int main () { string str ( \"C/C++\" ); for ( int i = 0 ; i < str . size (); i ++ ) { cout << str [ i ] << endl ; } return 0 ; } A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n Attenzione La maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti. Tuttavia, il compromesso costi/benefici propende, per i nostri scopi, nettamente a favore di Python.","title":"Ciclo for"},{"location":"01_python/02_programmare/#ciclo-while","text":"A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello della controparte C/C++. Anche in questo caso, ci\u00f2 che cambia \u00e8 la sintassi: Python >>> i = True >>> while ( i ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... else : ... print ( \"Esco!\" ) ... i = False C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { bool i = true ; while ( i ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; } else { cout << \"Esco!\" << endl ; i = false ; } } } A schermo vedremo: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola.","title":"Ciclo while"},{"location":"01_python/02_programmare/#la-funzione-range","text":"Torniamo adesso al precedente ciclo for per Python, che riportiamo di seguito. >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: >>> r = range ( 0 , 5 , 1 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ]","title":"La funzione range()"},{"location":"01_python/02_programmare/#iterare-su-tutti-gli-elementi-di-una-lista","text":"Usando la funzione range() assieme alla funzione len() \u00e8 possibile iterare sui singoli elementi di una lista: >>> l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] >>> for i in range ( len ( l )): ... print ( l [ i ]) Pippo Pluto 5 Paperino","title":"Iterare su tutti gli elementi di una lista"},{"location":"01_python/02_programmare/#istruzioni-break-e-continue","text":"Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: >>> while ( True ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... continue ... else : ... print ( \"Esco!\" ) ... break","title":"Istruzioni break e continue"},{"location":"01_python/02_programmare/#definire-una-funzione","text":"In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri di default.","title":"Definire una funzione"},{"location":"01_python/02_programmare/#esempio-di-funzioni","text":"La seguente funzione concatena ad una lista il doppio dei singoli valori nella lista stessa: >>> def raddoppia_lista ( lista ): ... for i in range ( len ( lista )): ... lista . append ( l [ i ] * 2 ) ... >>> l = [ 1 , 2 ] >>> raddoppia_lista ( l ) >>> l [ 1 , 2 , 2 , 4 ] In questa funzione, invece, usiamo un parametro opzionale per specificare la lunghezza della lista generata in output: >>> def genera_lista_casuale ( lunghezza = 5 ): ... l = [] ... for i in range ( lunghezza ): ... l . append ( randint ( 0 , 10 )) ... return l ... >>> genera_lista_casuale () [ 3 , 1 , 2 , 0 , 6 ] >>> genera_lista_casuale ( 10 ) [ 7 , 9 , 1 , 10 , 2 , 4 , 9 , 1 , 4 , 8 ] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore.","title":"Esempio di funzioni"},{"location":"01_python/02_programmare/#passaggio-di-parametri-a-funzione","text":"Python prevede che i parametri siano passati ad una funzione esclusivamente per valore . Ad esempio: >>> def raddoppia ( valore ): ... valore = valore * 2 ... >>> val = 1 >>> raddoppia ( val ) >>> val 1 Come evidente, la funzione raddoppia() non ha avuto alcun effetto sulla variabile val ; ci\u00f2 avviene proprio perch\u00e9 il passaggio \u00e8 stato effettuato proprio per valore. Questo \u00e8 il motivo per cui, qualora non si voglia avere un valore di ritorno in una ben determinata funzione, \u00e8 necessario usare dei tipi mutabili (come nel caso della funzione raddoppia_lista , che accetta una lista, ovvero un tipo mutabile), oppure utilizzare le funzioni nell'ambito di una classe (torneremo su questo in avanti).","title":"Passaggio di parametri a funzione"},{"location":"01_python/02_programmare/#listruzione-pass","text":"Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, l'istruzione pass \u00e8 estremamente utile.","title":"L'istruzione pass"},{"location":"01_python/02_programmare/#conclusioni","text":"In questa lezione, abbiamo visto alcune delle tecniche fondamentali da padroneggiare per quello che riguarda la programmazione strutturata in Python. Nella prossima lezione, ci focalizzeremo su alcune possibili applicazioni delle liste.","title":"Conclusioni"},{"location":"01_python/03_strutture/","text":"Alcune applicazioni delle liste \u00b6 Liste, pile e code \u00b6 Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi. Pila \u00b6 Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. >>> s = [ 1 , 2 , 3 ] >>> s . append ( 4 ) >>> s [ 1 , 2 , 3 , 4 ] >>> e = s . pop () >>> e 4 >>> s [ 1 , 2 , 3 ] Coda \u00b6 Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec, sempre che non ci si trovi in Italia. Per implementare una coda a partire da una lsita, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . >>> q = [ 1 , 2 , 3 ] >>> q . insert ( 0 , 4 ) >>> q [ 4 , 1 , 2 , 3 ] >>> e = q . pop ( 0 ) >>> e 4 >>> q [ 1 , 2 , 3 ] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: >>> from collections import deque >>> q = deque ([ 1 , 2 , 3 ]) >>> q . appendleft ( 4 ) >>> q deque ([ 4 , 1 , 2 , 3 ]) >>> e = q . popleft () >>> e 4 >>> q deque ([ 1 , 2 , 3 ]) Esercizio: tempo di confronti! \u00b6 Proviamo a comparare i due approcci che abbiamo visto per la costruzione di una coda. Per farlo, usiamo la libreria time : from time import time from collections import deque def queue ( queue , pushed = 1 ): t1 = time () queue . insert ( 0 , 4 ) queue . pop () t2 = time () print ( t2 - t1 ) def queue_con_deque ( queue , pushed = 1 ): t1 = time () queue . appendleft ( pushed ) queue . popleft () t2 = time () print ( t2 - t1 ) Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo il seguente output: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0 Nota Il codice per questo esercizio \u00e8 fornito nella relativa sezione a questo link . Conclusioni \u00b6 In questa lezione, abbiamo visto due applicazioni del concetto di lista. Nella prossima, introdurremo la tecnica della list comprehension .","title":"03 - Liste, code e pile"},{"location":"01_python/03_strutture/#alcune-applicazioni-delle-liste","text":"","title":"Alcune applicazioni delle liste"},{"location":"01_python/03_strutture/#liste-pile-e-code","text":"Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi.","title":"Liste, pile e code"},{"location":"01_python/03_strutture/#pila","text":"Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. >>> s = [ 1 , 2 , 3 ] >>> s . append ( 4 ) >>> s [ 1 , 2 , 3 , 4 ] >>> e = s . pop () >>> e 4 >>> s [ 1 , 2 , 3 ]","title":"Pila"},{"location":"01_python/03_strutture/#coda","text":"Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec, sempre che non ci si trovi in Italia. Per implementare una coda a partire da una lsita, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . >>> q = [ 1 , 2 , 3 ] >>> q . insert ( 0 , 4 ) >>> q [ 4 , 1 , 2 , 3 ] >>> e = q . pop ( 0 ) >>> e 4 >>> q [ 1 , 2 , 3 ] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: >>> from collections import deque >>> q = deque ([ 1 , 2 , 3 ]) >>> q . appendleft ( 4 ) >>> q deque ([ 4 , 1 , 2 , 3 ]) >>> e = q . popleft () >>> e 4 >>> q deque ([ 1 , 2 , 3 ])","title":"Coda"},{"location":"01_python/03_strutture/#esercizio-tempo-di-confronti","text":"Proviamo a comparare i due approcci che abbiamo visto per la costruzione di una coda. Per farlo, usiamo la libreria time : from time import time from collections import deque def queue ( queue , pushed = 1 ): t1 = time () queue . insert ( 0 , 4 ) queue . pop () t2 = time () print ( t2 - t1 ) def queue_con_deque ( queue , pushed = 1 ): t1 = time () queue . appendleft ( pushed ) queue . popleft () t2 = time () print ( t2 - t1 ) Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo il seguente output: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0 Nota Il codice per questo esercizio \u00e8 fornito nella relativa sezione a questo link .","title":"Esercizio: tempo di confronti!"},{"location":"01_python/03_strutture/#conclusioni","text":"In questa lezione, abbiamo visto due applicazioni del concetto di lista. Nella prossima, introdurremo la tecnica della list comprehension .","title":"Conclusioni"},{"location":"01_python/04_list_comprehension/","text":"List comprehension \u00b6 Forma base \u00b6 Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input. Forma estesa con if-else \u00b6 La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Vediamo adesso qualche esempio di applicazione. Esempio 1: selezionare i nomi da una lista \u00b6 Supponiamo di voler selezionare tutti i nomi che iniziano con la lettera \"B\". Se usassimo un classico ciclo for , potremmo scrivere: >>> lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] >>> output = [] >>> for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output . append ( nome ) >>> print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Decidendo di usare invece una list comprehension: >>> output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] >>> print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Esempio 2: calcolo dei quadrati \u00b6 Vediamo come usare una list comprehension per ottenere una nuova lista applicando a tutti gli elementi di una sequenza una certa funzione. Ad esempio, potremmo voler ottenere la lista dei quadrati di una certa sequenza: >>> def quadrato ( numero ): return numero ** 2 >>> output = [] >>> for i in range ( 10 ): output . append ( quadrato ( i )) >>> output [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Utilizzando la list comprehension: >>> output = [ quadrato ( i ) for i in range ( 10 )] >>> output [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Esempio 3: lista dei numeri pari e dispari \u00b6 Facciamo un ultimo esempio usando una list comprehension per \"contrassegnare\" tutti i numeri da 0 a 10 in base al fatto che siano pari o dispari. Al solito, vediamo come farlo usando un ciclo: >>> output = [] >>> for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \" {} \u00e8 pari\" . format ( i )) else : output . append ( \" {} \u00e8 dispari\" . format ( i )) >>> output [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] Usando una list comprehension, invece: >>> output = [ \" {} \u00e8 pari\" . format ( i ) if i % 2 == 0 else \" {} \u00e8 dispari\" . format ( i ) for i in range ( 1 , 10 )] >>> output [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] In definitiva... \u00b6 Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension. Post scriptum: assignment expressions \u00b6 Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 3.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"04 - List comprehension"},{"location":"01_python/04_list_comprehension/#list-comprehension","text":"","title":"List comprehension"},{"location":"01_python/04_list_comprehension/#forma-base","text":"Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input.","title":"Forma base"},{"location":"01_python/04_list_comprehension/#forma-estesa-con-if-else","text":"La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Vediamo adesso qualche esempio di applicazione.","title":"Forma estesa con if-else"},{"location":"01_python/04_list_comprehension/#esempio-1-selezionare-i-nomi-da-una-lista","text":"Supponiamo di voler selezionare tutti i nomi che iniziano con la lettera \"B\". Se usassimo un classico ciclo for , potremmo scrivere: >>> lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] >>> output = [] >>> for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output . append ( nome ) >>> print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Decidendo di usare invece una list comprehension: >>> output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] >>> print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ]","title":"Esempio 1: selezionare i nomi da una lista"},{"location":"01_python/04_list_comprehension/#esempio-2-calcolo-dei-quadrati","text":"Vediamo come usare una list comprehension per ottenere una nuova lista applicando a tutti gli elementi di una sequenza una certa funzione. Ad esempio, potremmo voler ottenere la lista dei quadrati di una certa sequenza: >>> def quadrato ( numero ): return numero ** 2 >>> output = [] >>> for i in range ( 10 ): output . append ( quadrato ( i )) >>> output [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Utilizzando la list comprehension: >>> output = [ quadrato ( i ) for i in range ( 10 )] >>> output [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ]","title":"Esempio 2: calcolo dei quadrati"},{"location":"01_python/04_list_comprehension/#esempio-3-lista-dei-numeri-pari-e-dispari","text":"Facciamo un ultimo esempio usando una list comprehension per \"contrassegnare\" tutti i numeri da 0 a 10 in base al fatto che siano pari o dispari. Al solito, vediamo come farlo usando un ciclo: >>> output = [] >>> for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \" {} \u00e8 pari\" . format ( i )) else : output . append ( \" {} \u00e8 dispari\" . format ( i )) >>> output [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] Usando una list comprehension, invece: >>> output = [ \" {} \u00e8 pari\" . format ( i ) if i % 2 == 0 else \" {} \u00e8 dispari\" . format ( i ) for i in range ( 1 , 10 )] >>> output [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ]","title":"Esempio 3: lista dei numeri pari e dispari"},{"location":"01_python/04_list_comprehension/#in-definitiva","text":"Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension.","title":"In definitiva..."},{"location":"01_python/04_list_comprehension/#post-scriptum-assignment-expressions","text":"Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 3.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"Post scriptum: assignment expressions"},{"location":"01_python/05_tuple_dict/","text":"Le altre strutture per le sequenze \u00b6 Quando abbiamo parlato delle liste abbiamo accennato al fatto che Python offre altre tre strutture built-in per memorizzare sequenze di dati. Scopriamole insieme. Tuple \u00b6 Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: >>> tupla = ( 'hello' , 'world' , 12 ) >>> tupla ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: >>> tupla = ( 'hello' , 'world' , ( 1 , 2 )) >>> tupla ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: >>> tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) >>> tupla [ 2 ] [ 1 , 2 , 3 ] La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: >>> tupla [ 2 ] = [ 2 , 2 , 3 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : >>> tupla [ 2 ][ 0 ] = 2 >>> tupla ( 'hello' , 'world' , [ 2 , 2 , 3 ]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi. Set \u00b6 Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. >>> insieme = { 1 , \"stringa\" , 2 } >>> insieme { 1 , 2 , 'stringa' } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: >>> l = [ 1 , 2 , 2 , 3 ] >>> l [ 1 , 2 , 2 , 3 ] >>> s = set ( l ) >>> s { 1 , 2 , 3 } Dizionari \u00b6 Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 3.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: >>> dizionario = {} >>> dizionario {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: >>> dizionario [ 'k' ] = 'v' >>> dizionario { 'k' : 'v' } >>> dizionario [ 1 ] = 'n' >>> dizionario { 'k' : 'v' , 1 : 'n' } Per accedere al valore associato ad una determinata chiave: >>> dizionario [ 1 ] 'n' Chiavi e valori \u00b6 E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: >>> chiavi = dizionario . keys () >>> chiavi dict_keys ([ 'k' , 1 ]) # non \u00e8 una lista! >>> list ( chiavi ) [ 'k' , 1 ] # \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: >>> valori = dizionario . values () >>> valori dict_values ([ 'k' , 'n' ]) # non \u00e8 una lista! >>> list ( valori ) [ 'k' , 'n' ] # \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: >>> coppie = dizionario . items () >>> coppie dict_items ([( 'k' , 'v' ), ( 1 , 'n' )]) # non \u00e8 una lista! >>> list ( coppie ) [( 'k' , 'v' ), ( 1 , 'n' )] # lista di tuple! >>> Creazione di un dizionario (non vuoto) \u00b6 Abbiamo diversi modi per creare un dizionario non vuoto. Uso dell'operatore {} \u00b6 Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 } Uso del costruttore dict() \u00b6 Un altro modo \u00e8 usare il metodo costruttore dict() : >>> dizionario = dict ( k1 = 1 , k2 = 2 ) >>> dizionario { 'k1' : 1 , 'k2' : 2 } Uso della funzione zip \u00b6 Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: >>> chiavi = [ 'k1' , 'k2' ] >>> valori = [ 1 , 2 ] >>> dizionario = dict ( zip ( chiavi , valori )) >>> dizionario { 'k1' : 1 , 'k2' : 2 } Dict comprehension \u00b6 Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: >>> quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} >>> quadrati { '1' : 1 , '2' : 4 , '3' : 9 , '4' : 16 , '5' : 25 , '6' : 36 , '7' : 49 , '8' : 64 , '9' : 81 } Oppure, possiamo creare un dizionario a partire da un altro dizionario, usando le stesse regole condizionali viste con la list comprehension: >>> dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } >>> vecchio_o_giovane = { k : 'vecchio' if v > 50 else 'giovane' for ( k , v ) in dizionario . items () } >>> vecchio_o_giovane { 'Jax Teller' : 'giovane' , 'Walter White' : 'vecchio' , 'Billy Butcher' : 'giovane' , 'Luke Skywalker' : 'vecchio' , 'Bobby Singer' : 'vecchio' , 'Johnny Lawrence' : 'giovane' } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"05 - Tuple, set e dizionari"},{"location":"01_python/05_tuple_dict/#le-altre-strutture-per-le-sequenze","text":"Quando abbiamo parlato delle liste abbiamo accennato al fatto che Python offre altre tre strutture built-in per memorizzare sequenze di dati. Scopriamole insieme.","title":"Le altre strutture per le sequenze"},{"location":"01_python/05_tuple_dict/#tuple","text":"Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: >>> tupla = ( 'hello' , 'world' , 12 ) >>> tupla ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: >>> tupla = ( 'hello' , 'world' , ( 1 , 2 )) >>> tupla ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: >>> tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) >>> tupla [ 2 ] [ 1 , 2 , 3 ] La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: >>> tupla [ 2 ] = [ 2 , 2 , 3 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : >>> tupla [ 2 ][ 0 ] = 2 >>> tupla ( 'hello' , 'world' , [ 2 , 2 , 3 ]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi.","title":"Tuple"},{"location":"01_python/05_tuple_dict/#set","text":"Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. >>> insieme = { 1 , \"stringa\" , 2 } >>> insieme { 1 , 2 , 'stringa' } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: >>> l = [ 1 , 2 , 2 , 3 ] >>> l [ 1 , 2 , 2 , 3 ] >>> s = set ( l ) >>> s { 1 , 2 , 3 }","title":"Set"},{"location":"01_python/05_tuple_dict/#dizionari","text":"Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 3.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: >>> dizionario = {} >>> dizionario {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: >>> dizionario [ 'k' ] = 'v' >>> dizionario { 'k' : 'v' } >>> dizionario [ 1 ] = 'n' >>> dizionario { 'k' : 'v' , 1 : 'n' } Per accedere al valore associato ad una determinata chiave: >>> dizionario [ 1 ] 'n'","title":"Dizionari"},{"location":"01_python/05_tuple_dict/#chiavi-e-valori","text":"E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: >>> chiavi = dizionario . keys () >>> chiavi dict_keys ([ 'k' , 1 ]) # non \u00e8 una lista! >>> list ( chiavi ) [ 'k' , 1 ] # \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: >>> valori = dizionario . values () >>> valori dict_values ([ 'k' , 'n' ]) # non \u00e8 una lista! >>> list ( valori ) [ 'k' , 'n' ] # \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: >>> coppie = dizionario . items () >>> coppie dict_items ([( 'k' , 'v' ), ( 1 , 'n' )]) # non \u00e8 una lista! >>> list ( coppie ) [( 'k' , 'v' ), ( 1 , 'n' )] # lista di tuple! >>>","title":"Chiavi e valori"},{"location":"01_python/05_tuple_dict/#creazione-di-un-dizionario-non-vuoto","text":"Abbiamo diversi modi per creare un dizionario non vuoto.","title":"Creazione di un dizionario (non vuoto)"},{"location":"01_python/05_tuple_dict/#uso-delloperatore","text":"Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"Uso dell'operatore {}"},{"location":"01_python/05_tuple_dict/#uso-del-costruttore-dict","text":"Un altro modo \u00e8 usare il metodo costruttore dict() : >>> dizionario = dict ( k1 = 1 , k2 = 2 ) >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"Uso del costruttore dict()"},{"location":"01_python/05_tuple_dict/#uso-della-funzione-zip","text":"Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: >>> chiavi = [ 'k1' , 'k2' ] >>> valori = [ 1 , 2 ] >>> dizionario = dict ( zip ( chiavi , valori )) >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"Uso della funzione zip"},{"location":"01_python/05_tuple_dict/#dict-comprehension","text":"Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: >>> quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} >>> quadrati { '1' : 1 , '2' : 4 , '3' : 9 , '4' : 16 , '5' : 25 , '6' : 36 , '7' : 49 , '8' : 64 , '9' : 81 } Oppure, possiamo creare un dizionario a partire da un altro dizionario, usando le stesse regole condizionali viste con la list comprehension: >>> dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } >>> vecchio_o_giovane = { k : 'vecchio' if v > 50 else 'giovane' for ( k , v ) in dizionario . items () } >>> vecchio_o_giovane { 'Jax Teller' : 'giovane' , 'Walter White' : 'vecchio' , 'Billy Butcher' : 'giovane' , 'Luke Skywalker' : 'vecchio' , 'Bobby Singer' : 'vecchio' , 'Johnny Lawrence' : 'giovane' } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"Dict comprehension"},{"location":"01_python/06_moduli/","text":"Script e moduli \u00b6 Un approccio migliore \u00b6 Finora abbiamo interagito direttamente con l'interprete Python, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi, tra cui: non abbiamo il syntax highlighting ; non siamo in grado di recuperare il codice una volta chiuso l'interprete; non possiamo verificare facilmente il funzionamento del codice; non possiamo modificare facilmente il codice. Appare evidente come quindi non si tratti di un modo ottimale di sviluppare codice Python. Per questo, oltre al supporto di una IDE (cfr. Appendice A ), dovremo definire dei veri e propri script , che saranno salvati sotto forma di file con estensione py , e conterranno le istruzioni relative al nostro programma. Il primo script \u00b6 Possiamo quindi provare a creare il nostro primo script Python. Per farlo, apriamo Visual Studio Code (o la nostra IDE di riferimento), e creiamo un file chiamato main.py , all'interno del quale inseriremo questo codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: $ cd cartella_dove_risiede_lo_script $ python main.py A schermo, dovrebbe apparire la scritta Hello, world : Hello, world L'approccio modulare \u00b6 Utilizzare gli script permette di ovviare a diversi tra gli inconvenienti evidenziati in precedenza; tuttavia, quando le dimensioni della nostra code base (ovvero, la quantit\u00e0 di codice che scriviamo nei nostri programmi) iniziano ad essere \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , che prevede una separazione \"fisica\", ancorch\u00e9 logica, di parti di codice delegate a funzioni differenti. Un esempio \u00b6 Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che contraddistingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ . I moduli geometria e trigonometria \u00b6 Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) . Usare gli import \u00b6 Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve. Alias \u00b6 La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi )) La funzione dir() \u00b6 La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from . Moduli della libreria standard \u00b6 Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference . Package \u00b6 Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"06 - Script, moduli e package"},{"location":"01_python/06_moduli/#script-e-moduli","text":"","title":"Script e moduli"},{"location":"01_python/06_moduli/#un-approccio-migliore","text":"Finora abbiamo interagito direttamente con l'interprete Python, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi, tra cui: non abbiamo il syntax highlighting ; non siamo in grado di recuperare il codice una volta chiuso l'interprete; non possiamo verificare facilmente il funzionamento del codice; non possiamo modificare facilmente il codice. Appare evidente come quindi non si tratti di un modo ottimale di sviluppare codice Python. Per questo, oltre al supporto di una IDE (cfr. Appendice A ), dovremo definire dei veri e propri script , che saranno salvati sotto forma di file con estensione py , e conterranno le istruzioni relative al nostro programma.","title":"Un approccio migliore"},{"location":"01_python/06_moduli/#il-primo-script","text":"Possiamo quindi provare a creare il nostro primo script Python. Per farlo, apriamo Visual Studio Code (o la nostra IDE di riferimento), e creiamo un file chiamato main.py , all'interno del quale inseriremo questo codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: $ cd cartella_dove_risiede_lo_script $ python main.py A schermo, dovrebbe apparire la scritta Hello, world : Hello, world","title":"Il primo script"},{"location":"01_python/06_moduli/#lapproccio-modulare","text":"Utilizzare gli script permette di ovviare a diversi tra gli inconvenienti evidenziati in precedenza; tuttavia, quando le dimensioni della nostra code base (ovvero, la quantit\u00e0 di codice che scriviamo nei nostri programmi) iniziano ad essere \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , che prevede una separazione \"fisica\", ancorch\u00e9 logica, di parti di codice delegate a funzioni differenti.","title":"L'approccio modulare"},{"location":"01_python/06_moduli/#un-esempio","text":"Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che contraddistingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ .","title":"Un esempio"},{"location":"01_python/06_moduli/#i-moduli-geometria-e-trigonometria","text":"Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) .","title":"I moduli geometria e trigonometria"},{"location":"01_python/06_moduli/#usare-gli-import","text":"Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve.","title":"Usare gli import"},{"location":"01_python/06_moduli/#alias","text":"La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi ))","title":"Alias"},{"location":"01_python/06_moduli/#la-funzione-dir","text":"La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from .","title":"La funzione dir()"},{"location":"01_python/06_moduli/#moduli-della-libreria-standard","text":"Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference .","title":"Moduli della libreria standard"},{"location":"01_python/06_moduli/#package","text":"Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"Package"},{"location":"01_python/07_classi/","text":"Classi in Python \u00b6 Cos\u00ec come il C++, Python ha un esteso supporto per la programmazione orientata agli oggetti. La definizione di una classe in Python avviene come segue: class ClassName ( BaseClass ): # Class body Notiamo che, a differenza del C++, nel quale la classe viene definita all'interno di un header, qui la definizione avviene contestualmente alla dichiarazione della firma della classe. Costruttori \u00b6 Il linguaggio Python non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione degli attributi della classe. Questo metodo assume lo stesso nome per ogni classe, ovvero __init__ : class ClassName ( BaseClass ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Nota La sintassi *args e **kwargs rappresenta, rispettivamente, l' unpacking di liste e dizionari. Ci\u00f2 significa che come argomento non si passa la lista o il dizionario, ma i valori (o le coppie chiave/valore) ivi contenuti. Notiamo l'uso della parola chiave self . Questa, in qualche modo, richiama il this del C++: infatti, si riferisce alla specifica istanza della classe. Ad esempio: class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota In Python, tutte le classi derivano da una classe generica object . Modificatori di accesso \u00b6 Python prevede, come il C++, l'uso di modificatori di accesso ai dati; nello specifico, ritroviamo public , protected e private . Per contraddistinguere i tre tipi di variabili, si utilizzano gli underscore come suffisso al nome della stessa; in particolare, un unico underscore indica un membro protected , mentre un doppio underscore indica un membro private . class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota I membri protetti sono facilmente accessibili dall'esterno della classe. Infatti: p = Person ( 'Jax' , 'Teller' ) print ( p . first_name ) print ( p . _last_name ) try : print ( p . __age ) except AttributeError : print ( 'Age is private!' ) risulter\u00e0 in: Jax Teller Et\u00e0 \u00e8 privato! Contestualmente, \u00e8 possibile usare la stessa convenzione definire metodi per l'accesso a variabili protected e private . Classi e metodi \u00b6 I metodi di una classe sono definiti in questo modo: def metodo ( self , * args , ** kwargs ): pass E' importante notare come il primo attributo di un normale metodo di classe sia sempre la parola self . Questa non deve per\u00f2 essere specificata quando lo si chiama dall'esterno: basta infatti chiamarlo usando l'operatore . da un'istanza della classe: # ... p = Person () p . metodo ( * args , ** kwargs ) # ... I decorator \u00b6 Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione. Funzioni come oggetti \u00b6 Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester Funzioni come argomenti di altre funzioni \u00b6 Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series . Definizione ed uso di decorator \u00b6 La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it ! @classmethod \u00b6 E' possibile definire i cosiddetti metodi di classe mediante il decorator @classmethod : @classmethod def from_string ( cls , person_string : str ): fn , ln , age = person_string . split ( ' ' ) return Person ( fn , ln , age ) A differenza dei normali metodi definiti all'interno di una classe, i metodi di classe passano implicitamente un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi pensati per applicarsi all'intera classe, e non alla singola istanza; normalmente, vengono usati per creare dei costruttori alternativi, come nel caso precedente, nel quale creiamo una persona a partire da una stringa. Per chiamare un metodo di classe, ci riferiamo al nome della classe stessa, e non alla singola istanza: pb = Person . from_string ( 'Bobby Munson 58' ) print ( \" {} {} \" . format ( pb . first_name , pb . _last_name )) @staticmethod \u00b6 Cos\u00ec come in C e C++, \u00e8 possibile definire metodi statici, che in questo caso sono maggiormente assimilabili alla loro concezione del C++. Infatti, nell'ambito della classe, un metodo statico non accetta n\u00e9 la classe, n\u00e9 una specifica istanza, ma si comporta come una funzione \"semplice\", che per\u00f2 \u00e8 possibile chiamare dall'interno della classe. Ad esempio: @staticmethod def check_is_valid ( first_name ): # return False if len(first_name) < 2 else True # return len(first_name) < 2 return False or len ( first_name ) >= 2 Nota In questo metodo, abbiamo usato una sintassi chiamata shorthand ternary operator , mentre commentato troviamo il classico operatore ternario, o una versione pi\u00f9 semplice. >>> print ( pb . check_is_valid ( 'Li' )) True >>> print ( Person . check_is_valid ( 'X' )) False @abstractmethod \u00b6 I metodi astratti sono definibili nel caso si stiano implementando delle classi astratte (ovvero classi in cui alcuni metodi non sono implementati) o, nel caso estremo, interfacce (ovvero classi in cui nessun metodo \u00e8 implementato). Per usarli, la nostra classe deve discendere da un particolare tipo di classe Python chiamato Abstract Base Class , abbreviato in ABC , e contenuto nel package abc : from abc import ABC class BaseClass ( ABC ): # some methods... @abstractmethod def method_to_override ( self ): pass I metodi contrassegnati con il decorator @abstractmethod andranno implementati nelle classi derivate (operazione di override ): class DerivedClass ( BaseClass ): # some methods... def method_to_override ( self ): do_something () Propriet\u00e0 \u00b6 A differenza delle classi implementate in C++, finora non abbiamo usato i getter ed i setter. Per farlo, possiamo usare sia degli opportuni metodi (nel nostro caso, ad esempio, potremmo usare un metodo get_first_name(self) , un metodo set_first_name(self, fn) , e via dicendo), o, in maniera pi\u00f9 pythonic , il decorator @property , che ci offre un modo integrato per definire ogni attributo della classe. Note In realt\u00e0, il decorator @property si riferisce ad una funzione con quattro parametri: py property(fget=None, fset=None, fdel=None, doc=None) che rappresentano: * fget funzione per ottenere il valore dell'attributo; * fset funzione per impostare il valore dell'attributo; * fdel funzione per cancellare l'attributo; * doc funzione per la documentazione dell'attributo. Le best practice ci dicono di adattare i nostri attributi, rendendoli privati, ed accedendovi soltanto mediante il decorator @property : class PersonProperty (): def __init__ ( self , first_name , last_name , age ): self . first_name = first_name self . last_name = last_name self . age = age @property def first_name ( self ): return self . __first_name @first_name . setter def first_name ( self , value ): if len ( value ) < 2 : raise ValueError ( 'Name must be longer than two characters' ) else : self . __first_name = value # ... >>> pp = PersonProperty ( 'Draco' , 'Malfoy' , 12 ) >>> print ( pp . first_name ) Draco >>> pp = PersonProperty ( '' , 'Granger' , 18 ) ValueError : Name must be longer than two characters","title":"07 - Classi"},{"location":"01_python/07_classi/#classi-in-python","text":"Cos\u00ec come il C++, Python ha un esteso supporto per la programmazione orientata agli oggetti. La definizione di una classe in Python avviene come segue: class ClassName ( BaseClass ): # Class body Notiamo che, a differenza del C++, nel quale la classe viene definita all'interno di un header, qui la definizione avviene contestualmente alla dichiarazione della firma della classe.","title":"Classi in Python"},{"location":"01_python/07_classi/#costruttori","text":"Il linguaggio Python non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione degli attributi della classe. Questo metodo assume lo stesso nome per ogni classe, ovvero __init__ : class ClassName ( BaseClass ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Nota La sintassi *args e **kwargs rappresenta, rispettivamente, l' unpacking di liste e dizionari. Ci\u00f2 significa che come argomento non si passa la lista o il dizionario, ma i valori (o le coppie chiave/valore) ivi contenuti. Notiamo l'uso della parola chiave self . Questa, in qualche modo, richiama il this del C++: infatti, si riferisce alla specifica istanza della classe. Ad esempio: class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota In Python, tutte le classi derivano da una classe generica object .","title":"Costruttori"},{"location":"01_python/07_classi/#modificatori-di-accesso","text":"Python prevede, come il C++, l'uso di modificatori di accesso ai dati; nello specifico, ritroviamo public , protected e private . Per contraddistinguere i tre tipi di variabili, si utilizzano gli underscore come suffisso al nome della stessa; in particolare, un unico underscore indica un membro protected , mentre un doppio underscore indica un membro private . class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota I membri protetti sono facilmente accessibili dall'esterno della classe. Infatti: p = Person ( 'Jax' , 'Teller' ) print ( p . first_name ) print ( p . _last_name ) try : print ( p . __age ) except AttributeError : print ( 'Age is private!' ) risulter\u00e0 in: Jax Teller Et\u00e0 \u00e8 privato! Contestualmente, \u00e8 possibile usare la stessa convenzione definire metodi per l'accesso a variabili protected e private .","title":"Modificatori di accesso"},{"location":"01_python/07_classi/#classi-e-metodi","text":"I metodi di una classe sono definiti in questo modo: def metodo ( self , * args , ** kwargs ): pass E' importante notare come il primo attributo di un normale metodo di classe sia sempre la parola self . Questa non deve per\u00f2 essere specificata quando lo si chiama dall'esterno: basta infatti chiamarlo usando l'operatore . da un'istanza della classe: # ... p = Person () p . metodo ( * args , ** kwargs ) # ...","title":"Classi e metodi"},{"location":"01_python/07_classi/#i-decorator","text":"Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione.","title":"I decorator"},{"location":"01_python/07_classi/#funzioni-come-oggetti","text":"Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester","title":"Funzioni come oggetti"},{"location":"01_python/07_classi/#funzioni-come-argomenti-di-altre-funzioni","text":"Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series .","title":"Funzioni come argomenti di altre funzioni"},{"location":"01_python/07_classi/#definizione-ed-uso-di-decorator","text":"La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it !","title":"Definizione ed uso di decorator"},{"location":"01_python/07_classi/#classmethod","text":"E' possibile definire i cosiddetti metodi di classe mediante il decorator @classmethod : @classmethod def from_string ( cls , person_string : str ): fn , ln , age = person_string . split ( ' ' ) return Person ( fn , ln , age ) A differenza dei normali metodi definiti all'interno di una classe, i metodi di classe passano implicitamente un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi pensati per applicarsi all'intera classe, e non alla singola istanza; normalmente, vengono usati per creare dei costruttori alternativi, come nel caso precedente, nel quale creiamo una persona a partire da una stringa. Per chiamare un metodo di classe, ci riferiamo al nome della classe stessa, e non alla singola istanza: pb = Person . from_string ( 'Bobby Munson 58' ) print ( \" {} {} \" . format ( pb . first_name , pb . _last_name ))","title":"@classmethod"},{"location":"01_python/07_classi/#staticmethod","text":"Cos\u00ec come in C e C++, \u00e8 possibile definire metodi statici, che in questo caso sono maggiormente assimilabili alla loro concezione del C++. Infatti, nell'ambito della classe, un metodo statico non accetta n\u00e9 la classe, n\u00e9 una specifica istanza, ma si comporta come una funzione \"semplice\", che per\u00f2 \u00e8 possibile chiamare dall'interno della classe. Ad esempio: @staticmethod def check_is_valid ( first_name ): # return False if len(first_name) < 2 else True # return len(first_name) < 2 return False or len ( first_name ) >= 2 Nota In questo metodo, abbiamo usato una sintassi chiamata shorthand ternary operator , mentre commentato troviamo il classico operatore ternario, o una versione pi\u00f9 semplice. >>> print ( pb . check_is_valid ( 'Li' )) True >>> print ( Person . check_is_valid ( 'X' )) False","title":"@staticmethod"},{"location":"01_python/07_classi/#abstractmethod","text":"I metodi astratti sono definibili nel caso si stiano implementando delle classi astratte (ovvero classi in cui alcuni metodi non sono implementati) o, nel caso estremo, interfacce (ovvero classi in cui nessun metodo \u00e8 implementato). Per usarli, la nostra classe deve discendere da un particolare tipo di classe Python chiamato Abstract Base Class , abbreviato in ABC , e contenuto nel package abc : from abc import ABC class BaseClass ( ABC ): # some methods... @abstractmethod def method_to_override ( self ): pass I metodi contrassegnati con il decorator @abstractmethod andranno implementati nelle classi derivate (operazione di override ): class DerivedClass ( BaseClass ): # some methods... def method_to_override ( self ): do_something ()","title":"@abstractmethod"},{"location":"01_python/07_classi/#proprieta","text":"A differenza delle classi implementate in C++, finora non abbiamo usato i getter ed i setter. Per farlo, possiamo usare sia degli opportuni metodi (nel nostro caso, ad esempio, potremmo usare un metodo get_first_name(self) , un metodo set_first_name(self, fn) , e via dicendo), o, in maniera pi\u00f9 pythonic , il decorator @property , che ci offre un modo integrato per definire ogni attributo della classe. Note In realt\u00e0, il decorator @property si riferisce ad una funzione con quattro parametri: py property(fget=None, fset=None, fdel=None, doc=None) che rappresentano: * fget funzione per ottenere il valore dell'attributo; * fset funzione per impostare il valore dell'attributo; * fdel funzione per cancellare l'attributo; * doc funzione per la documentazione dell'attributo. Le best practice ci dicono di adattare i nostri attributi, rendendoli privati, ed accedendovi soltanto mediante il decorator @property : class PersonProperty (): def __init__ ( self , first_name , last_name , age ): self . first_name = first_name self . last_name = last_name self . age = age @property def first_name ( self ): return self . __first_name @first_name . setter def first_name ( self , value ): if len ( value ) < 2 : raise ValueError ( 'Name must be longer than two characters' ) else : self . __first_name = value # ... >>> pp = PersonProperty ( 'Draco' , 'Malfoy' , 12 ) >>> print ( pp . first_name ) Draco >>> pp = PersonProperty ( '' , 'Granger' , 18 ) ValueError : Name must be longer than two characters","title":"Propriet\u00e0"},{"location":"02_numpy/01_intro/","text":"Introduzione a NumPy \u00b6 La libreria NumPy (abbreviazione che sta per Num*erical *Py*thon) \u00e8 quella maggiormente usata nel campo del calcolo scientifico in Python, e ne rappresenta uno standard *de facto , in quanto le API messe a disposizione da NumPy sono estensivamente utilizzate dalla quasi totalit\u00e0 degli altri package dedicati alle scienze ed all'ingegneria. Installazione \u00b6 Al momento di installare NumPy, possiamo optare per due opzioni. La prima \u00e8 quella di usare una distribuzione \"scientifica\" di Python; quella pi\u00f9 usata \u00e8 Anaconda . La seconda strada, che \u00e8 quella che seguiremo, \u00e8 sfruttare un'installazione \"standard\" di Python, creando un apposito ambiente virtuale ed il dependency manager pipenv . Creiamo quindi una cartella, e creiamo un nuovo ambiente virtuale con NumPy usando questo comando: mkdir python-data-science cd python-data-science pipenv install numpy All'interno della cartella troveremo due file: Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente i file generati da pipenv. Per farlo, esistono comandi appositi che illustreremo man mano che ne avremo bisogno. Importare NumPy \u00b6 Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np Gli ndarray \u00b6 La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy offre una struttura chiamata ndarray , rappresentante un array ad \\(n\\) dimensioni contenente dati di tipo omogeneo . E' interessante notare come anche ndarray sia un'abbreviazione, stante per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 molto simile a quella di una classica lista Python: >>> a = numpy . array ([ 1 , 2 , 3 ]) Questa sintassi, per\u00f2, non deve trarci in inganno. Esistono, infatti, varie differenze che intercorrono tra un ndarray ed una classica sequenza Python, ovvero: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array creer\u00e0 quindi un nuovo array, cancellando quello originario; gli elementi di un ndarray devono essere dello stesso tipo; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni. Efficienza di NumPy \u00b6 Il terzo punto \u00e8 particolarmente importante, sopratutto nell'ambito del calcolo scientifico. Come semplice esempio, consideriamo una moltiplicazione elemento per elemento tra due vettori della stessa dimensione. Con due liste, potremmo usare un ciclo for : c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) oppure una list comprehension : c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] In entrambi i casi, l'operazione verr\u00e0 effettuata in maniera corretta; tuttavia, se i vettori sono di dimensioni importanti, avremo un costo da pagare legato all'inefficienza di Python nella gestione dei cicli. Ovviamente, dato che le inefficienze sono legate al Python (e, quindi, all' overhead introdotto principalmente dall'interprete), la soluzione pi\u00f9 semplice sarebbe quella di utilizzare un altro linguaggio, come ad esempio il C. In questo caso, l'operazione precedente sarebbe associata a questo codice: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Per un caso cos\u00ec semplice, s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, l'operazione precedente pu\u00f2 essere riassunta in NumPy come segue: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, sia rispetto al C, sia rispetto al caso in cui si usino delle liste in Python. Inoltre, \u00e8 la stessa sintassi che viene solitamente usata nelle formule reali! Oltre a questo, NumPy sfrutta codice precompilato in C: questo significa che la precedente operazione sar\u00e0 svolta quasi alla stessa velocit\u00e0 del codice scritto in linguaggio C. Si tratta, quindi, di unire il \"meglio\" dei due mondi: da un lato, l'eleganza e semplicit\u00e0 sintattica del Python e, dall'altro, l'efficienza del C. Vettorizzazione e broadcasting \u00b6 Due importanti concetti sfruttati da NumPy sono quelli di vettorizzazione e broadcasting . La vettorizzazione ci permette di scrivere codice senza cicli o indici espliciti; ovviamente, i cicli ci sono , ma avvengono sotto al cofano , grazie al codice C precompilato. Il codice vettorizzato, inoltre, presenta diversi vantaggi, soprattutto in termini di leggibilit\u00e0 e manutenibilit\u00e0. Il concetto di broadcasting riguarda invece il comportamento implicito delle operazioni, e permette di usare la stessa sintassi indipendentemente dalle dimensioni degli ndarray coinvolti (e dall'operazione effettuata, sia essa algebrica, logica, etc.).","title":"01 - Introduzione a NumPy"},{"location":"02_numpy/01_intro/#introduzione-a-numpy","text":"La libreria NumPy (abbreviazione che sta per Num*erical *Py*thon) \u00e8 quella maggiormente usata nel campo del calcolo scientifico in Python, e ne rappresenta uno standard *de facto , in quanto le API messe a disposizione da NumPy sono estensivamente utilizzate dalla quasi totalit\u00e0 degli altri package dedicati alle scienze ed all'ingegneria.","title":"Introduzione a NumPy"},{"location":"02_numpy/01_intro/#installazione","text":"Al momento di installare NumPy, possiamo optare per due opzioni. La prima \u00e8 quella di usare una distribuzione \"scientifica\" di Python; quella pi\u00f9 usata \u00e8 Anaconda . La seconda strada, che \u00e8 quella che seguiremo, \u00e8 sfruttare un'installazione \"standard\" di Python, creando un apposito ambiente virtuale ed il dependency manager pipenv . Creiamo quindi una cartella, e creiamo un nuovo ambiente virtuale con NumPy usando questo comando: mkdir python-data-science cd python-data-science pipenv install numpy All'interno della cartella troveremo due file: Pipfile , che conterr\u00e0 l'elenco dei pacchetti che abbiamo installato in quello specifico ambiente virtuale; Pipfile.lock , che conterr\u00e0 i riferimenti alle versioni dei singoli pacchetti installati. Attenzione Non modifichiamo mai direttamente i file generati da pipenv. Per farlo, esistono comandi appositi che illustreremo man mano che ne avremo bisogno.","title":"Installazione"},{"location":"02_numpy/01_intro/#importare-numpy","text":"Abbiamo visto in precedenza che per usare un package o un modulo Python all'interno dei nostri script dovremo per prima cosa renderli \"visibili\". Faremo ovviamente lo stesso con NumPy, anteponendo questa direttiva in ogni modulo nel quale lo useremo: import numpy as np","title":"Importare NumPy"},{"location":"02_numpy/01_intro/#gli-ndarray","text":"La struttura dati alla base di NumPy \u00e8 quella degli array . Pi\u00f9 precisamente, NumPy offre una struttura chiamata ndarray , rappresentante un array ad \\(n\\) dimensioni contenente dati di tipo omogeneo . E' interessante notare come anche ndarray sia un'abbreviazione, stante per n - d*imensional *array . La dichiarazione ed inizializzazione di un ndarray \u00e8 molto simile a quella di una classica lista Python: >>> a = numpy . array ([ 1 , 2 , 3 ]) Questa sintassi, per\u00f2, non deve trarci in inganno. Esistono, infatti, varie differenze che intercorrono tra un ndarray ed una classica sequenza Python, ovvero: un ndarray ha una dimensione fissata al momento della creazione, a differenza della lista. Cambiare la dimensione di un array creer\u00e0 quindi un nuovo array, cancellando quello originario; gli elementi di un ndarray devono essere dello stesso tipo; gli array rendono pi\u00f9 semplici ed efficienti le operazioni algebriche, specialmente su matrici di grosse dimensioni.","title":"Gli ndarray"},{"location":"02_numpy/01_intro/#efficienza-di-numpy","text":"Il terzo punto \u00e8 particolarmente importante, sopratutto nell'ambito del calcolo scientifico. Come semplice esempio, consideriamo una moltiplicazione elemento per elemento tra due vettori della stessa dimensione. Con due liste, potremmo usare un ciclo for : c = [] for i in range ( len ( a )): c . append ( a [ i ] * b [ i ]) oppure una list comprehension : c = [ a [ i ] * b [ i ] for i in range ( len ( a ))] In entrambi i casi, l'operazione verr\u00e0 effettuata in maniera corretta; tuttavia, se i vettori sono di dimensioni importanti, avremo un costo da pagare legato all'inefficienza di Python nella gestione dei cicli. Ovviamente, dato che le inefficienze sono legate al Python (e, quindi, all' overhead introdotto principalmente dall'interprete), la soluzione pi\u00f9 semplice sarebbe quella di utilizzare un altro linguaggio, come ad esempio il C. In questo caso, l'operazione precedente sarebbe associata a questo codice: for ( i = 0 ; i < rows ; i ++ ) { c [ i ] = a [ i ] * b [ i ]; } Problema risolto, dunque? Per un caso cos\u00ec semplice, s\u00ec. Immaginiamo per\u00f2 di voler estendere il caso precedente a due dimensioni; il codice diverr\u00e0: for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { c [ i ][ j ] = a [ i ][ j ] * b [ i ][ j ]; } } Appare quindi chiaro come anche un leggero aumento della complessit\u00e0 delle operazioni da effettuare comporti un significativo aumento della complessit\u00e0 in termini di codice. Ed \u00e8 proprio qui che NumPy ci viene in aiuto. Infatti, l'operazione precedente pu\u00f2 essere riassunta in NumPy come segue: c = a * b La sintassi \u00e8 evidentemente molto pi\u00f9 concisa e semplice, sia rispetto al C, sia rispetto al caso in cui si usino delle liste in Python. Inoltre, \u00e8 la stessa sintassi che viene solitamente usata nelle formule reali! Oltre a questo, NumPy sfrutta codice precompilato in C: questo significa che la precedente operazione sar\u00e0 svolta quasi alla stessa velocit\u00e0 del codice scritto in linguaggio C. Si tratta, quindi, di unire il \"meglio\" dei due mondi: da un lato, l'eleganza e semplicit\u00e0 sintattica del Python e, dall'altro, l'efficienza del C.","title":"Efficienza di NumPy"},{"location":"02_numpy/01_intro/#vettorizzazione-e-broadcasting","text":"Due importanti concetti sfruttati da NumPy sono quelli di vettorizzazione e broadcasting . La vettorizzazione ci permette di scrivere codice senza cicli o indici espliciti; ovviamente, i cicli ci sono , ma avvengono sotto al cofano , grazie al codice C precompilato. Il codice vettorizzato, inoltre, presenta diversi vantaggi, soprattutto in termini di leggibilit\u00e0 e manutenibilit\u00e0. Il concetto di broadcasting riguarda invece il comportamento implicito delle operazioni, e permette di usare la stessa sintassi indipendentemente dalle dimensioni degli ndarray coinvolti (e dall'operazione effettuata, sia essa algebrica, logica, etc.).","title":"Vettorizzazione e broadcasting"},{"location":"02_numpy/02_array/","text":"Introduzione agli array \u00b6 L'array \u00e8 la struttura dati al centro del funzionamento di NumPy. Un array (o, pi\u00f9 precisamente, un ndarray ) \u00e8 una vera e propria griglia di elementi omogenei , ovvero caratterizzati dallo stesso tipo (indicato con dtype ); l'oggetto ndarray offre inoltre dei metodi per reperire il valore e gli indici di ciascun elemento. Inizializzazione di un array \u00b6 Un modo in cui Un modo in cui si possono inziializzare gli array NumPy \u00e8 dalle liste Python, usanod liste annidate per dati con due o pi\u00f9 dimensioni. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) o >>> a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]]) Accesso agli elementi degli array \u00b6 Un aspetto interessante dell'indicizzazione \u00e8 che questa pu\u00f2 essere fatta in diversi modi: ad esempio, \u00e8 possibile usare dei numeri interi, o una maschera di valori booleani, o ancora un altro array. Vediamo alcuni esempi: # TODO: esempi Possiamo accedere agli elementi nell'array usando le parentesi quadre. Quando si accede agli elementi, dobbiamo ricordarci che l'indicizzazione in NumPy inizia a 0. QUesto significa che se vogliamo accedere il primo elemento nell'array, staremo accedendo all'elemento 0. >>> print ( a [ 0 ]) [ 1 2 3 4 ] Array vs. liste \u00b6 Di primo acchitto, pu\u00f2 sembrare che gli array siano molto simili alle classiche liste. Esistono per\u00f2 delle differenze: NumPy ci d\u00e0 un enorme range di modi veloci ed efficienti per creare degli array e manipolare dei dati numerici al lroo interno. Mentre una lista python pu\u00f2 contenere diversi tipi di dati al suo interno, tutti gli elementi in un array NumPy devono essere omogenei. Le operazioni matematiche che devono essere effettuate sugli array sarebbero state infatti estremamente inefficaci se gli array non fossero stati omogenei. Perch\u00e9* usare NumPy? \u00b6 Gli array numpy sono pi\u00f9 veloci e compatti rispetto alle liste Python. Un array consuma meno memoria, ed \u00e8 pi\u00f9 conveniente da utilizzare. NumPy uisa molta meno memoria per memorizzare i dati e fornisce un meccanismo per specificare i tipi d dati. Qusto permette una ulteriore ottimizzzazione del codice. Pi\u00f9 informaizoni sugli array \u00b6 Possiamo occasionalmente sentire un riferimento ad un array come ad un ndarray , che \u00e8 una abbreviazione per N-dimensional array (array ad n dimensioni). Un array ad n dimensioni \u00e8 semplicemente un array con un numero generico di dimensioni. Possiaom sentire infatti 1-D, o array monodimensionaloi, o 2-D, array multidimenzionali, e via dicendo. La classe NumPy ndarray viene suata per rappresentare sia matrici sia vettori. Un vettore \u00e8 un array con una singola dimensione (non vi \u00e8 differenza tra i vettori riga ed i vettori colonna), mentre una matrice si riferisce ad un array con due dimensioni. Per array tridimensionali o con un maggior numero di dimensioni, si usa comunemente il termine tensore. QUali sono gli attributi di un array? \u00b6 Una rray \u00e8 normalmente un contenitore a dimensione fissata di oggetti dello stesso tipo e dimensione. Il numero di dimensioni ed oggetti in un array \u00e8 definito dalla sua forma. La forma di un array \u00e8 una tupla di interi non negativi che specifica le dimensioni lungo ogni asse. In numpy, gli assi sono indicati con axes. Questo indica che se abbiamo un array bidimensionale del tipo: [[0.,0.,0.], [1.,1., 1.]] il nsotro array avr\u00e0 due assi. Il primo asse ha una lunghezza di 2, mentre il secondo una lunghezza di 3. Cos\u00ec come in altri container Python, i contenuti di un array sono accessibili e modificabili mediante l'indicizzazione o lo slicing dell'array. A differenza del tipico container, per\u00f2, diversi array possono condividere gli stessi dati, per cui i cambi fatti su un array possono essere visibili in un altro. Gli attributi di un array riflettono informazioni intrinseche sull'array stesso. Se dobbiamo accedere o impostare delle propriet\u00e0 di un array senza crearne uno nuovo, si pu\u00f2 spesso accedere ad un array mediante is uoi attributi.","title":"Introduzione agli array"},{"location":"02_numpy/02_array/#introduzione-agli-array","text":"L'array \u00e8 la struttura dati al centro del funzionamento di NumPy. Un array (o, pi\u00f9 precisamente, un ndarray ) \u00e8 una vera e propria griglia di elementi omogenei , ovvero caratterizzati dallo stesso tipo (indicato con dtype ); l'oggetto ndarray offre inoltre dei metodi per reperire il valore e gli indici di ciascun elemento.","title":"Introduzione agli array"},{"location":"02_numpy/02_array/#inizializzazione-di-un-array","text":"Un modo in cui Un modo in cui si possono inziializzare gli array NumPy \u00e8 dalle liste Python, usanod liste annidate per dati con due o pi\u00f9 dimensioni. Ad esempio: >>> a = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) o >>> a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]])","title":"Inizializzazione di un array"},{"location":"02_numpy/02_array/#accesso-agli-elementi-degli-array","text":"Un aspetto interessante dell'indicizzazione \u00e8 che questa pu\u00f2 essere fatta in diversi modi: ad esempio, \u00e8 possibile usare dei numeri interi, o una maschera di valori booleani, o ancora un altro array. Vediamo alcuni esempi: # TODO: esempi Possiamo accedere agli elementi nell'array usando le parentesi quadre. Quando si accede agli elementi, dobbiamo ricordarci che l'indicizzazione in NumPy inizia a 0. QUesto significa che se vogliamo accedere il primo elemento nell'array, staremo accedendo all'elemento 0. >>> print ( a [ 0 ]) [ 1 2 3 4 ]","title":"Accesso agli elementi degli array"},{"location":"02_numpy/02_array/#array-vs-liste","text":"Di primo acchitto, pu\u00f2 sembrare che gli array siano molto simili alle classiche liste. Esistono per\u00f2 delle differenze: NumPy ci d\u00e0 un enorme range di modi veloci ed efficienti per creare degli array e manipolare dei dati numerici al lroo interno. Mentre una lista python pu\u00f2 contenere diversi tipi di dati al suo interno, tutti gli elementi in un array NumPy devono essere omogenei. Le operazioni matematiche che devono essere effettuate sugli array sarebbero state infatti estremamente inefficaci se gli array non fossero stati omogenei.","title":"Array vs. liste"},{"location":"02_numpy/02_array/#perche-usare-numpy","text":"Gli array numpy sono pi\u00f9 veloci e compatti rispetto alle liste Python. Un array consuma meno memoria, ed \u00e8 pi\u00f9 conveniente da utilizzare. NumPy uisa molta meno memoria per memorizzare i dati e fornisce un meccanismo per specificare i tipi d dati. Qusto permette una ulteriore ottimizzzazione del codice.","title":"Perch\u00e9* usare NumPy?"},{"location":"02_numpy/02_array/#piu-informaizoni-sugli-array","text":"Possiamo occasionalmente sentire un riferimento ad un array come ad un ndarray , che \u00e8 una abbreviazione per N-dimensional array (array ad n dimensioni). Un array ad n dimensioni \u00e8 semplicemente un array con un numero generico di dimensioni. Possiaom sentire infatti 1-D, o array monodimensionaloi, o 2-D, array multidimenzionali, e via dicendo. La classe NumPy ndarray viene suata per rappresentare sia matrici sia vettori. Un vettore \u00e8 un array con una singola dimensione (non vi \u00e8 differenza tra i vettori riga ed i vettori colonna), mentre una matrice si riferisce ad un array con due dimensioni. Per array tridimensionali o con un maggior numero di dimensioni, si usa comunemente il termine tensore.","title":"Pi\u00f9 informaizoni sugli array"},{"location":"02_numpy/02_array/#quali-sono-gli-attributi-di-un-array","text":"Una rray \u00e8 normalmente un contenitore a dimensione fissata di oggetti dello stesso tipo e dimensione. Il numero di dimensioni ed oggetti in un array \u00e8 definito dalla sua forma. La forma di un array \u00e8 una tupla di interi non negativi che specifica le dimensioni lungo ogni asse. In numpy, gli assi sono indicati con axes. Questo indica che se abbiamo un array bidimensionale del tipo: [[0.,0.,0.], [1.,1., 1.]] il nsotro array avr\u00e0 due assi. Il primo asse ha una lunghezza di 2, mentre il secondo una lunghezza di 3. Cos\u00ec come in altri container Python, i contenuti di un array sono accessibili e modificabili mediante l'indicizzazione o lo slicing dell'array. A differenza del tipico container, per\u00f2, diversi array possono condividere gli stessi dati, per cui i cambi fatti su un array possono essere visibili in un altro. Gli attributi di un array riflettono informazioni intrinseche sull'array stesso. Se dobbiamo accedere o impostare delle propriet\u00e0 di un array senza crearne uno nuovo, si pu\u00f2 spesso accedere ad un array mediante is uoi attributi.","title":"QUali sono gli attributi di un array?"},{"location":"02_numpy/03_build/","text":"Costruire un array \u00b6 I nuovi array possono essere creati mediante un apposito costruttore. ndarray(shape, **kwargs) E' per\u00f2 pi\u00f9 semplice farlo tramite una delle funzioni messe a disposizione da NumPy. Ad esempio, possiamo farlo usando la funzione np.array(), che ci permette di crearlo usando una semplice lista e, opzionalmente, impostando il tipo di dato: >>> a = np . array ([ 1 , 2 , 3 ]) Esistono ovviamente numerose altre funzioni per la creazione di un array. Ad esempio, se volessimo creare una matrice con valori unitari, potremmo usare np.ones(): >>> u = np . ones ( 2 ) array ([ 1. , 1. ]) mentre per una matrice con tutti valori pari a zero usiamo np.zeros(): >>> u = np . zeros ( 2 ) array ([ 0. , 0. ]) Creazione di un array vuoto \u00b6 Possiamo anche creare un array vuoto. Questo pu\u00f2 essere particolarmente utile quando vogliamo preallocare un array di una certa dimensione. >>> np . empty ( 2 ) array ([ 42. , 42. ]) Nota In realt\u00e0, possiamo osservare un fenomeno interessante: infatti, l'array vuoto sar\u00e0, in realt\u00e0, popolato da valori. Tuttavia, questi valori sono completamente casuali, e dipendenti dallo stato della memoria del sistema in un determinato istante. https://numpy.org/doc/stable/user/absolute_beginners.html","title":"03 build"},{"location":"02_numpy/03_build/#costruire-un-array","text":"I nuovi array possono essere creati mediante un apposito costruttore. ndarray(shape, **kwargs) E' per\u00f2 pi\u00f9 semplice farlo tramite una delle funzioni messe a disposizione da NumPy. Ad esempio, possiamo farlo usando la funzione np.array(), che ci permette di crearlo usando una semplice lista e, opzionalmente, impostando il tipo di dato: >>> a = np . array ([ 1 , 2 , 3 ]) Esistono ovviamente numerose altre funzioni per la creazione di un array. Ad esempio, se volessimo creare una matrice con valori unitari, potremmo usare np.ones(): >>> u = np . ones ( 2 ) array ([ 1. , 1. ]) mentre per una matrice con tutti valori pari a zero usiamo np.zeros(): >>> u = np . zeros ( 2 ) array ([ 0. , 0. ])","title":"Costruire un array"},{"location":"02_numpy/03_build/#creazione-di-un-array-vuoto","text":"Possiamo anche creare un array vuoto. Questo pu\u00f2 essere particolarmente utile quando vogliamo preallocare un array di una certa dimensione. >>> np . empty ( 2 ) array ([ 42. , 42. ]) Nota In realt\u00e0, possiamo osservare un fenomeno interessante: infatti, l'array vuoto sar\u00e0, in realt\u00e0, popolato da valori. Tuttavia, questi valori sono completamente casuali, e dipendenti dallo stato della memoria del sistema in un determinato istante. https://numpy.org/doc/stable/user/absolute_beginners.html","title":"Creazione di un array vuoto"},{"location":"02_numpy/04_indexing/","text":"\u00e8 possibile fare l'indicizzazione e lo slice degli array NumPy nello stesso modo con cui lo si fa con le liste Python: >>> data = np . array ([ 1 , 2 , 3 ]) >>> data [ 1 ] 2 >>> data [ 0 : 2 ] array ([ 1 , 2 ]) >>> data [ 1 :] array ([ 2 , 3 ]) >>> data [ - 2 :] array ([ 2 , 3 ]) Possiamo voler prendere una sezione del nostro array, o specificarne gli elementi da usare in ulteriori analisi od operazioni. Per farlo, \u00e8 necessario selezionare un sottoinsieme, fare lo slicing e/o specificare gli indici dei nostri array. Se vogliamo selezionare dei valori dagli array che soddisfino certe condizioni, \u00e8 facile farlo mediante Numpy. Per esempio, se si inizia con questo array: a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]]) Si pu\u00f2 facilmente stampare a schermo tutti i valori nell'array che sono inferiori a 5: >>> print ( a [ a < 5 > ]) [ 1 2 3 4 ] Possiamo anche scegliere, ad esempio, i numeri che sono maggiori o uguali a 5, ed usare questa condizione per indicizzare un array: >>> five_up = ( a >= 5 ) >>> print ( a [ five_up ]) [ 5 6 7 8 9 10 11 12 ] Posisamo scegliere gli elementi divisibili per 2: >>> divisible_by_2 = a [ a % 2 = 0 ] >>> print ( divisible_by_2 ) [ 2 4 6 8 10 12 ] O possiamo scegliere gli elmentic he soddisfano due condizioni usando gli oepratori logici booleani >>> c = a [( a > 2 ) & ( a < 11 )] >>> print ( c ) [ 3 4 5 6 7 8 9 10 ] Possiamo anche suare le operazioni logiche per restituire valori booleani che specificano se i valori in un array rispettano una certa condizione. Questo pu\u00f2 essere utile con gli array che contengono nomi o altri valori categorici: >>> five_up = ( a > 5 ) | ( a == 5 ) >>> print ( five_up ) [[ False False False False ] [ True True True True ] [ True True True True ]] Possiamo anche usare np.nonzero() per scegliere gli elementi o gli indici da un array. Iniziamo con questo array: >>> a = np . array ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]]) Possiamo usare np.nonzero() per selezionare gli indici degli elementi che sono, per esempio, inferiori a 5. >>> b = np . nonzero ( a < 5 ) >>> print ( b ) ( array ([ 0 , 0 , 0 , 0 ]), array ([ 0 , 1 , 2 , 3 ])) In questo esempio, una tupla di array viene restituita: una per ogni dimensione. Il primo array rappresenta gli indici di riga dove si trovano qeusti valori, mentre il secondo rappresenta gli indici di colonna dove si trovano questi valori. Se vogliamo generare una lista di coordinate dove esiste l'elemento, possiamo zippare gli array, iterare sulla lista di coordinate, e stamparli a schermo. Ad esempio: >>> list_of_coordinates = list ( zip ( b [ 0 ], b [ 1 ])) >>> for coord in list_of_coordinates : ... print ( coord ) ( 0 , 0 ) ( 0 , 1 ) ( 0 , 2 ) ( 0 , 3 ) Possiamo anche usare np.nonzero() per stampare gli elementi in un array che siano inferiori a 5 con: >>> print ( a [ b ]) [ 1 2 3 4 ] Se l'elemento che stiamo cercando non esiste nell'array, l'array di indici restituito sar\u00e0 vuoto. Ad esempio: >>> not_there = np . nonzero ( a == 42 ) >>> print ( not_there ) ( array ([], dtype = int64 ), array ([], dtype = int64 ))","title":"04 indexing"},{"location":"02_numpy/04_manipolare_array/","text":"FONO A \"How to convert a D array into a 2D array Ordinare un elemento \u00e8 semplice con np.sort(). Si possono specificare gli assi, tipo ed ordine quando si chiama la funzione. Se si inizia con questo array: >>> arr = np . array ([ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ]) si pu\u00f2 rapidamente ordinare i numeri in ordine ascendente con: >>> np . sort ( arr ) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) Oltre all'ordinamento, che restituisce una copia ordinata di un array, si possono usare le seguenti funzioni: argsort, che \u00e8 un ordinamento indiretto lungo un certo asse lexosrt, che \u00e8 un ordinamento indiretto con pi\u00f9 chiavi searchsorted, che trova gli elementi in un array ordinato e partition, che \u00e8 un ordinamento parziale Se iniziamo con questi array: >>> a = np . array ([ 1 , 2 , 3 , 4 ]) >>> b = np . array ([ 5 , 6 , 7 , 8 ]) possiamo concatenarli usando np.concatenate() . >>> np . concatenate (( a , b )) array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) O, se iniziamo con questi array: x = np.array([[1, 2], [3, 4]]) y = np.array([[5, 6]]) possiamo concatenarli con: np.concatenate((x, y), axis=0) array([[1, 2], [3, 4], [5, 6]]) per rimuovere un elemento in un array, \u00e8 facile usare l'indicizzazione per scegliere gli elementi che si vogliono mantenere. come si fa a sapere la dimensione e forma di un array \u00b6 ndarray.ndim ci dice il numero di assi, o dimensioni, dell'array ndarray.size ci dice il numero totale di elementi dell'array. Questo \u00e8 il prodotto degli elementi della forma dell'array. ndarray.shape ci mostra una tupla di interi che indicano il numero di elmeenti memorizzati in ogni dimensione dell'array. Se, per esempio, si ha un array bidimensioanle con due righe e tre colonne, la forma dell'array \u00e8 (2, 3). per esempio, se si crea questo array: array_example = np.array([[[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0 ,1 ,2, 3], ... [4, 5, 6, 7]]]) Per trovare il numero di dimensioni dell'array, si esegue: array_example.ndim 3 per trovare il numero totale di elementi nell'array, si esegue: array_example.size 24 e per trovare la dimensione del nostro array, eseguiamo: array_example.shape (3, 2, 4) cambiare le dimensioni di un array \u00b6 usare arr.reshape() dar\u00e0 una nuova forma all'array senza cambiare i dati. Ricordiao che quando si usa il metodo reshape, l'array che vogliamo produrre deve avere lo stesso numero di elementi dell'array originario. Se iniziamo con un array con 12 elementi, dovremo assicuracri che il nostro nuovo array ha un totale di 12 elementi. Se iniziamo con questo array: a = np.arange(6) print(a) [0 1 2 3 4 5] possiamo usare reshape() per cambiare le dimensioni dell'arary. Ad esempio, possiamo ridimensionare questo array in un array con tre righe e due colonne: b = a.reshape(3, 2) print(b) [[0 1] [2 3] [4 5]] con np.reshape, possiamo specificare alcuni parametri opzionali: numpy.reshape(a, newshape=(1, 6)) array([[0, 1, 2, 3, 4, 5]]) a \u00e8 l'array che verr\u00e0 ridimensionato. newshape \u00e8 la nuova forma che vogliamo. POssiamo specificare un intero o una tupla di interi. Se specifichiamo un intero, il risultato sar\u00e0 un array di quella lunghezza. La fomra deve essere compatibile con quella originaria.","title":"04 manipolare array"},{"location":"02_numpy/04_manipolare_array/#come-si-fa-a-sapere-la-dimensione-e-forma-di-un-array","text":"ndarray.ndim ci dice il numero di assi, o dimensioni, dell'array ndarray.size ci dice il numero totale di elementi dell'array. Questo \u00e8 il prodotto degli elementi della forma dell'array. ndarray.shape ci mostra una tupla di interi che indicano il numero di elmeenti memorizzati in ogni dimensione dell'array. Se, per esempio, si ha un array bidimensioanle con due righe e tre colonne, la forma dell'array \u00e8 (2, 3). per esempio, se si crea questo array: array_example = np.array([[[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0 ,1 ,2, 3], ... [4, 5, 6, 7]]]) Per trovare il numero di dimensioni dell'array, si esegue: array_example.ndim 3 per trovare il numero totale di elementi nell'array, si esegue: array_example.size 24 e per trovare la dimensione del nostro array, eseguiamo: array_example.shape (3, 2, 4)","title":"come si fa a sapere la dimensione e forma di un array"},{"location":"02_numpy/04_manipolare_array/#cambiare-le-dimensioni-di-un-array","text":"usare arr.reshape() dar\u00e0 una nuova forma all'array senza cambiare i dati. Ricordiao che quando si usa il metodo reshape, l'array che vogliamo produrre deve avere lo stesso numero di elementi dell'array originario. Se iniziamo con un array con 12 elementi, dovremo assicuracri che il nostro nuovo array ha un totale di 12 elementi. Se iniziamo con questo array: a = np.arange(6) print(a) [0 1 2 3 4 5] possiamo usare reshape() per cambiare le dimensioni dell'arary. Ad esempio, possiamo ridimensionare questo array in un array con tre righe e due colonne: b = a.reshape(3, 2) print(b) [[0 1] [2 3] [4 5]] con np.reshape, possiamo specificare alcuni parametri opzionali: numpy.reshape(a, newshape=(1, 6)) array([[0, 1, 2, 3, 4, 5]]) a \u00e8 l'array che verr\u00e0 ridimensionato. newshape \u00e8 la nuova forma che vogliamo. POssiamo specificare un intero o una tupla di interi. Se specifichiamo un intero, il risultato sar\u00e0 un array di quella lunghezza. La fomra deve essere compatibile con quella originaria.","title":"cambiare le dimensioni di un array"},{"location":"02_numpy/05_basic_operations/","text":"una volta che abbiamo creato i nostri array, possiamo iniziare a lavorarci. Diciamo, ad esempio, che abbiamo creato due array, uno chiamato data ed uno chiamato ones . Posisamo sommare i due array mediante il segno pi\u00f9. data = np.array([1, 2]) ones = np.ones(2, dtype=int) data + ones array([2, 3]) Ovviamente, possiamo efettuare anche altre operazioni aritmentiche. data - ones array([0, 1]) data * data array([1, 4]) data / data array([1., 1.]) Le operazioni base sono semplici con NumPy. Se vogliamo trovare la somma degli elementi in un array, useremo sum(). Questo funziona per gli array di qualsiasi dimensione. a = np.array([1, 2, 3, 4]) a.sum() 10 Per aggiungere le righe o le colonne in un array bidimensionale, \u00e8 necessario specificare l'asse. se iniziamo con questo array: b = np.array([[1, 1], [2, 2]]) possiamo sommare le righe con: b.sum(axis=0) array([3, 3]) e le colonne con: b.sum(axis=1) array([2, 4])","title":"05 basic operations"},{"location":"02_numpy/06_broadcasting/","text":"alle volte possiamo voler effettuare un'operazione tra un array ed un singolo numero (chiamata anche operazione tra vettore e scallare) o tra array di diverse dimensioni. Ad esempio, il nostro array (che chiameremo data) contiene infimazioni sulla distanza in miglia, ma vogliamo convertire l'informazioni in chilometri. POssiamo far questa operazione ocn: data = np.array([1.0, 2.0]) data * 1.6 array([1.6, 3.2]) Numpy comprende che la moltiplicazione deve avvenire all'interno di ogni c ella. Questo concetto \u00e8 chiamato broadcasting . Il broadcasting \u00e8 un meccanismo che permette a NumPy di efettuare operazioni su array di diverse forme. Le dimensioi del nostro array devono essere compatibili, per esempio, quando le dimensioni di entrambi gli array sono uguali, o quando una di queste \u00e8 unitaria. Se le dimensioni non sono compatibili, avremo un ValueError.","title":"06 broadcasting"},{"location":"02_numpy/07_useful_ops/","text":"trasposta un'operazione comune \u00e8 fare la trasporta delle nostre matrici. gli array numpy hanno la propriet\u00e0 T che ci permette di trasporre una matrice. si pu\u00f2 anche dover cambiare le dimensioni di una matrice. questo pu\u00f2 accadere quando, ad esempio, si ha un modello che si attende una certa forma di input che \u00e8 diversa dal nostro dataset. questo \u00e8 dove il meotodo reshape pu\u00f2 essere utile. abbiamo infatti bisogno semplicemente di passare le nuove dimensioni che vogliamo per la matrice. data.reshape(2, 3) array([[1, 2, 3], [4, 5, 6]]) data.reshape(3, 2) array([[1, 2], [3, 4], [5, 6]]) reshaping inversa reshaping and flattening","title":"07 useful ops"},{"location":"02_numpy/08_plotting/","text":"Plot di array \u00b6 Se dobbiamo generare un plot per i nosri valri, possiamo farlo in maneira estreamemte semplice usando Matplotlib. Installazione di Matplotlib \u00b6 pipenv install matplotlib Per esempio, se abbiamo un array come questo: a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22]) importiamo matplotlib: import matplotlib.pypplot as plt A questo punto, ci baster\u00e0 eseguire quesot comando: plt.plot(a)s","title":"Plot di array"},{"location":"02_numpy/08_plotting/#plot-di-array","text":"Se dobbiamo generare un plot per i nosri valri, possiamo farlo in maneira estreamemte semplice usando Matplotlib.","title":"Plot di array"},{"location":"02_numpy/08_plotting/#installazione-di-matplotlib","text":"pipenv install matplotlib Per esempio, se abbiamo un array come questo: a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22]) importiamo matplotlib: import matplotlib.pypplot as plt A questo punto, ci baster\u00e0 eseguire quesot comando: plt.plot(a)s","title":"Installazione di Matplotlib"},{"location":"03_pandas/01_intro/","text":"Cosa \u00e8 Pandas? \u00b6 pandas \u00e8 un package Python che fornisce delle strutture dati progettate per lavorare con dati \"relazionali\" (se abbiamo un background informatico) o \"etichettati\" (se il nsotro background \u00e8 pi\u00f9 da data scientist) in maniera semplice ed intuitiva. L'obiettivo di pandas \u00e8 diventare un blocco fondamentale per l'analisi di dati reali in Python. pandas \u00e8 adatto a diversi tipi di dati: dati tabellari con colonne eterogenee, come nelel tabelle SQL o nei fogli Excel; dati di serie temporali, sia ordinati sia non, non necessariamente a frequenza fissa matrici dati arbitrarie (sia tipizzate omogeneamente, sia eterogeneamente) con label in termini di righe e colonne ogni altra fofrma di dataset derivanti da osservazioni o statistiche I dati non devono essere necessariamente labellizzati per essere posizionati all'interno di una struttura dati pandas. Le due strutture dati primarei di pandas sono le Series (monodimensionali) ed i DataFrame (bidimensionali). Queste permettono dig estire la stragrande maggioranza dei tipici casi d'uso in finanza, statistica, scienze sociali, e molte aree ingegneristiche. Pandas \u00e8 inoltre stato creato a partire da NumPy, e si intera con altri ambienti per il calcolo scientifico, con molte altre librerie di terze parti.","title":"Cosa \u00e8 Pandas?"},{"location":"03_pandas/01_intro/#cosa-e-pandas","text":"pandas \u00e8 un package Python che fornisce delle strutture dati progettate per lavorare con dati \"relazionali\" (se abbiamo un background informatico) o \"etichettati\" (se il nsotro background \u00e8 pi\u00f9 da data scientist) in maniera semplice ed intuitiva. L'obiettivo di pandas \u00e8 diventare un blocco fondamentale per l'analisi di dati reali in Python. pandas \u00e8 adatto a diversi tipi di dati: dati tabellari con colonne eterogenee, come nelel tabelle SQL o nei fogli Excel; dati di serie temporali, sia ordinati sia non, non necessariamente a frequenza fissa matrici dati arbitrarie (sia tipizzate omogeneamente, sia eterogeneamente) con label in termini di righe e colonne ogni altra fofrma di dataset derivanti da osservazioni o statistiche I dati non devono essere necessariamente labellizzati per essere posizionati all'interno di una struttura dati pandas. Le due strutture dati primarei di pandas sono le Series (monodimensionali) ed i DataFrame (bidimensionali). Queste permettono dig estire la stragrande maggioranza dei tipici casi d'uso in finanza, statistica, scienze sociali, e molte aree ingegneristiche. Pandas \u00e8 inoltre stato creato a partire da NumPy, e si intera con altri ambienti per il calcolo scientifico, con molte altre librerie di terze parti.","title":"Cosa \u00e8 Pandas?"},{"location":"03_pandas/02_data_structure/","text":"Introduzione alle strutture dati \u00b6 Iniziamo con una rapida, non comprensiva overview delle strutture dati fondamentali in pandas. I comportamenti fondamentali a riguardo di tipo di dati, indicizzazione, ed axis labeling/alignment si applicano a tutti gli oggetti. Per iniziare, importiamo NumPy e carichiamo Pandas nel nostro namespace.","title":"Introduzione alle strutture dati"},{"location":"03_pandas/02_data_structure/#introduzione-alle-strutture-dati","text":"Iniziamo con una rapida, non comprensiva overview delle strutture dati fondamentali in pandas. I comportamenti fondamentali a riguardo di tipo di dati, indicizzazione, ed axis labeling/alignment si applicano a tutti gli oggetti. Per iniziare, importiamo NumPy e carichiamo Pandas nel nostro namespace.","title":"Introduzione alle strutture dati"},{"location":"03_pandas/03_basics/","text":"","title":"03 basics"},{"location":"03_pandas/04_io/","text":"","title":"04 io"},{"location":"03_pandas/05_indexing/","text":"","title":"05 indexing"},{"location":"03_pandas/06_merge_join_concat_comp/","text":"","title":"06 merge join concat comp"},{"location":"03_pandas/07_missing_data/","text":"","title":"07 missing data"},{"location":"03_pandas/08_visualization/","text":"","title":"08 visualization"},{"location":"04_appendici/a_configurazioni/","text":"Appendice A - Configurazioni \u00b6 Configurazione dell'ambiente di sviluppo \u00b6","title":"Appendice A - Configurazioni"},{"location":"04_appendici/a_configurazioni/#appendice-a-configurazioni","text":"","title":"Appendice A - Configurazioni"},{"location":"04_appendici/a_configurazioni/#configurazione-dellambiente-di-sviluppo","text":"","title":"Configurazione dell'ambiente di sviluppo"},{"location":"04_appendici/b_python/","text":"Appendice A - Python \u00b6 Tabella degli operatori booleani \u00b6 Operatore Operazione logica Esempio Risultato and AND 1 and 2 True or OR True or False True not NOT True is not False True","title":"Appendice B - Tabelle Python"},{"location":"04_appendici/b_python/#appendice-a-python","text":"","title":"Appendice A - Python"},{"location":"04_appendici/b_python/#tabella-degli-operatori-booleani","text":"Operatore Operazione logica Esempio Risultato and AND 1 and 2 True or OR True or False True not NOT True is not False True","title":"Tabella degli operatori booleani"}]}